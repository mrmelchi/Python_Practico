{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00a1Bienvenidos! El curso fue originalmente publicado en ingl\u00e9s por David Beazley. GitHub Pages | GitHub Repo Ha sido adaptado al espa\u00f1ol por Mario.Melchiori . Se comparte gratuitamente bajo el marco de la siguiente licencia Desde aqu\u00ed, todo es obra de --David Beazley ( https://dabeaz.com {.uri}), \\@dabeaz . Cuando aprend\u00ed Python por primera vez hace casi 27 a\u00f1os, me sorprendi\u00f3 de inmediato c\u00f3mo pod\u00eda aplicarlo de manera productiva a todo tipo de proyectos laborales complicados. Una d\u00e9cada despu\u00e9s, me encontr\u00e9 ense\u00f1\u00e1ndoles a otros la misma diversi\u00f3n. El resultado de esa ense\u00f1anza es este curso: un curso de Python que se ha ense\u00f1ado activamente a m\u00e1s de 400 grupos en persona desde 2007. Traders, administradores de sistemas, astr\u00f3nomos, pensadores e incluso unos cientos de cient\u00edficos espaciales que usaron Python para ayudar a aterrizar un rover en Marte, todos han tomado este curso. Ahora, me complace ponerlo a disposici\u00f3n bajo una licencia Creative Commons, completamente libre de spam, registros y otras tonter\u00edas. \u00a1Disfr\u00fatelo! (P.D.: Este curso trata sobre Python. Si quieres un curso de Python que trate sobre programaci\u00f3n, podr\u00edas considerar Programaci\u00f3n avanzada con Python ) \u00bfQu\u00e9 es esto? El material que ves aqu\u00ed es el n\u00facleo de un curso de capacitaci\u00f3n de Python dirigido por un instructor que se utiliza para la capacitaci\u00f3n corporativa y el desarrollo profesional. Estuvo en desarrollo continuo desde 2007 hasta 2019 y se prob\u00f3 en clases del mundo real. Por lo general, se ense\u00f1a de modo presencial durante un per\u00edodo de tres o cuatro d\u00edas, lo que requiere aproximadamente entre 25 y 35 horas de trabajo intenso. Esto incluye la realizaci\u00f3n de aproximadamente 130 ejercicios pr\u00e1cticos de codificaci\u00f3n. P\u00fablico objetivo Los estudiantes de este curso suelen ser cient\u00edficos, ingenieros y programadores profesionales que ya tienen experiencia en al menos otro lenguaje de programaci\u00f3n. No se requieren conocimientos previos de Python, pero se supone que se tienen conocimientos de temas de programaci\u00f3n comunes. La mayor\u00eda de los participantes encuentran el curso desafiante, incluso si ya han estado haciendo un poco de programaci\u00f3n en Python. Objetivos del curso El objetivo de este curso es cubrir los aspectos fundamentales de la programaci\u00f3n en Python con \u00e9nfasis en la escritura de scripts, la manipulaci\u00f3n b\u00e1sica de datos y la organizaci\u00f3n de programas. Al final de este curso, los estudiantes deber\u00edan ser capaces de comenzar a escribir programas \u00fatiles en Python por su cuenta o poder comprender y modificar el c\u00f3digo Python escrito por sus compa\u00f1eros de trabajo. Requisitos Para completar este curso, no necesita nada m\u00e1s que una instalaci\u00f3n b\u00e1sica de Python 3.6 o una versi\u00f3n m\u00e1s reciente y tiempo para trabajar en ella. Qu\u00e9 no es este curso Este no es un curso para principiantes absolutos sobre c\u00f3mo programar una computadora. Se supone que ya tienes experiencia en programaci\u00f3n en alg\u00fan otro lenguaje de programaci\u00f3n o en Python. Este no es un curso sobre desarrollo web. Ese es un circo diferente. Sin embargo, si te quedas para este circo, ver\u00e1s algunos actos interesantes, pero nada que involucre animales. Este no es un curso sobre el uso de herramientas que est\u00e1n escritas en Python. Se trata de aprender el lenguaje Python central. Este no es un curso para ingenieros de software sobre c\u00f3mo escribir o mantener una aplicaci\u00f3n Python de un mill\u00f3n de l\u00edneas. No escribo programas de ese tipo, ni tampoco lo hacen la mayor\u00eda de las empresas que usan Python, y t\u00fa tampoco deber\u00edas hacerlo. \u00a1Elimina algo de una vez! \u00a1Ll\u00e9vame al curso ya! Ok, ok. \u00a1Apunta tu navegador AQU\u00cd ! Discusi\u00f3n de la comunidad \u00bfQuieres debatir sobre el curso? Puedes unirte a la conversaci\u00f3n en Gitter . No puedo prometer una respuesta individual, pero quiz\u00e1s otros puedan sumarse para ayudar. Agradecimientos Lloren\u00e7 Muntaner fue fundamental en la conversi\u00f3n del contenido del curso de Apple Keynote a la estructura en l\u00ednea que ves aqu\u00ed. Varios instructores han presentado este curso en un momento u otro durante los \u00faltimos 12 a\u00f1os. Esto incluye (en orden alfab\u00e9tico): Ned Batchelder, Juan Pablo Claude, Mark Fenner, Michael Foord, Matt Harrison, Raymond Hettinger, Daniel Klein, Travis Oliphant, James Powell, Michael Selik, Hugo Shi, Ian Stokes-Rees, Yarko Tymciurak, Bryan Van de ven, Peter Wang y Mark Wiebe. Tambi\u00e9n me gustar\u00eda agradecer a los miles de estudiantes que han realizado este curso y han contribuido a su \u00e9xito con sus comentarios y discusiones. Preguntas y respuestas P: \u00bfHay videos del curso que pueda ver? No. Este curso se trata de que usted escriba c\u00f3digo Python, no de ver a otra persona. P: \u00bfC\u00f3mo se licencia este curso? Practical Python Programming tiene licencia Creative Commons Attribution ShareAlike 4.0 International License. P: \u00bfPuedo usar este material para ense\u00f1ar mi propio curso de Python? S\u00ed, siempre que se indique la atribuci\u00f3n correspondiente. P: \u00bfPuedo hacer trabajos derivados? S\u00ed, siempre que dichos trabajos tengan los mismos t\u00e9rminos de licencia y proporcionen la atribuci\u00f3n. P: \u00bfPuedo traducir esto a otro idioma? S\u00ed, eso ser\u00eda genial. Env\u00edeme un enlace cuando haya terminado. P: \u00bfPuedo transmitir en vivo el curso o hacer un video? \u00a1S\u00ed, adelante! Probablemente aprender\u00e1s mucho de Python haciendo eso. P: \u00bfPor qu\u00e9 no se cubri\u00f3 el tema X? Hay una cantidad limitada de material que se puede cubrir en 3 o 4 d\u00edas. Si no se cubri\u00f3, probablemente fue porque se cubri\u00f3 una vez y hizo que a todos les explotara la cabeza o nunca hubo tiempo suficiente para cubrirlo en primer lugar. Adem\u00e1s, este es un curso, no un manual de referencia de Python. P: \u00bfPor qu\u00e9 no se cubre el incre\u00edble {command} en el incre\u00edble {tool} ? El enfoque de este curso es aprender el lenguaje Python central, no aprender los nombres de los comandos en las herramientas. P: \u00bfEste curso se mantiene o se actualiza? Este curso representa un \"producto terminado\" que se ense\u00f1\u00f3 y desarroll\u00f3 durante m\u00e1s de una d\u00e9cada. No tengo planes de revisar significativamente el material en este momento, pero ocasionalmente corregir\u00e9 errores y agregar\u00e9 aclaraciones. P: \u00bfAceptan solicitudes de incorporaci\u00f3n de cambios? Se agradecen los informes de errores y pueden enviarse a trav\u00e9s del seguimiento de problemas . No se aceptan solicitudes de incorporaci\u00f3n de cambios, excepto por invitaci\u00f3n. Primero, env\u00ede un informe de problemas.","title":"Home"},{"location":"#bienvenidos","text":"El curso fue originalmente publicado en ingl\u00e9s por David Beazley. GitHub Pages | GitHub Repo Ha sido adaptado al espa\u00f1ol por Mario.Melchiori . Se comparte gratuitamente bajo el marco de la siguiente licencia Desde aqu\u00ed, todo es obra de --David Beazley ( https://dabeaz.com {.uri}), \\@dabeaz . Cuando aprend\u00ed Python por primera vez hace casi 27 a\u00f1os, me sorprendi\u00f3 de inmediato c\u00f3mo pod\u00eda aplicarlo de manera productiva a todo tipo de proyectos laborales complicados. Una d\u00e9cada despu\u00e9s, me encontr\u00e9 ense\u00f1\u00e1ndoles a otros la misma diversi\u00f3n. El resultado de esa ense\u00f1anza es este curso: un curso de Python que se ha ense\u00f1ado activamente a m\u00e1s de 400 grupos en persona desde 2007. Traders, administradores de sistemas, astr\u00f3nomos, pensadores e incluso unos cientos de cient\u00edficos espaciales que usaron Python para ayudar a aterrizar un rover en Marte, todos han tomado este curso. Ahora, me complace ponerlo a disposici\u00f3n bajo una licencia Creative Commons, completamente libre de spam, registros y otras tonter\u00edas. \u00a1Disfr\u00fatelo! (P.D.: Este curso trata sobre Python. Si quieres un curso de Python que trate sobre programaci\u00f3n, podr\u00edas considerar Programaci\u00f3n avanzada con Python )","title":"\u00a1Bienvenidos!"},{"location":"#que-es-esto","text":"El material que ves aqu\u00ed es el n\u00facleo de un curso de capacitaci\u00f3n de Python dirigido por un instructor que se utiliza para la capacitaci\u00f3n corporativa y el desarrollo profesional. Estuvo en desarrollo continuo desde 2007 hasta 2019 y se prob\u00f3 en clases del mundo real. Por lo general, se ense\u00f1a de modo presencial durante un per\u00edodo de tres o cuatro d\u00edas, lo que requiere aproximadamente entre 25 y 35 horas de trabajo intenso. Esto incluye la realizaci\u00f3n de aproximadamente 130 ejercicios pr\u00e1cticos de codificaci\u00f3n.","title":"\u00bfQu\u00e9 es esto?"},{"location":"#publico-objetivo","text":"Los estudiantes de este curso suelen ser cient\u00edficos, ingenieros y programadores profesionales que ya tienen experiencia en al menos otro lenguaje de programaci\u00f3n. No se requieren conocimientos previos de Python, pero se supone que se tienen conocimientos de temas de programaci\u00f3n comunes. La mayor\u00eda de los participantes encuentran el curso desafiante, incluso si ya han estado haciendo un poco de programaci\u00f3n en Python.","title":"P\u00fablico objetivo"},{"location":"#objetivos-del-curso","text":"El objetivo de este curso es cubrir los aspectos fundamentales de la programaci\u00f3n en Python con \u00e9nfasis en la escritura de scripts, la manipulaci\u00f3n b\u00e1sica de datos y la organizaci\u00f3n de programas. Al final de este curso, los estudiantes deber\u00edan ser capaces de comenzar a escribir programas \u00fatiles en Python por su cuenta o poder comprender y modificar el c\u00f3digo Python escrito por sus compa\u00f1eros de trabajo.","title":"Objetivos del curso"},{"location":"#requisitos","text":"Para completar este curso, no necesita nada m\u00e1s que una instalaci\u00f3n b\u00e1sica de Python 3.6 o una versi\u00f3n m\u00e1s reciente y tiempo para trabajar en ella.","title":"Requisitos"},{"location":"#que-no-es-este-curso","text":"Este no es un curso para principiantes absolutos sobre c\u00f3mo programar una computadora. Se supone que ya tienes experiencia en programaci\u00f3n en alg\u00fan otro lenguaje de programaci\u00f3n o en Python. Este no es un curso sobre desarrollo web. Ese es un circo diferente. Sin embargo, si te quedas para este circo, ver\u00e1s algunos actos interesantes, pero nada que involucre animales. Este no es un curso sobre el uso de herramientas que est\u00e1n escritas en Python. Se trata de aprender el lenguaje Python central. Este no es un curso para ingenieros de software sobre c\u00f3mo escribir o mantener una aplicaci\u00f3n Python de un mill\u00f3n de l\u00edneas. No escribo programas de ese tipo, ni tampoco lo hacen la mayor\u00eda de las empresas que usan Python, y t\u00fa tampoco deber\u00edas hacerlo. \u00a1Elimina algo de una vez!","title":"Qu\u00e9 no es este curso"},{"location":"#llevame-al-curso-ya","text":"Ok, ok. \u00a1Apunta tu navegador AQU\u00cd !","title":"\u00a1Ll\u00e9vame al curso ya!"},{"location":"#discusion-de-la-comunidad","text":"\u00bfQuieres debatir sobre el curso? Puedes unirte a la conversaci\u00f3n en Gitter . No puedo prometer una respuesta individual, pero quiz\u00e1s otros puedan sumarse para ayudar.","title":"Discusi\u00f3n de la comunidad"},{"location":"#agradecimientos","text":"Lloren\u00e7 Muntaner fue fundamental en la conversi\u00f3n del contenido del curso de Apple Keynote a la estructura en l\u00ednea que ves aqu\u00ed. Varios instructores han presentado este curso en un momento u otro durante los \u00faltimos 12 a\u00f1os. Esto incluye (en orden alfab\u00e9tico): Ned Batchelder, Juan Pablo Claude, Mark Fenner, Michael Foord, Matt Harrison, Raymond Hettinger, Daniel Klein, Travis Oliphant, James Powell, Michael Selik, Hugo Shi, Ian Stokes-Rees, Yarko Tymciurak, Bryan Van de ven, Peter Wang y Mark Wiebe. Tambi\u00e9n me gustar\u00eda agradecer a los miles de estudiantes que han realizado este curso y han contribuido a su \u00e9xito con sus comentarios y discusiones.","title":"Agradecimientos"},{"location":"#preguntas-y-respuestas","text":"","title":"Preguntas y respuestas"},{"location":"#p-hay-videos-del-curso-que-pueda-ver","text":"No. Este curso se trata de que usted escriba c\u00f3digo Python, no de ver a otra persona.","title":"P: \u00bfHay videos del curso que pueda ver?"},{"location":"#p-como-se-licencia-este-curso","text":"Practical Python Programming tiene licencia Creative Commons Attribution ShareAlike 4.0 International License.","title":"P: \u00bfC\u00f3mo se licencia este curso?"},{"location":"#p-puedo-usar-este-material-para-ensenar-mi-propio-curso-de-python","text":"S\u00ed, siempre que se indique la atribuci\u00f3n correspondiente.","title":"P: \u00bfPuedo usar este material para ense\u00f1ar mi propio curso de Python?"},{"location":"#p-puedo-hacer-trabajos-derivados","text":"S\u00ed, siempre que dichos trabajos tengan los mismos t\u00e9rminos de licencia y proporcionen la atribuci\u00f3n.","title":"P: \u00bfPuedo hacer trabajos derivados?"},{"location":"#p-puedo-traducir-esto-a-otro-idioma","text":"S\u00ed, eso ser\u00eda genial. Env\u00edeme un enlace cuando haya terminado.","title":"P: \u00bfPuedo traducir esto a otro idioma?"},{"location":"#p-puedo-transmitir-en-vivo-el-curso-o-hacer-un-video","text":"\u00a1S\u00ed, adelante! Probablemente aprender\u00e1s mucho de Python haciendo eso.","title":"P: \u00bfPuedo transmitir en vivo el curso o hacer un video?"},{"location":"#p-por-que-no-se-cubrio-el-tema-x","text":"Hay una cantidad limitada de material que se puede cubrir en 3 o 4 d\u00edas. Si no se cubri\u00f3, probablemente fue porque se cubri\u00f3 una vez y hizo que a todos les explotara la cabeza o nunca hubo tiempo suficiente para cubrirlo en primer lugar. Adem\u00e1s, este es un curso, no un manual de referencia de Python.","title":"P: \u00bfPor qu\u00e9 no se cubri\u00f3 el tema X?"},{"location":"#p-por-que-no-se-cubre-el-increible-command-en-el-increible-tool","text":"El enfoque de este curso es aprender el lenguaje Python central, no aprender los nombres de los comandos en las herramientas.","title":"P: \u00bfPor qu\u00e9 no se cubre el incre\u00edble {command} en el incre\u00edble {tool}?"},{"location":"#p-este-curso-se-mantiene-o-se-actualiza","text":"Este curso representa un \"producto terminado\" que se ense\u00f1\u00f3 y desarroll\u00f3 durante m\u00e1s de una d\u00e9cada. No tengo planes de revisar significativamente el material en este momento, pero ocasionalmente corregir\u00e9 errores y agregar\u00e9 aclaraciones.","title":"P: \u00bfEste curso se mantiene o se actualiza?"},{"location":"#p-aceptan-solicitudes-de-incorporacion-de-cambios","text":"Se agradecen los informes de errores y pueden enviarse a trav\u00e9s del seguimiento de problemas . No se aceptan solicitudes de incorporaci\u00f3n de cambios, excepto por invitaci\u00f3n. Primero, env\u00ede un informe de problemas.","title":"P: \u00bfAceptan solicitudes de incorporaci\u00f3n de cambios?"},{"location":"00_Setup/","text":"0. Configuraci\u00f3n y descripci\u00f3n general del curso \u00a1Bienvenido a Programaci\u00f3n Practica de Python! Esta p\u00e1gina contiene informaci\u00f3n importante sobre la configuraci\u00f3n y la log\u00edstica del curso. Duraci\u00f3n del curso y requisitos de tiempo Este curso se imparti\u00f3 originalmente como una capacitaci\u00f3n presencial dirigida por un instructor que dur\u00f3 de 3 a 4 d\u00edas. Para completar el curso en su totalidad, debe planificar un m\u00ednimo de 25 a 35 horas de trabajo. La mayor\u00eda de los participantes encuentran que el material es bastante desafiante sin echar un vistazo al c\u00f3digo de la soluci\u00f3n (ver a continuaci\u00f3n). Configuraci\u00f3n e instalaci\u00f3n de Python No necesita nada m\u00e1s que una instalaci\u00f3n b\u00e1sica de Python 3.6 o posterior. No hay dependencia de ning\u00fan sistema operativo, editor, IDE o herramientas adicionales relacionadas con Python en particular. No hay dependencias de terceros. Dicho esto, la mayor parte de este curso implica aprender a escribir scripts y peque\u00f1os programas que involucran la lectura de datos de archivos. Por lo tanto, debe asegurarse de estar en un entorno en el que pueda trabajar f\u00e1cilmente con archivos. Esto incluye el uso de un editor para crear programas Python y poder ejecutar esos programas desde el cmd/shell/terminal/bash. IMPORTANTE: En adelante los t\u00e9rminos cmd , shell , terminal , bash se utilizaran indistintamente con el mismo significado. Es posible que te sientas inclinado a trabajar en este curso utilizando un entorno m\u00e1s interactivo, como Jupyter Notebooks. \u00a1NO LO RECOMIENDO! Aunque los cuadernos son excelentes para la experimentaci\u00f3n, muchos de los ejercicios de este curso ense\u00f1an conceptos relacionados con la organizaci\u00f3n de programas. Esto incluye trabajar con funciones, m\u00f3dulos, declaraciones de importaci\u00f3n y refactorizaci\u00f3n de programas cuyo c\u00f3digo fuente abarca varios archivos. En mi experiencia, es dif\u00edcil replicar este tipo de entorno de trabajo en Jupyter Notebooks. Bifurcaci\u00f3n/clonaci\u00f3n del repositorio del curso Para preparar tu entorno para el curso, te recomiendo crear tu propia bifurcaci\u00f3n del repositorio de GitHub del curso en https://github.com/dabeaz-course/practical-python . Una vez que hayas terminado, puedes clonarlo en tu m\u00e1quina local: bash % git clone https://github.com/yourname/practical-python bash % cd practical-python bash % Haz todo tu trabajo dentro del directorio practical-python/ . Si env\u00edas el c\u00f3digo de tu soluci\u00f3n a tu bifurcaci\u00f3n del repositorio, esto mantendr\u00e1 todo tu c\u00f3digo junto en un solo lugar y tendr\u00e1s un buen registro hist\u00f3rico de tu trabajo cuando hayas terminado. Si no quieres crear una bifurcaci\u00f3n personal o no tienes una cuenta de GitHub, a\u00fan puedes clonar el directorio del curso en tu m\u00e1quina: bash % git clone https://github.com/dabeaz-course/practical-python``` bash % cd practical-python``` bash % En Windows, bash % deber\u00eda ser reemplazado por C:\\Users\\tu_nombre . Con esta opci\u00f3n, no podr\u00e1s confirmar cambios en el c\u00f3digo excepto en la copia local en tu m\u00e1quina. Dise\u00f1o del trabajo del curso Realiza todo tu trabajo de codificaci\u00f3n en el directorio Work/ . Dentro de ese directorio, hay un directorio Data/ . El directorio Data/ contiene una variedad de archivos de datos y otros scripts utilizados durante el curso. Con frecuencia tendr\u00e1s que acceder a archivos ubicados en Data/ . Los ejercicios del curso se escriben asumiendo que est\u00e1s creando programas en el directorio Work/ . Orden del curso El material del curso debe completarse en el orden de las secciones, comenzando con la secci\u00f3n 1. Los ejercicios del curso en las secciones posteriores se basan en el c\u00f3digo escrito en las secciones anteriores. Muchos de los ejercicios posteriores implican una refactorizaci\u00f3n menor del c\u00f3digo existente. C\u00f3digo de la soluci\u00f3n El directorio Solutions/ contiene el c\u00f3digo de la soluci\u00f3n completa para los ejercicios seleccionados. No dude en consultarlo si necesita una pista. Sin embargo, para aprovechar al m\u00e1ximo el curso, debe intentar crear sus propias soluciones primero. Contenido | Pr\u00f3ximo (1 Introducci\u00f3n a Python)","title":"0. Configuraci\u00f3n y descripci\u00f3n general del curso"},{"location":"00_Setup/#0-configuracion-y-descripcion-general-del-curso","text":"\u00a1Bienvenido a Programaci\u00f3n Practica de Python! Esta p\u00e1gina contiene informaci\u00f3n importante sobre la configuraci\u00f3n y la log\u00edstica del curso.","title":"0. Configuraci\u00f3n y descripci\u00f3n general del curso"},{"location":"00_Setup/#duracion-del-curso-y-requisitos-de-tiempo","text":"Este curso se imparti\u00f3 originalmente como una capacitaci\u00f3n presencial dirigida por un instructor que dur\u00f3 de 3 a 4 d\u00edas. Para completar el curso en su totalidad, debe planificar un m\u00ednimo de 25 a 35 horas de trabajo. La mayor\u00eda de los participantes encuentran que el material es bastante desafiante sin echar un vistazo al c\u00f3digo de la soluci\u00f3n (ver a continuaci\u00f3n).","title":"Duraci\u00f3n del curso y requisitos de tiempo"},{"location":"00_Setup/#configuracion-e-instalacion-de-python","text":"No necesita nada m\u00e1s que una instalaci\u00f3n b\u00e1sica de Python 3.6 o posterior. No hay dependencia de ning\u00fan sistema operativo, editor, IDE o herramientas adicionales relacionadas con Python en particular. No hay dependencias de terceros. Dicho esto, la mayor parte de este curso implica aprender a escribir scripts y peque\u00f1os programas que involucran la lectura de datos de archivos. Por lo tanto, debe asegurarse de estar en un entorno en el que pueda trabajar f\u00e1cilmente con archivos. Esto incluye el uso de un editor para crear programas Python y poder ejecutar esos programas desde el cmd/shell/terminal/bash. IMPORTANTE: En adelante los t\u00e9rminos cmd , shell , terminal , bash se utilizaran indistintamente con el mismo significado. Es posible que te sientas inclinado a trabajar en este curso utilizando un entorno m\u00e1s interactivo, como Jupyter Notebooks. \u00a1NO LO RECOMIENDO! Aunque los cuadernos son excelentes para la experimentaci\u00f3n, muchos de los ejercicios de este curso ense\u00f1an conceptos relacionados con la organizaci\u00f3n de programas. Esto incluye trabajar con funciones, m\u00f3dulos, declaraciones de importaci\u00f3n y refactorizaci\u00f3n de programas cuyo c\u00f3digo fuente abarca varios archivos. En mi experiencia, es dif\u00edcil replicar este tipo de entorno de trabajo en Jupyter Notebooks.","title":"Configuraci\u00f3n e instalaci\u00f3n de Python"},{"location":"00_Setup/#bifurcacionclonacion-del-repositorio-del-curso","text":"Para preparar tu entorno para el curso, te recomiendo crear tu propia bifurcaci\u00f3n del repositorio de GitHub del curso en https://github.com/dabeaz-course/practical-python . Una vez que hayas terminado, puedes clonarlo en tu m\u00e1quina local: bash % git clone https://github.com/yourname/practical-python bash % cd practical-python bash % Haz todo tu trabajo dentro del directorio practical-python/ . Si env\u00edas el c\u00f3digo de tu soluci\u00f3n a tu bifurcaci\u00f3n del repositorio, esto mantendr\u00e1 todo tu c\u00f3digo junto en un solo lugar y tendr\u00e1s un buen registro hist\u00f3rico de tu trabajo cuando hayas terminado. Si no quieres crear una bifurcaci\u00f3n personal o no tienes una cuenta de GitHub, a\u00fan puedes clonar el directorio del curso en tu m\u00e1quina: bash % git clone https://github.com/dabeaz-course/practical-python``` bash % cd practical-python``` bash % En Windows, bash % deber\u00eda ser reemplazado por C:\\Users\\tu_nombre . Con esta opci\u00f3n, no podr\u00e1s confirmar cambios en el c\u00f3digo excepto en la copia local en tu m\u00e1quina.","title":"Bifurcaci\u00f3n/clonaci\u00f3n del repositorio del curso"},{"location":"00_Setup/#diseno-del-trabajo-del-curso","text":"Realiza todo tu trabajo de codificaci\u00f3n en el directorio Work/ . Dentro de ese directorio, hay un directorio Data/ . El directorio Data/ contiene una variedad de archivos de datos y otros scripts utilizados durante el curso. Con frecuencia tendr\u00e1s que acceder a archivos ubicados en Data/ . Los ejercicios del curso se escriben asumiendo que est\u00e1s creando programas en el directorio Work/ .","title":"Dise\u00f1o del trabajo del curso"},{"location":"00_Setup/#orden-del-curso","text":"El material del curso debe completarse en el orden de las secciones, comenzando con la secci\u00f3n 1. Los ejercicios del curso en las secciones posteriores se basan en el c\u00f3digo escrito en las secciones anteriores. Muchos de los ejercicios posteriores implican una refactorizaci\u00f3n menor del c\u00f3digo existente.","title":"Orden del curso"},{"location":"00_Setup/#codigo-de-la-solucion","text":"El directorio Solutions/ contiene el c\u00f3digo de la soluci\u00f3n completa para los ejercicios seleccionados. No dude en consultarlo si necesita una pista. Sin embargo, para aprovechar al m\u00e1ximo el curso, debe intentar crear sus propias soluciones primero. Contenido | Pr\u00f3ximo (1 Introducci\u00f3n a Python)","title":"C\u00f3digo de la soluci\u00f3n"},{"location":"Contents/","text":"Programaci\u00f3n pr\u00e1ctica en Python Tabla de contenido 0. Configuraci\u00f3n del curso (\u00a1LEA PRIMERO!) 1. Introducci\u00f3n a Python 2. Trabajar con datos 3. Organizaci\u00f3n del programa 4. Classes y Objetos 5. Funcionamiento interno de los objetos de Python 6. Generadores 7. Algunos temas avanzados 8. Pruebas, registro y depuraci\u00f3n 9. Paquetes Consulte las Notas del instructor si planea impartiendo el curso. Inicio","title":"Programaci\u00f3n pr\u00e1ctica en Python"},{"location":"Contents/#programacion-practica-en-python","text":"","title":"Programaci\u00f3n pr\u00e1ctica en Python"},{"location":"Contents/#tabla-de-contenido","text":"0. Configuraci\u00f3n del curso (\u00a1LEA PRIMERO!) 1. Introducci\u00f3n a Python 2. Trabajar con datos 3. Organizaci\u00f3n del programa 4. Classes y Objetos 5. Funcionamiento interno de los objetos de Python 6. Generadores 7. Algunos temas avanzados 8. Pruebas, registro y depuraci\u00f3n 9. Paquetes Consulte las Notas del instructor si planea impartiendo el curso. Inicio","title":"Tabla de contenido"},{"location":"InstructorNotes/","text":"Programaci\u00f3n pr\u00e1ctica con Python - Notas para el instructor Autor: David Beazley Descripci\u00f3n general Este documento proporciona algunas notas generales y consejos sobre la ense\u00f1anza del contenido de mi curso \u201cPractical Python\u201d, incluidos los objetivos, el p\u00fablico objetivo, las partes complicadas, etc. Estas instrucciones se les dieron a las personas que imparten el curso en un entorno t\u00edpico de capacitaci\u00f3n corporativa de tres d\u00edas. Es posible que le brinden una idea sobre c\u00f3mo ense\u00f1ar su propio curso. P\u00fablico objetivo y enfoque general Este curso est\u00e1 destinado a ser un curso de \u201cIntroducci\u00f3n a Python\u201d para personas que ya tienen algo de experiencia en programaci\u00f3n. Este definitivamente no es un curso dise\u00f1ado para ense\u00f1ar a las personas \u201cprogramaci\u00f3n 101\u201d. Habiendo dicho eso, he observado que el estudiante t\u00edpico en un curso de Python tampoco es probable que sea un ingeniero de software o programador de n\u00facleo duro. En cambio, probablemente obtendr\u00e1 una mezcla de ingenieros, cient\u00edficos, programadores web y desarrolladores m\u00e1s inexpertos. La formaci\u00f3n de los estudiantes var\u00eda ampliamente. Es posible que tengas algunos estudiantes con mucha experiencia en C, C++ y Java, otros pueden saber PHP y HTML, otros pueden venir de herramientas como MATLAB y otros pueden no tener casi ninguna experiencia en \"programaci\u00f3n\" tradicional a pesar de mis mejores intentos por aclarar los requisitos previos. Con esto en mente, el curso apunta a ense\u00f1ar Python a trav\u00e9s del problema general de manipulaci\u00f3n de datos (datos del mercado de valores en particular). Este dominio ha sido elegido porque es simple y algo que todos deber\u00edan saber al respecto independientemente de su experiencia. Solo como ejemplo, es probable que los estudiantes con habilidades de programaci\u00f3n d\u00e9biles a\u00fan sepan sobre cosas comunes como usar una hoja de c\u00e1lculo (por ejemplo, Excel). Entonces, si est\u00e1n realmente estancados, puedes decirles cosas como \"bueno, esta lista de tuplas es como filas de datos en una hoja de c\u00e1lculo\" o \"una comprensi\u00f3n de listas es la misma idea que aplicar una operaci\u00f3n a una columna de la hoja de c\u00e1lculo y colocar el resultado en una columna diferente\". La idea clave es permanecer centrado en un entorno del mundo real en lugar de desviarse hacia problemas esot\u00e9ricos de \"ciencia inform\u00e1tica\" (por ejemplo, \"vamos a calcular los n\u00fameros de Fibonacci\"). Este dominio de problemas tambi\u00e9n funciona bien para introducir otros temas de programaci\u00f3n. Por ejemplo, los cient\u00edficos o ingenieros pueden querer saber sobre an\u00e1lisis de datos o gr\u00e1ficos. Por lo tanto, puede mostrarles c\u00f3mo hacer un gr\u00e1fico usando matplotlib. Los programadores web pueden querer saber c\u00f3mo presentar datos del mercado de valores en una p\u00e1gina web. Por lo tanto, puede hablar sobre motores de plantillas. Los administradores de sistemas pueden querer hacer algo con archivos de registro. Por lo tanto, puede indicarles un archivo de registro de datos burs\u00e1tiles en tiempo real. Los ingenieros de software pueden querer saber sobre dise\u00f1o. Por lo tanto, puede pedirles que busquen formas de encapsular datos burs\u00e1tiles dentro de un objeto o hacer que un programa sea extensible (por ejemplo, c\u00f3mo hacer que este programa produzca resultados en 10 formatos de tabla diferentes). Ya entiende la idea. Pautas de presentaci\u00f3n Las diapositivas de la presentaci\u00f3n (notas) est\u00e1n ah\u00ed para brindar una estructura narrativa al curso y para que los estudiantes las utilicen como referencia cuando trabajan en ejercicios. No repase laboriosamente cada punto de cada diapositiva; suponga que los estudiantes pueden leer y que tendr\u00e1n tiempo para volver a leer cuando est\u00e9n codificando. Suelo repasar las diapositivas a un ritmo bastante r\u00e1pido, mostrando ejemplos breves de manera interactiva a medida que avanzo. A menudo me salto diapositivas por completo a favor de demostraciones en vivo. Por ejemplo, no es necesario hacer un mont\u00f3n de diapositivas con listas. Simplemente vaya al int\u00e9rprete y haga algunos ejemplos de listas en vivo. Regla general: no m\u00e1s de 1 minuto por diapositiva, a menos que sea algo inusualmente complicado. Honestamente, probablemente podr\u00eda omitir la mayor\u00eda de las diapositivas y simplemente dar una clase con demostraciones en vivo si siente que funciona para usted. A menudo lo hago. Ejercicios del curso El curso tiene alrededor de 130 ejercicios pr\u00e1cticos. Si haces cada uno de los ejercicios y les das tiempo a los estudiantes para pensar y codificar, probablemente les llevar\u00e1 entre 10 y 12 horas. En la pr\u00e1ctica, probablemente encontrar\u00e1s que los estudiantes necesitan m\u00e1s tiempo en ciertos ejercicios. Tengo algunas notas sobre esto a continuaci\u00f3n. Debes enfatizar repetidamente a los estudiantes que el c\u00f3digo de la soluci\u00f3n est\u00e1 disponible y que est\u00e1 bien mirarlo y copiarlo, especialmente debido a los requisitos de tiempo. Antes de ense\u00f1ar el curso, te recomiendo encarecidamente que revises y trabajes en cada uno de los ejercicios del curso para que no haya sorpresas. Durante la impartici\u00f3n del curso, generalmente trabajo en cada uno de los ejercicios desde cero, sin mirar la soluci\u00f3n, en mi computadora mientras los estudiantes tambi\u00e9n trabajan. Para esto, te recomiendo encarecidamente que tengas una copia impresa de los ejercicios a mano que puedas mirar sin tener que abrirla en la pantalla de la computadora (que se est\u00e1 proyectando). Cerca del final del per\u00edodo de tiempo del ejercicio, comenzar\u00e9 a analizar mi c\u00f3digo de soluci\u00f3n, enfatizar\u00e9 diferentes partes en la pantalla y hablar\u00e9 sobre ellas. Si hay alg\u00fan problema potencial con la soluci\u00f3n (incluidas consideraciones de dise\u00f1o), tambi\u00e9n hablar\u00e9 de ello. Enfatice a los estudiantes que tal vez quieran ver o copiar el c\u00f3digo de la soluci\u00f3n antes de continuar. Contenido Secci\u00f3n 1: Introducci\u00f3n El objetivo principal de esta secci\u00f3n es que las personas se familiaricen con el entorno. Esto incluye el uso del shell interactivo y la edici\u00f3n/ejecuci\u00f3n de programas cortos. Al final de la secci\u00f3n, los estudiantes deber\u00edan poder escribir scripts cortos que lean archivos de datos y realicen peque\u00f1os c\u00e1lculos. Conocer\u00e1n los n\u00fameros, las cadenas, las listas y los archivos. Tambi\u00e9n habr\u00e1n tenido algo de exposici\u00f3n a funciones, excepciones y m\u00f3dulos, pero faltar\u00e1n muchos detalles. La primera parte de este curso suele ser la m\u00e1s larga porque los estudiantes son nuevos en las herramientas y pueden tener varios problemas para hacer que las cosas funcionen. Es absolutamente fundamental que recorra el sal\u00f3n y se asegure de que todos puedan editar, ejecutar y depurar programas simples. Aseg\u00farese de que Python est\u00e9 instalado correctamente. Aseg\u00farese de que hayan descargado los ejercicios del curso. Aseg\u00farese de que Internet funcione. Arregle cualquier otra cosa que surja. Tiempo: Mi objetivo es terminar la secci\u00f3n 1 alrededor del almuerzo del primer d\u00eda. Secci\u00f3n 2: Trabajar con datos Esta secci\u00f3n es probablemente la m\u00e1s importante del curso. Abarca los conceptos b\u00e1sicos de la representaci\u00f3n y manipulaci\u00f3n de datos, incluidas tuplas, listas, diccionarios y conjuntos. La secci\u00f3n 2.2 es la m\u00e1s importante. D\u00e9 a los estudiantes todo el tiempo que necesiten para que los ejercicios funcionen dentro de lo razonable. Seg\u00fan la audiencia, los ejercicios pueden durar 45 minutos. En la mitad de este ejercicio, a menudo avanzo a la Secci\u00f3n 2.3 (impresi\u00f3n formateada) y les doy a los estudiantes m\u00e1s tiempo para seguir trabajando. Juntas, las Secciones 2.2/2.3 pueden llevar una hora o m\u00e1s. La Secci\u00f3n 2.4 hace que las personas exploren el uso de enumerate() y zip(). Considero que estas funciones son esenciales, as\u00ed que no escatime en ella. La Secci\u00f3n 2.5 presenta el m\u00f3dulo de colecciones. Hay MUCHO que podr\u00eda decirse sobre las colecciones, pero los estudiantes no lo entender\u00e1n por completo en este momento. Aborde esto m\u00e1s desde el punto de vista de \"aqu\u00ed est\u00e1 este m\u00f3dulo interesante que deber\u00eda ver m\u00e1s adelante. Aqu\u00ed hay algunos ejemplos interesantes\". La Secci\u00f3n 2.6 presenta las comprensiones de listas, que son una caracter\u00edstica importante para procesar datos de listas. Enfatice a los estudiantes que las comprensiones de listas son muy similares a cosas como las consultas de bases de datos SQL. Al final de este ejercicio, a menudo hago una demostraci\u00f3n interactiva que involucra algo m\u00e1s avanzado. Tal vez haga una comprensi\u00f3n de listas y trace algunos datos con matplotlib. Tambi\u00e9n es una oportunidad para presentar Jupyter si as\u00ed lo desea. La Secci\u00f3n 2.7 es el ejercicio m\u00e1s sofisticado. Se relaciona con el uso de datos de primera clase en Python y el hecho de que las estructuras de datos como las listas pueden contener cualquier tipo de objeto que desee. Los ejercicios est\u00e1n relacionados con el an\u00e1lisis de columnas de datos en archivos CSV y los conceptos se reutilizan posteriormente en la Secci\u00f3n 3.2. Tiempo: lo ideal es terminar con la Secci\u00f3n 2 el primer d\u00eda. Sin embargo, es com\u00fan terminar con la Secci\u00f3n 2.5 o 2.6. Por lo tanto, no se asuste si siente que est\u00e1 un poco atrasado. Secci\u00f3n 3: Organizaci\u00f3n del programa El objetivo principal de esta secci\u00f3n es presentar m\u00e1s detalles sobre las funciones y alentar a los estudiantes a usarlas. La secci\u00f3n se construye a partir de funciones en m\u00f3dulos y escritura de scripts. La Secci\u00f3n 3.1 trata sobre pasar de la simple \"creaci\u00f3n de scripts\" a las funciones. Se debe disuadir a los estudiantes de escribir \"scripts\" desorganizados. En cambio, el c\u00f3digo debe al menos modularizarse en funciones. Hace que el c\u00f3digo sea m\u00e1s f\u00e1cil de entender, facilita la realizaci\u00f3n de cambios posteriormente y, de hecho, se ejecuta un poco m\u00e1s r\u00e1pido. Las funciones son buenas. La Secci\u00f3n 3.2 es probablemente el conjunto de ejercicios m\u00e1s avanzado de todo el curso. Hace que los estudiantes escriban una funci\u00f3n de utilidad de prop\u00f3sito general para analizar datos orientados a columnas. Sin embargo, hace un uso intensivo de listas por comprensi\u00f3n, as\u00ed como de listas de funciones (por ejemplo, funciones como objetos de primera clase). Probablemente necesitar\u00e1 guiar a las personas a trav\u00e9s de cada paso de este c\u00f3digo, mostrando c\u00f3mo funciona con gran detalle. Sin embargo, la recompensa es enorme: puede mostrar a las personas una funci\u00f3n de prop\u00f3sito general corta que hace algo incre\u00edblemente poderoso y que ser\u00eda pr\u00e1cticamente imposible de escribir en C, C++ o Java sin tener MUCHO c\u00f3digo muy complicado. Hay muchas posibles v\u00edas de dise\u00f1o/discusi\u00f3n para este c\u00f3digo. Use su imaginaci\u00f3n. La Secci\u00f3n 3.3 agrega el manejo de errores a la funci\u00f3n creada en la Secci\u00f3n 3.2. Este es un buen momento para hablar sobre el manejo de excepciones en general. Definitivamente, hable sobre los peligros de capturar todas las excepciones. Este podr\u00eda ser un buen momento para hablar sobre el elemento \u201cLos errores nunca deben pasar silenciosamente\u201d en el \u201cZen de Python\u201d. Nota: Antes del Ejercicio 3.4, aseg\u00farese de que los estudiantes obtengan versiones completamente funcionales de report.py, pcost.py y fileparse.py. C\u00f3pielas de la carpeta Soluciones si es necesario La Secci\u00f3n 3.4 presenta las importaciones de m\u00f3dulos. El archivo escrito en la Secci\u00f3n 3.2-3.3 se utiliza para simplificar el c\u00f3digo en la Secci\u00f3n 3.1. Tenga en cuenta que es posible que deba ayudar a los estudiantes a solucionar problemas con IDLE, sys.path y otras configuraciones variadas relacionadas con la importaci\u00f3n. La secci\u00f3n 3.5 habla sobre argumentos lineales. Puede que te sientas inclinado a hablar de un m\u00f3dulo como argparse. Sin embargo, ten en cuenta que hacerlo abre un atolladero. Por lo general, es mejor simplemente mencionarlo y seguir adelante. La secci\u00f3n 3.6 abre una discusi\u00f3n sobre el dise\u00f1o en general en Python. \u00bfEs mejor escribir c\u00f3digo que sea m\u00e1s flexible en lugar de c\u00f3digo que est\u00e9 programado para trabajar solo con nombres de archivo? Este es el primer lugar en el que se realiza un cambio de c\u00f3digo y se debe refactorizar el c\u00f3digo existente. A partir de aqu\u00ed, la mayor\u00eda de los ejercicios realizan peque\u00f1os cambios en el c\u00f3digo que ya se ha escrito. Secci\u00f3n 4: Clases y objetos Esta secci\u00f3n trata sobre programaci\u00f3n orientada a objetos muy b\u00e1sica. En general, no es seguro asumir que las personas tienen muchos conocimientos de OO. Por lo tanto, antes de comenzar, suelo describir en general el \u201cestilo\u201d de OO y c\u00f3mo se agrupan sus datos y m\u00e9todos. Realice algunos ejemplos con cadenas y listas para ilustrar que son \"objetos\" y que los m\u00e9todos (invocados mediante .) hacen cosas con el objeto. Enfatice c\u00f3mo los m\u00e9todos est\u00e1n asociados al objeto en s\u00ed. Por ejemplo, usted hace items.append(x), no llama a una funci\u00f3n separada append(items, x). La Secci\u00f3n 4.1 presenta la declaraci\u00f3n de clase y muestra a las personas c\u00f3mo crear un objeto b\u00e1sico. En realidad, esto solo presenta las clases como otra forma de definir una estructura de datos simple, en relaci\u00f3n con el uso de tuplas y diccionarios para este prop\u00f3sito en la Secci\u00f3n 2. La Secci\u00f3n 4.2 trata sobre la herencia y c\u00f3mo se usa para crear programas extensibles. Este conjunto de ejercicios es probablemente el m\u00e1s significativo en t\u00e9rminos de programaci\u00f3n orientada a objetos y dise\u00f1o orientado a objetos. D\u00e9 a los estudiantes mucho tiempo para trabajar en \u00e9l (30-45 minutos). Dependiendo del inter\u00e9s, puede pasar MUCHO tiempo discutiendo aspectos de la orientaci\u00f3n a objetos. Por ejemplo, diferentes patrones de dise\u00f1o, jerarqu\u00edas de herencia, clases base abstractas, etc. La Secci\u00f3n 4.3 realiza algunos experimentos con m\u00e9todos especiales. No dedicar\u00eda demasiado tiempo a perder el tiempo con esto. Los m\u00e9todos especiales aparecen un poco m\u00e1s adelante en el Ejercicio 6.1 y en otras partes. Tiempo: Esto suele ser al final del segundo d\u00eda. Secci\u00f3n 5: Dentro de los objetos Esta secci\u00f3n lleva a los estudiantes detr\u00e1s de escena del sistema de objetos y c\u00f3mo se construye utilizando diccionarios, c\u00f3mo se vinculan las instancias y las clases y c\u00f3mo funciona la herencia. Sin embargo, la parte m\u00e1s importante de esta secci\u00f3n es probablemente el material sobre encapsulaci\u00f3n (atributos privados, propiedades, ranuras, etc.) La Secci\u00f3n 5.1 simplemente quita las cubiertas y hace que los estudiantes observen y jueguen con los diccionarios subyacentes de instancias y clases. La Secci\u00f3n 5.2 trata sobre ocultar atributos detr\u00e1s de funciones get/set y el uso de propiedades. Normalmente hago hincapi\u00e9 en que estas t\u00e9cnicas se utilizan com\u00fanmente en bibliotecas y marcos de trabajo, especialmente en situaciones en las que se desea un mayor control sobre lo que se le permite hacer a un usuario. Un experto en Python notar\u00e1 que no hablo en absoluto sobre temas avanzados como descriptores o m\u00e9todos de acceso a atributos ( __getattr__ , __setattr__ ). He descubierto, a trav\u00e9s de la experiencia, que esto es demasiada sobrecarga mental para los estudiantes que toman el curso de introducci\u00f3n. La cabeza de todos ya est\u00e1 al borde de explotar en este punto y si hablas sobre c\u00f3mo funcionan algo como los descriptores, los perder\u00e1s por el resto del d\u00eda, si no por el resto del curso. Gu\u00e1rdalo para un curso de \"Python avanzado\". Si est\u00e1s mirando el reloj pensando \"No hay manera de que vaya a terminar este curso\", puedes saltarte la secci\u00f3n 5 por completo. Secci\u00f3n 6: Generadores El objetivo principal de esta secci\u00f3n es presentar los generadores como una forma de definir iteraciones personalizadas y utilizarlos para diversos problemas relacionados con el manejo de datos. Los ejercicios del curso hacen que los estudiantes analicen transmisiones de datos en forma de actualizaciones de stock que se escriben en un archivo de registro. Hay dos grandes ideas que destacar. Primero, los generadores se pueden utilizar para escribir c\u00f3digo basado en el procesamiento incremental. Esto puede ser muy \u00fatil para cosas como la transmisi\u00f3n de datos o conjuntos de datos enormes que son demasiado grandes para quepa en la memoria de una sola vez. La segunda idea es que se pueden encadenar generadores/iteradores para crear canales de procesamiento (algo as\u00ed como las tuber\u00edas de Unix). Nuevamente, esta puede ser una forma realmente poderosa de procesar y pensar en transmisiones, conjuntos de datos grandes, etc. Algunas omisiones: aunque se describe el protocolo de iteraci\u00f3n, las notas no detallan la creaci\u00f3n de objetos iterables (es decir, clases con __iter__() y next() ). En la pr\u00e1ctica, he descubierto que no es necesario hacer esto tan a menudo (los generadores suelen ser mejores/m\u00e1s f\u00e1ciles). Por lo tanto, en aras del tiempo, he tomado la decisi\u00f3n consciente de omitirlo. Tampoco se incluyen los generadores extendidos (corrutinas) ni los usos de los generadores para la concurrencia (tasklets, etc.). Eso es mejor que se trate en cursos avanzados. Secci\u00f3n 7: Temas avanzados B\u00e1sicamente, esta secci\u00f3n es una variedad de temas m\u00e1s avanzados que podr\u00edan haberse tratado antes, pero no se hicieron por varias razones relacionadas con el flujo del curso y el contenido de los ejercicios del curso. Si quieres saber, sol\u00eda presentar este material antes en el curso, pero ya estaba sobrecargado con suficiente informaci\u00f3n. Volver a \u00e9l m\u00e1s tarde parece funcionar mejor, especialmente porque a esta altura, todos est\u00e1n mucho m\u00e1s familiarizados con el trabajo en Python y comienzan a entenderlo. Los temas incluyen argumentos de funciones vari\u00e1dicas (*args, **kwargs), lambda, cierres y decoradores. La discusi\u00f3n de decoradores es solo una peque\u00f1a pista de lo que es posible con la metaprogramaci\u00f3n. Si\u00e9ntete libre de decir m\u00e1s sobre lo que es posible, \u00a1pero probablemente me mantendr\u00eda alejado de las metaclases! \u00daltimamente, he estado demostrando \"numba\" como un ejemplo de un decorador m\u00e1s interesante. Si tiene poco tiempo, puede omitir la mayor parte de la secci\u00f3n 7 o comprimirla en gran medida (por ejemplo, puede omitir ejercicios). Secci\u00f3n 8: Pruebas y depuraci\u00f3n El objetivo principal de esta secci\u00f3n es simplemente presentar varias herramientas y t\u00e9cnicas relacionadas con las pruebas, la depuraci\u00f3n y el desarrollo de software. Muestre a todos el m\u00f3dulo unittest. Presente el m\u00f3dulo de registro. Discuta las afirmaciones y la idea de los \"contratos\". Muestre a las personas el depurador y el generador de perfiles. La mayor parte de esto se explica por s\u00ed solo. Secci\u00f3n 9: Paquetes En este punto, los estudiantes han escrito una variedad de archivos (pcost.py, report.py, fileparse.py, tableformat.py, stock.py, portfolio.py, follow.py, etc.). Dos objetivos principales en esta secci\u00f3n. Primero, poner todo el c\u00f3digo en una estructura de paquete Python. Esta es solo una introducci\u00f3n suave a eso, pero mover\u00e1n los archivos a un directorio y todo se romper\u00e1. Tendr\u00e1n que corregir sus declaraciones de importaci\u00f3n (importaciones relativas a paquetes) y tal vez modificar un archivo __init__.py . Segundo objetivo: escribir un archivo setup.py simple que puedan usar para empaquetar el c\u00f3digo y d\u00e1rselo a alguien. Eso es todo. Fin del curso. Contenido","title":"Programaci\u00f3n pr\u00e1ctica con Python - Notas para el instructor"},{"location":"InstructorNotes/#programacion-practica-con-python-notas-para-el-instructor","text":"Autor: David Beazley","title":"Programaci\u00f3n pr\u00e1ctica con Python - Notas para el instructor"},{"location":"InstructorNotes/#descripcion-general","text":"Este documento proporciona algunas notas generales y consejos sobre la ense\u00f1anza del contenido de mi curso \u201cPractical Python\u201d, incluidos los objetivos, el p\u00fablico objetivo, las partes complicadas, etc. Estas instrucciones se les dieron a las personas que imparten el curso en un entorno t\u00edpico de capacitaci\u00f3n corporativa de tres d\u00edas. Es posible que le brinden una idea sobre c\u00f3mo ense\u00f1ar su propio curso.","title":"Descripci\u00f3n general"},{"location":"InstructorNotes/#publico-objetivo-y-enfoque-general","text":"Este curso est\u00e1 destinado a ser un curso de \u201cIntroducci\u00f3n a Python\u201d para personas que ya tienen algo de experiencia en programaci\u00f3n. Este definitivamente no es un curso dise\u00f1ado para ense\u00f1ar a las personas \u201cprogramaci\u00f3n 101\u201d. Habiendo dicho eso, he observado que el estudiante t\u00edpico en un curso de Python tampoco es probable que sea un ingeniero de software o programador de n\u00facleo duro. En cambio, probablemente obtendr\u00e1 una mezcla de ingenieros, cient\u00edficos, programadores web y desarrolladores m\u00e1s inexpertos. La formaci\u00f3n de los estudiantes var\u00eda ampliamente. Es posible que tengas algunos estudiantes con mucha experiencia en C, C++ y Java, otros pueden saber PHP y HTML, otros pueden venir de herramientas como MATLAB y otros pueden no tener casi ninguna experiencia en \"programaci\u00f3n\" tradicional a pesar de mis mejores intentos por aclarar los requisitos previos. Con esto en mente, el curso apunta a ense\u00f1ar Python a trav\u00e9s del problema general de manipulaci\u00f3n de datos (datos del mercado de valores en particular). Este dominio ha sido elegido porque es simple y algo que todos deber\u00edan saber al respecto independientemente de su experiencia. Solo como ejemplo, es probable que los estudiantes con habilidades de programaci\u00f3n d\u00e9biles a\u00fan sepan sobre cosas comunes como usar una hoja de c\u00e1lculo (por ejemplo, Excel). Entonces, si est\u00e1n realmente estancados, puedes decirles cosas como \"bueno, esta lista de tuplas es como filas de datos en una hoja de c\u00e1lculo\" o \"una comprensi\u00f3n de listas es la misma idea que aplicar una operaci\u00f3n a una columna de la hoja de c\u00e1lculo y colocar el resultado en una columna diferente\". La idea clave es permanecer centrado en un entorno del mundo real en lugar de desviarse hacia problemas esot\u00e9ricos de \"ciencia inform\u00e1tica\" (por ejemplo, \"vamos a calcular los n\u00fameros de Fibonacci\"). Este dominio de problemas tambi\u00e9n funciona bien para introducir otros temas de programaci\u00f3n. Por ejemplo, los cient\u00edficos o ingenieros pueden querer saber sobre an\u00e1lisis de datos o gr\u00e1ficos. Por lo tanto, puede mostrarles c\u00f3mo hacer un gr\u00e1fico usando matplotlib. Los programadores web pueden querer saber c\u00f3mo presentar datos del mercado de valores en una p\u00e1gina web. Por lo tanto, puede hablar sobre motores de plantillas. Los administradores de sistemas pueden querer hacer algo con archivos de registro. Por lo tanto, puede indicarles un archivo de registro de datos burs\u00e1tiles en tiempo real. Los ingenieros de software pueden querer saber sobre dise\u00f1o. Por lo tanto, puede pedirles que busquen formas de encapsular datos burs\u00e1tiles dentro de un objeto o hacer que un programa sea extensible (por ejemplo, c\u00f3mo hacer que este programa produzca resultados en 10 formatos de tabla diferentes). Ya entiende la idea.","title":"P\u00fablico objetivo y enfoque general"},{"location":"InstructorNotes/#pautas-de-presentacion","text":"Las diapositivas de la presentaci\u00f3n (notas) est\u00e1n ah\u00ed para brindar una estructura narrativa al curso y para que los estudiantes las utilicen como referencia cuando trabajan en ejercicios. No repase laboriosamente cada punto de cada diapositiva; suponga que los estudiantes pueden leer y que tendr\u00e1n tiempo para volver a leer cuando est\u00e9n codificando. Suelo repasar las diapositivas a un ritmo bastante r\u00e1pido, mostrando ejemplos breves de manera interactiva a medida que avanzo. A menudo me salto diapositivas por completo a favor de demostraciones en vivo. Por ejemplo, no es necesario hacer un mont\u00f3n de diapositivas con listas. Simplemente vaya al int\u00e9rprete y haga algunos ejemplos de listas en vivo. Regla general: no m\u00e1s de 1 minuto por diapositiva, a menos que sea algo inusualmente complicado. Honestamente, probablemente podr\u00eda omitir la mayor\u00eda de las diapositivas y simplemente dar una clase con demostraciones en vivo si siente que funciona para usted. A menudo lo hago.","title":"Pautas de presentaci\u00f3n"},{"location":"InstructorNotes/#ejercicios-del-curso","text":"El curso tiene alrededor de 130 ejercicios pr\u00e1cticos. Si haces cada uno de los ejercicios y les das tiempo a los estudiantes para pensar y codificar, probablemente les llevar\u00e1 entre 10 y 12 horas. En la pr\u00e1ctica, probablemente encontrar\u00e1s que los estudiantes necesitan m\u00e1s tiempo en ciertos ejercicios. Tengo algunas notas sobre esto a continuaci\u00f3n. Debes enfatizar repetidamente a los estudiantes que el c\u00f3digo de la soluci\u00f3n est\u00e1 disponible y que est\u00e1 bien mirarlo y copiarlo, especialmente debido a los requisitos de tiempo. Antes de ense\u00f1ar el curso, te recomiendo encarecidamente que revises y trabajes en cada uno de los ejercicios del curso para que no haya sorpresas. Durante la impartici\u00f3n del curso, generalmente trabajo en cada uno de los ejercicios desde cero, sin mirar la soluci\u00f3n, en mi computadora mientras los estudiantes tambi\u00e9n trabajan. Para esto, te recomiendo encarecidamente que tengas una copia impresa de los ejercicios a mano que puedas mirar sin tener que abrirla en la pantalla de la computadora (que se est\u00e1 proyectando). Cerca del final del per\u00edodo de tiempo del ejercicio, comenzar\u00e9 a analizar mi c\u00f3digo de soluci\u00f3n, enfatizar\u00e9 diferentes partes en la pantalla y hablar\u00e9 sobre ellas. Si hay alg\u00fan problema potencial con la soluci\u00f3n (incluidas consideraciones de dise\u00f1o), tambi\u00e9n hablar\u00e9 de ello. Enfatice a los estudiantes que tal vez quieran ver o copiar el c\u00f3digo de la soluci\u00f3n antes de continuar.","title":"Ejercicios del curso"},{"location":"InstructorNotes/#contenido","text":"","title":"Contenido"},{"location":"InstructorNotes/#seccion-1-introduccion","text":"El objetivo principal de esta secci\u00f3n es que las personas se familiaricen con el entorno. Esto incluye el uso del shell interactivo y la edici\u00f3n/ejecuci\u00f3n de programas cortos. Al final de la secci\u00f3n, los estudiantes deber\u00edan poder escribir scripts cortos que lean archivos de datos y realicen peque\u00f1os c\u00e1lculos. Conocer\u00e1n los n\u00fameros, las cadenas, las listas y los archivos. Tambi\u00e9n habr\u00e1n tenido algo de exposici\u00f3n a funciones, excepciones y m\u00f3dulos, pero faltar\u00e1n muchos detalles. La primera parte de este curso suele ser la m\u00e1s larga porque los estudiantes son nuevos en las herramientas y pueden tener varios problemas para hacer que las cosas funcionen. Es absolutamente fundamental que recorra el sal\u00f3n y se asegure de que todos puedan editar, ejecutar y depurar programas simples. Aseg\u00farese de que Python est\u00e9 instalado correctamente. Aseg\u00farese de que hayan descargado los ejercicios del curso. Aseg\u00farese de que Internet funcione. Arregle cualquier otra cosa que surja. Tiempo: Mi objetivo es terminar la secci\u00f3n 1 alrededor del almuerzo del primer d\u00eda.","title":"Secci\u00f3n 1: Introducci\u00f3n"},{"location":"InstructorNotes/#seccion-2-trabajar-con-datos","text":"Esta secci\u00f3n es probablemente la m\u00e1s importante del curso. Abarca los conceptos b\u00e1sicos de la representaci\u00f3n y manipulaci\u00f3n de datos, incluidas tuplas, listas, diccionarios y conjuntos. La secci\u00f3n 2.2 es la m\u00e1s importante. D\u00e9 a los estudiantes todo el tiempo que necesiten para que los ejercicios funcionen dentro de lo razonable. Seg\u00fan la audiencia, los ejercicios pueden durar 45 minutos. En la mitad de este ejercicio, a menudo avanzo a la Secci\u00f3n 2.3 (impresi\u00f3n formateada) y les doy a los estudiantes m\u00e1s tiempo para seguir trabajando. Juntas, las Secciones 2.2/2.3 pueden llevar una hora o m\u00e1s. La Secci\u00f3n 2.4 hace que las personas exploren el uso de enumerate() y zip(). Considero que estas funciones son esenciales, as\u00ed que no escatime en ella. La Secci\u00f3n 2.5 presenta el m\u00f3dulo de colecciones. Hay MUCHO que podr\u00eda decirse sobre las colecciones, pero los estudiantes no lo entender\u00e1n por completo en este momento. Aborde esto m\u00e1s desde el punto de vista de \"aqu\u00ed est\u00e1 este m\u00f3dulo interesante que deber\u00eda ver m\u00e1s adelante. Aqu\u00ed hay algunos ejemplos interesantes\". La Secci\u00f3n 2.6 presenta las comprensiones de listas, que son una caracter\u00edstica importante para procesar datos de listas. Enfatice a los estudiantes que las comprensiones de listas son muy similares a cosas como las consultas de bases de datos SQL. Al final de este ejercicio, a menudo hago una demostraci\u00f3n interactiva que involucra algo m\u00e1s avanzado. Tal vez haga una comprensi\u00f3n de listas y trace algunos datos con matplotlib. Tambi\u00e9n es una oportunidad para presentar Jupyter si as\u00ed lo desea. La Secci\u00f3n 2.7 es el ejercicio m\u00e1s sofisticado. Se relaciona con el uso de datos de primera clase en Python y el hecho de que las estructuras de datos como las listas pueden contener cualquier tipo de objeto que desee. Los ejercicios est\u00e1n relacionados con el an\u00e1lisis de columnas de datos en archivos CSV y los conceptos se reutilizan posteriormente en la Secci\u00f3n 3.2. Tiempo: lo ideal es terminar con la Secci\u00f3n 2 el primer d\u00eda. Sin embargo, es com\u00fan terminar con la Secci\u00f3n 2.5 o 2.6. Por lo tanto, no se asuste si siente que est\u00e1 un poco atrasado.","title":"Secci\u00f3n 2: Trabajar con datos"},{"location":"InstructorNotes/#seccion-3-organizacion-del-programa","text":"El objetivo principal de esta secci\u00f3n es presentar m\u00e1s detalles sobre las funciones y alentar a los estudiantes a usarlas. La secci\u00f3n se construye a partir de funciones en m\u00f3dulos y escritura de scripts. La Secci\u00f3n 3.1 trata sobre pasar de la simple \"creaci\u00f3n de scripts\" a las funciones. Se debe disuadir a los estudiantes de escribir \"scripts\" desorganizados. En cambio, el c\u00f3digo debe al menos modularizarse en funciones. Hace que el c\u00f3digo sea m\u00e1s f\u00e1cil de entender, facilita la realizaci\u00f3n de cambios posteriormente y, de hecho, se ejecuta un poco m\u00e1s r\u00e1pido. Las funciones son buenas. La Secci\u00f3n 3.2 es probablemente el conjunto de ejercicios m\u00e1s avanzado de todo el curso. Hace que los estudiantes escriban una funci\u00f3n de utilidad de prop\u00f3sito general para analizar datos orientados a columnas. Sin embargo, hace un uso intensivo de listas por comprensi\u00f3n, as\u00ed como de listas de funciones (por ejemplo, funciones como objetos de primera clase). Probablemente necesitar\u00e1 guiar a las personas a trav\u00e9s de cada paso de este c\u00f3digo, mostrando c\u00f3mo funciona con gran detalle. Sin embargo, la recompensa es enorme: puede mostrar a las personas una funci\u00f3n de prop\u00f3sito general corta que hace algo incre\u00edblemente poderoso y que ser\u00eda pr\u00e1cticamente imposible de escribir en C, C++ o Java sin tener MUCHO c\u00f3digo muy complicado. Hay muchas posibles v\u00edas de dise\u00f1o/discusi\u00f3n para este c\u00f3digo. Use su imaginaci\u00f3n. La Secci\u00f3n 3.3 agrega el manejo de errores a la funci\u00f3n creada en la Secci\u00f3n 3.2. Este es un buen momento para hablar sobre el manejo de excepciones en general. Definitivamente, hable sobre los peligros de capturar todas las excepciones. Este podr\u00eda ser un buen momento para hablar sobre el elemento \u201cLos errores nunca deben pasar silenciosamente\u201d en el \u201cZen de Python\u201d. Nota: Antes del Ejercicio 3.4, aseg\u00farese de que los estudiantes obtengan versiones completamente funcionales de report.py, pcost.py y fileparse.py. C\u00f3pielas de la carpeta Soluciones si es necesario La Secci\u00f3n 3.4 presenta las importaciones de m\u00f3dulos. El archivo escrito en la Secci\u00f3n 3.2-3.3 se utiliza para simplificar el c\u00f3digo en la Secci\u00f3n 3.1. Tenga en cuenta que es posible que deba ayudar a los estudiantes a solucionar problemas con IDLE, sys.path y otras configuraciones variadas relacionadas con la importaci\u00f3n. La secci\u00f3n 3.5 habla sobre argumentos lineales. Puede que te sientas inclinado a hablar de un m\u00f3dulo como argparse. Sin embargo, ten en cuenta que hacerlo abre un atolladero. Por lo general, es mejor simplemente mencionarlo y seguir adelante. La secci\u00f3n 3.6 abre una discusi\u00f3n sobre el dise\u00f1o en general en Python. \u00bfEs mejor escribir c\u00f3digo que sea m\u00e1s flexible en lugar de c\u00f3digo que est\u00e9 programado para trabajar solo con nombres de archivo? Este es el primer lugar en el que se realiza un cambio de c\u00f3digo y se debe refactorizar el c\u00f3digo existente. A partir de aqu\u00ed, la mayor\u00eda de los ejercicios realizan peque\u00f1os cambios en el c\u00f3digo que ya se ha escrito.","title":"Secci\u00f3n 3: Organizaci\u00f3n del programa"},{"location":"InstructorNotes/#seccion-4-clases-y-objetos","text":"Esta secci\u00f3n trata sobre programaci\u00f3n orientada a objetos muy b\u00e1sica. En general, no es seguro asumir que las personas tienen muchos conocimientos de OO. Por lo tanto, antes de comenzar, suelo describir en general el \u201cestilo\u201d de OO y c\u00f3mo se agrupan sus datos y m\u00e9todos. Realice algunos ejemplos con cadenas y listas para ilustrar que son \"objetos\" y que los m\u00e9todos (invocados mediante .) hacen cosas con el objeto. Enfatice c\u00f3mo los m\u00e9todos est\u00e1n asociados al objeto en s\u00ed. Por ejemplo, usted hace items.append(x), no llama a una funci\u00f3n separada append(items, x). La Secci\u00f3n 4.1 presenta la declaraci\u00f3n de clase y muestra a las personas c\u00f3mo crear un objeto b\u00e1sico. En realidad, esto solo presenta las clases como otra forma de definir una estructura de datos simple, en relaci\u00f3n con el uso de tuplas y diccionarios para este prop\u00f3sito en la Secci\u00f3n 2. La Secci\u00f3n 4.2 trata sobre la herencia y c\u00f3mo se usa para crear programas extensibles. Este conjunto de ejercicios es probablemente el m\u00e1s significativo en t\u00e9rminos de programaci\u00f3n orientada a objetos y dise\u00f1o orientado a objetos. D\u00e9 a los estudiantes mucho tiempo para trabajar en \u00e9l (30-45 minutos). Dependiendo del inter\u00e9s, puede pasar MUCHO tiempo discutiendo aspectos de la orientaci\u00f3n a objetos. Por ejemplo, diferentes patrones de dise\u00f1o, jerarqu\u00edas de herencia, clases base abstractas, etc. La Secci\u00f3n 4.3 realiza algunos experimentos con m\u00e9todos especiales. No dedicar\u00eda demasiado tiempo a perder el tiempo con esto. Los m\u00e9todos especiales aparecen un poco m\u00e1s adelante en el Ejercicio 6.1 y en otras partes. Tiempo: Esto suele ser al final del segundo d\u00eda.","title":"Secci\u00f3n 4: Clases y objetos"},{"location":"InstructorNotes/#seccion-5-dentro-de-los-objetos","text":"Esta secci\u00f3n lleva a los estudiantes detr\u00e1s de escena del sistema de objetos y c\u00f3mo se construye utilizando diccionarios, c\u00f3mo se vinculan las instancias y las clases y c\u00f3mo funciona la herencia. Sin embargo, la parte m\u00e1s importante de esta secci\u00f3n es probablemente el material sobre encapsulaci\u00f3n (atributos privados, propiedades, ranuras, etc.) La Secci\u00f3n 5.1 simplemente quita las cubiertas y hace que los estudiantes observen y jueguen con los diccionarios subyacentes de instancias y clases. La Secci\u00f3n 5.2 trata sobre ocultar atributos detr\u00e1s de funciones get/set y el uso de propiedades. Normalmente hago hincapi\u00e9 en que estas t\u00e9cnicas se utilizan com\u00fanmente en bibliotecas y marcos de trabajo, especialmente en situaciones en las que se desea un mayor control sobre lo que se le permite hacer a un usuario. Un experto en Python notar\u00e1 que no hablo en absoluto sobre temas avanzados como descriptores o m\u00e9todos de acceso a atributos ( __getattr__ , __setattr__ ). He descubierto, a trav\u00e9s de la experiencia, que esto es demasiada sobrecarga mental para los estudiantes que toman el curso de introducci\u00f3n. La cabeza de todos ya est\u00e1 al borde de explotar en este punto y si hablas sobre c\u00f3mo funcionan algo como los descriptores, los perder\u00e1s por el resto del d\u00eda, si no por el resto del curso. Gu\u00e1rdalo para un curso de \"Python avanzado\". Si est\u00e1s mirando el reloj pensando \"No hay manera de que vaya a terminar este curso\", puedes saltarte la secci\u00f3n 5 por completo.","title":"Secci\u00f3n 5: Dentro de los objetos"},{"location":"InstructorNotes/#seccion-6-generadores","text":"El objetivo principal de esta secci\u00f3n es presentar los generadores como una forma de definir iteraciones personalizadas y utilizarlos para diversos problemas relacionados con el manejo de datos. Los ejercicios del curso hacen que los estudiantes analicen transmisiones de datos en forma de actualizaciones de stock que se escriben en un archivo de registro. Hay dos grandes ideas que destacar. Primero, los generadores se pueden utilizar para escribir c\u00f3digo basado en el procesamiento incremental. Esto puede ser muy \u00fatil para cosas como la transmisi\u00f3n de datos o conjuntos de datos enormes que son demasiado grandes para quepa en la memoria de una sola vez. La segunda idea es que se pueden encadenar generadores/iteradores para crear canales de procesamiento (algo as\u00ed como las tuber\u00edas de Unix). Nuevamente, esta puede ser una forma realmente poderosa de procesar y pensar en transmisiones, conjuntos de datos grandes, etc. Algunas omisiones: aunque se describe el protocolo de iteraci\u00f3n, las notas no detallan la creaci\u00f3n de objetos iterables (es decir, clases con __iter__() y next() ). En la pr\u00e1ctica, he descubierto que no es necesario hacer esto tan a menudo (los generadores suelen ser mejores/m\u00e1s f\u00e1ciles). Por lo tanto, en aras del tiempo, he tomado la decisi\u00f3n consciente de omitirlo. Tampoco se incluyen los generadores extendidos (corrutinas) ni los usos de los generadores para la concurrencia (tasklets, etc.). Eso es mejor que se trate en cursos avanzados.","title":"Secci\u00f3n 6: Generadores"},{"location":"InstructorNotes/#seccion-7-temas-avanzados","text":"B\u00e1sicamente, esta secci\u00f3n es una variedad de temas m\u00e1s avanzados que podr\u00edan haberse tratado antes, pero no se hicieron por varias razones relacionadas con el flujo del curso y el contenido de los ejercicios del curso. Si quieres saber, sol\u00eda presentar este material antes en el curso, pero ya estaba sobrecargado con suficiente informaci\u00f3n. Volver a \u00e9l m\u00e1s tarde parece funcionar mejor, especialmente porque a esta altura, todos est\u00e1n mucho m\u00e1s familiarizados con el trabajo en Python y comienzan a entenderlo. Los temas incluyen argumentos de funciones vari\u00e1dicas (*args, **kwargs), lambda, cierres y decoradores. La discusi\u00f3n de decoradores es solo una peque\u00f1a pista de lo que es posible con la metaprogramaci\u00f3n. Si\u00e9ntete libre de decir m\u00e1s sobre lo que es posible, \u00a1pero probablemente me mantendr\u00eda alejado de las metaclases! \u00daltimamente, he estado demostrando \"numba\" como un ejemplo de un decorador m\u00e1s interesante. Si tiene poco tiempo, puede omitir la mayor parte de la secci\u00f3n 7 o comprimirla en gran medida (por ejemplo, puede omitir ejercicios).","title":"Secci\u00f3n 7: Temas avanzados"},{"location":"InstructorNotes/#seccion-8-pruebas-y-depuracion","text":"El objetivo principal de esta secci\u00f3n es simplemente presentar varias herramientas y t\u00e9cnicas relacionadas con las pruebas, la depuraci\u00f3n y el desarrollo de software. Muestre a todos el m\u00f3dulo unittest. Presente el m\u00f3dulo de registro. Discuta las afirmaciones y la idea de los \"contratos\". Muestre a las personas el depurador y el generador de perfiles. La mayor parte de esto se explica por s\u00ed solo.","title":"Secci\u00f3n 8: Pruebas y depuraci\u00f3n"},{"location":"InstructorNotes/#seccion-9-paquetes","text":"En este punto, los estudiantes han escrito una variedad de archivos (pcost.py, report.py, fileparse.py, tableformat.py, stock.py, portfolio.py, follow.py, etc.). Dos objetivos principales en esta secci\u00f3n. Primero, poner todo el c\u00f3digo en una estructura de paquete Python. Esta es solo una introducci\u00f3n suave a eso, pero mover\u00e1n los archivos a un directorio y todo se romper\u00e1. Tendr\u00e1n que corregir sus declaraciones de importaci\u00f3n (importaciones relativas a paquetes) y tal vez modificar un archivo __init__.py . Segundo objetivo: escribir un archivo setup.py simple que puedan usar para empaquetar el c\u00f3digo y d\u00e1rselo a alguien. Eso es todo. Fin del curso. Contenido","title":"Secci\u00f3n 9: Paquetes"},{"location":"LICENSE/","text":"creative commons Attribution-ShareAlike 4.0 International Creative Commons Corporation (\u201cCreative Commons\u201d) no es un bufete de abogados y no proporciona servicios legales ni asesoramiento legal. La distribuci\u00f3n de licencias p\u00fablicas de Creative Commons no crea una relaci\u00f3n abogado-cliente ni de ning\u00fan otro tipo. Creative Commons pone a disposici\u00f3n sus licencias e informaci\u00f3n relacionada \u201ctal cual\u201d. Creative Commons no ofrece garant\u00edas con respecto a sus licencias, ning\u00fan material licenciado bajo sus t\u00e9rminos y condiciones, ni ninguna informaci\u00f3n relacionada. Creative Commons renuncia a toda responsabilidad por da\u00f1os resultantes de su uso en la mayor medida posible. Uso de licencias p\u00fablicas de Creative Commons Las licencias p\u00fablicas de Creative Commons proporcionan un conjunto est\u00e1ndar de t\u00e9rminos y condiciones que los creadores y otros titulares de derechos pueden utilizar para compartir obras originales de autor\u00eda y otro material sujeto a derechos de autor y otros derechos especificados en la licencia p\u00fablica a continuaci\u00f3n. Las siguientes consideraciones son solo para fines informativos, no son exhaustivas y no forman parte de nuestras licencias. Consideraciones para los licenciantes: Nuestras licencias p\u00fablicas est\u00e1n destinadas a ser utilizadas por aquellos autorizados a dar al p\u00fablico permiso para usar material en formas que de otro modo estar\u00edan restringidas por los derechos de autor y otros derechos determinados. Nuestras licencias son irrevocables. Los licenciantes deben leer y comprender los t\u00e9rminos y condiciones de la licencia que elijan antes de aplicarla. Los licenciantes tambi\u00e9n deben asegurar todos los derechos necesarios antes de aplicar nuestras licencias para que el p\u00fablico pueda reutilizar el material como se espera. Los licenciantes deben marcar claramente cualquier material que no est\u00e9 sujeto a la licencia. Esto incluye otro material con licencia CC o material utilizado bajo una excepci\u00f3n o limitaci\u00f3n a los derechos de autor. M\u00e1s consideraciones para los licenciantes . Consideraciones para el p\u00fablico: Al utilizar una de nuestras licencias p\u00fablicas, un licenciante otorga al p\u00fablico permiso para usar el material con licencia bajo t\u00e9rminos y condiciones espec\u00edficos. Si el permiso del licenciante no es necesario por alg\u00fan motivo (por ejemplo, debido a alguna excepci\u00f3n o limitaci\u00f3n aplicable a los derechos de autor), entonces ese uso no est\u00e1 regulado por la licencia. Nuestras licencias otorgan \u00fanicamente permisos en virtud de los derechos de autor y otros derechos que el licenciante tiene autoridad para otorgar. El uso del material licenciado puede estar restringido por otros motivos, incluso porque otros tengan derechos de autor u otros derechos sobre el material. El licenciante puede hacer solicitudes especiales, como pedir que se marquen o describan todos los cambios. Aunque nuestras licencias no lo exigen, se recomienda que respete esas solicitudes cuando sea razonable. M\u00e1s consideraciones para el p\u00fablico . Licencia p\u00fablica internacional Creative Commons Attribution-ShareAlike 4.0 Al ejercer los derechos licenciados (definidos a continuaci\u00f3n), acepta y se compromete a cumplir los t\u00e9rminos y condiciones de esta licencia p\u00fablica internacional Creative Commons Attribution-ShareAlike 4.0 (\"Licencia p\u00fablica\"). En la medida en que esta Licencia P\u00fablica pueda interpretarse como un contrato, se le otorgan los Derechos Licenciados a cambio de su aceptaci\u00f3n de estos t\u00e9rminos y condiciones, y el Licenciante le otorga dichos derechos a cambio de los beneficios que recibe al poner a disposici\u00f3n el Material Licenciado de conformidad con estos t\u00e9rminos y condiciones. Secci\u00f3n 1 \u2013 Definiciones. a. Material Adaptado significa material sujeto a Derechos de Autor y Derechos Similares que se deriva de o se basa en el Material Licenciado y en el que el Material Licenciado se traduce, altera, arregla, transforma o modifica de otra manera de una manera que requiere permiso de conformidad con los Derechos de Autor y Derechos Similares que posee el Licenciante. Para los fines de esta Licencia P\u00fablica, cuando el Material Licenciado es una obra musical, una interpretaci\u00f3n o una grabaci\u00f3n de sonido, el Material Adaptado siempre se produce cuando el Material Licenciado est\u00e1 sincronizado en relaci\u00f3n temporal con una imagen en movimiento. b. Licencia del Adaptador significa la licencia que Usted aplica a sus Derechos de Autor y Derechos Similares en sus contribuciones al Material Adaptado de conformidad con los t\u00e9rminos y condiciones de esta Licencia P\u00fablica. c. Licencia compatible con BY-SA significa una licencia incluida en creativecommons.org/compatiblelicenses , aprobada por Creative Commons como esencialmente equivalente a esta Licencia p\u00fablica. d. Copyright y derechos similares significa copyright y/o derechos similares estrechamente relacionados con el copyright, incluidos, sin limitaci\u00f3n, derechos de ejecuci\u00f3n, transmisi\u00f3n, grabaci\u00f3n de sonido y derechos de base de datos sui generis, sin importar c\u00f3mo se etiqueten o categoricen los derechos. Para los fines de esta Licencia p\u00fablica, los derechos especificados en la Secci\u00f3n 2(b)(1)-(2) no son derechos de autor y derechos similares. e. Medidas tecnol\u00f3gicas efectivas significa aquellas medidas que, en ausencia de una autoridad adecuada, no pueden eludirse en virtud de leyes que cumplan con las obligaciones establecidas en el Art\u00edculo 11 del Tratado de la OMPI sobre Derecho de Autor adoptado el 20 de diciembre de 1996 y/o acuerdos internacionales similares. f. Excepciones y limitaciones significa uso justo, trato justo y/o cualquier otra excepci\u00f3n o limitaci\u00f3n a los derechos de autor y derechos similares que se aplique a Su uso del Material con licencia. g. Elementos de la licencia significa los atributos de la licencia enumerados en el nombre de una Licencia p\u00fablica de Creative Commons. Los elementos de la licencia de esta Licencia p\u00fablica son Atribuci\u00f3n y Compartir por igual. h. Material con licencia significa la obra art\u00edstica o literaria, base de datos u otro material al que el Licenciante aplic\u00f3 esta Licencia p\u00fablica. i. Derechos Licenciados significa los derechos que se le otorgan a Usted sujetos a los t\u00e9rminos y condiciones de esta Licencia P\u00fablica, que se limitan a todos los Derechos de Autor y Derechos Similares que se aplican a Su uso del Material Licenciado y que el Licenciante tiene autoridad para licenciar. j. Licenciante significa la(s) persona(s) o entidad(es) que otorgan derechos bajo esta Licencia P\u00fablica. k. Compartir significa proporcionar material al p\u00fablico por cualquier medio o proceso que requiera permiso bajo los Derechos Licenciados, como reproducci\u00f3n, exhibici\u00f3n p\u00fablica, presentaci\u00f3n p\u00fablica, distribuci\u00f3n, difusi\u00f3n, comunicaci\u00f3n o importaci\u00f3n, y poner material a disposici\u00f3n del p\u00fablico, incluso de maneras en que los miembros del p\u00fablico puedan acceder al material desde un lugar y en un momento elegidos individualmente por ellos. l. Derechos Sui Generis de Bases de Datos significa derechos distintos de los derechos de autor resultantes de la Directiva 96/9/CE del Parlamento Europeo y del Consejo del 11 de marzo de 1996 sobre la protecci\u00f3n jur\u00eddica de las bases de datos, en su forma enmendada y/o sucedida, as\u00ed como otros derechos esencialmente equivalentes en cualquier parte del mundo. m. Usted significa la persona o entidad que ejerce los Derechos Licenciados bajo esta Licencia P\u00fablica. Su tiene un significado correspondiente. Secci\u00f3n 2 \u2013 Alcance. a. Concesi\u00f3n de la licencia. Sujeto a los t\u00e9rminos y condiciones de esta Licencia P\u00fablica, el Licenciante le otorga por la presente una licencia mundial, libre de regal\u00edas, no sublicenciable, no exclusiva e irrevocable para ejercer los Derechos Licenciados en el Material Licenciado para: A. reproducir y Compartir el Material Licenciado, en su totalidad o en parte; y B. producir, reproducir y Compartir Material Adaptado. Excepciones y Limitaciones. Para evitar dudas, cuando las Excepciones y Limitaciones se aplican a Su uso, esta Licencia P\u00fablica no se aplica y Usted no necesita cumplir con sus t\u00e9rminos y condiciones. Plazo. El plazo de esta Licencia P\u00fablica se especifica en la Secci\u00f3n 6(a). Medios y formatos; modificaciones t\u00e9cnicas permitidas. El Licenciante lo autoriza a ejercer los Derechos Licenciados en todos los medios y formatos ya sean conocidos o creados en el futuro, y a realizar las modificaciones t\u00e9cnicas necesarias para ello. El Licenciante renuncia y/o acepta no hacer valer ning\u00fan derecho o autoridad para prohibirle realizar las modificaciones t\u00e9cnicas necesarias para ejercer los Derechos Licenciados, incluidas las modificaciones t\u00e9cnicas necesarias para eludir las Medidas Tecnol\u00f3gicas Efectivas. Para los fines de esta Licencia P\u00fablica, la simple realizaci\u00f3n de modificaciones autorizadas por esta Secci\u00f3n 2(a)(4) nunca produce Material Adaptado. Destinatarios posteriores. A. Oferta del Licenciante: Material Licenciado. Todo destinatario del Material Licenciado recibe autom\u00e1ticamente una oferta del Licenciante para ejercer los Derechos Licenciados seg\u00fan los t\u00e9rminos y condiciones de esta Licencia P\u00fablica. B. __Oferta adicional del Licenciante: Material Adaptado. Cada receptor de Material Adaptado de Usted recibe autom\u00e1ticamente una oferta del Licenciante para ejercer los Derechos Licenciados en el Material Adaptado bajo las condiciones de la Licencia del Adaptador que Usted aplique. C. Sin restricciones posteriores. Usted no puede ofrecer ni imponer t\u00e9rminos o condiciones adicionales o diferentes, ni aplicar Medidas Tecnol\u00f3gicas Efectivas al Material Licenciado si al hacerlo restringe el ejercicio de los Derechos Licenciados por cualquier receptor del Material Licenciado. Sin respaldo. Nada en esta Licencia P\u00fablica constituye ni puede interpretarse como un permiso para afirmar o implicar que Usted est\u00e1, o que Su uso del Material Licenciado est\u00e1, relacionado con, o patrocinado, respaldado o concedido estatus oficial por, el Licenciante u otros designados para recibir atribuci\u00f3n seg\u00fan lo dispuesto en la Secci\u00f3n 3(a)(1)(A)(i). b. Otros derechos. Los derechos morales, como el derecho a la integridad, no est\u00e1n licenciados bajo esta Licencia P\u00fablica, ni tampoco lo est\u00e1n los derechos de publicidad, privacidad y/u otros derechos de personalidad similares; Sin embargo, en la medida de lo posible, el Licenciante renuncia y/o acepta no hacer valer dichos derechos que posee en la medida limitada necesaria para permitirle ejercer los Derechos Licenciados, pero no de otra manera. Patente y cesi\u00f3n de derechos a cobrarle regal\u00edas por el ejercicio de los Derechos Licenciados, ya sea directamente o a trav\u00e9s de una sociedad de recaudaci\u00f3n en virtud de cualquier esquema de licencia obligatoria o estatutaria voluntaria o renunciable. En todos los dem\u00e1s casos, el Licenciante se reserva expresamente cualquier derecho a cobrar dichas regal\u00edas. Secci\u00f3n 3 \u2013 Condiciones de la Licencia. Su ejercicio de los Derechos Licenciados est\u00e1 expresamente sujeto a las siguientes condiciones. a. Atribuci\u00f3n. Si comparte el Material Licenciado (incluso en forma modificada), debe: A. conservar lo siguiente si el Licenciante lo proporciona con el Material Licenciado: i. identificaci\u00f3n del(los) creador(es) del Material Licenciado y cualquier otra persona designada para recibir atribuci\u00f3n, de cualquier manera razonable solicitada por el Licenciante (incluso mediante seud\u00f3nimo si se designa); ii. un aviso de derechos de autor; iii. un aviso que haga referencia a esta Licencia P\u00fablica; iv. un aviso que haga referencia a la exenci\u00f3n de garant\u00edas; v. un URI o hiperv\u00ednculo al Material Licenciado en la medida en que sea razonablemente posible; B. indicar si modific\u00f3 el Material Licenciado y conservar una indicaci\u00f3n de cualquier modificaci\u00f3n anterior; y C. indicar que el Material Licenciado est\u00e1 licenciado bajo esta Licencia P\u00fablica e incluir el texto de, o el URI o hiperv\u00ednculo a, esta Licencia P\u00fablica. Puede cumplir con las condiciones de la Secci\u00f3n 3(a)(1) de cualquier manera razonable seg\u00fan el medio, los medios y el contexto en los que comparta el Material Licenciado. Por ejemplo, puede ser razonable cumplir con las condiciones proporcionando un URI o hiperv\u00ednculo a un recurso que incluya la informaci\u00f3n requerida. Si el Licenciante lo solicita, debe eliminar cualquier informaci\u00f3n requerida por la Secci\u00f3n 3(a)(1)(A) en la medida en que sea razonablemente posible. b. ShareAlike. Adem\u00e1s de las condiciones de la Secci\u00f3n 3(a), si comparte material adaptado que produce, tambi\u00e9n se aplican las siguientes condiciones. La Licencia del Adaptador que usted aplica debe ser una licencia Creative Commons con los mismos Elementos de Licencia, esta versi\u00f3n o posterior, o una Licencia Compatible con BY-SA. Usted debe incluir el texto, el URI o el hiperv\u00ednculo a la Licencia del Adaptador que usted aplica. Usted puede satisfacer esta condici\u00f3n de cualquier manera razonable en funci\u00f3n del medio, los medios y el contexto en el que Usted Comparte el Material Adaptado. Usted no puede ofrecer ni imponer t\u00e9rminos o condiciones adicionales o diferentes, ni aplicar Medidas Tecnol\u00f3gicas Efectivas al Material Adaptado que restrinjan el ejercicio de los derechos otorgados bajo la Licencia del Adaptador que usted aplica. Secci\u00f3n 4 \u2013 Derechos de Base de Datos Sui Generis. Cuando los Derechos Licenciados incluyen Derechos de Base de Datos Sui Generis que se aplican a Su uso del Material Licenciado: a. para evitar dudas, la Secci\u00f3n 2(a)(1) le otorga el derecho a extraer, reutilizar, reproducir y Compartir todo o una parte sustancial de los contenidos de la base de datos; b. Si incluye la totalidad o una parte sustancial del contenido de la base de datos en una base de datos en la que tiene derechos sui generis sobre la base de datos, entonces la base de datos en la que tiene derechos sui generis sobre la base de datos (pero no su contenido individual) es material adaptado, incluso a los efectos de la Secci\u00f3n 3(b); y c. Debe cumplir con las condiciones de la Secci\u00f3n 3(a) si comparte la totalidad o una parte sustancial del contenido de la base de datos. Para evitar dudas, esta Secci\u00f3n 4 complementa y no reemplaza sus obligaciones bajo esta Licencia P\u00fablica cuando los Derechos Licenciados incluyen otros Derechos de Autor y Derechos Similares. Secci\u00f3n 5 \u2013 Renuncia de garant\u00edas y limitaci\u00f3n de responsabilidad. a. A menos que el Licenciante acuerde lo contrario por separado, en la medida de lo posible, el Licenciante ofrece el Material Licenciado tal como est\u00e1 y tal como est\u00e1 disponible, y no realiza declaraciones ni garant\u00edas de ning\u00fan tipo con respecto al Material Licenciado, ya sean expresas, impl\u00edcitas, legales u otras. Esto incluye, sin limitaci\u00f3n, garant\u00edas de t\u00edtulo, comerciabilidad, idoneidad para un fin determinado, no infracci\u00f3n, ausencia de defectos latentes o de otro tipo, precisi\u00f3n o presencia o ausencia de errores, sean o no conocidos o detectables. Cuando no se permitan descargos de responsabilidad de garant\u00edas en su totalidad o en parte, es posible que este descargo de responsabilidad no se aplique en su caso. b. En la medida de lo posible, en ning\u00fan caso el Licenciante ser\u00e1 responsable ante Usted en virtud de ninguna teor\u00eda legal (incluida, sin limitaci\u00f3n, la negligencia) o de otro modo por p\u00e9rdidas, costos, gastos o da\u00f1os directos, especiales, indirectos, incidentales, consecuentes, punitivos, ejemplares u otros que surjan de esta Licencia P\u00fablica o del uso del Material Licenciado, incluso si se le ha advertido al Licenciante de la posibilidad de dichas p\u00e9rdidas, costos, gastos o da\u00f1os. Cuando no se permita una limitaci\u00f3n de responsabilidad en su totalidad o en parte, es posible que esta limitaci\u00f3n no se aplique en su caso. c. La exenci\u00f3n de garant\u00edas y la limitaci\u00f3n de responsabilidad que se proporcionan anteriormente se interpretar\u00e1n de manera que, en la medida de lo posible, se respete la exenci\u00f3n de responsabilidad y la renuncia a toda responsabilidad. Secci\u00f3n 6: - Plazo y terminaci\u00f3n. a. Esta Licencia P\u00fablica se aplica durante el plazo de los derechos de autor y derechos similares aqu\u00ed licenciados. Sin embargo, si no cumple con esta Licencia P\u00fablica, sus derechos bajo esta Licencia P\u00fablica terminar\u00e1n autom\u00e1ticamente. b. Cuando su derecho a usar el Material Licenciado haya terminado seg\u00fan la Secci\u00f3n 6(a), se restablecer\u00e1: autom\u00e1ticamente a partir de la fecha en que se corrija la infracci\u00f3n, siempre que se corrija dentro de los 30 d\u00edas posteriores a que usted descubra la infracci\u00f3n; o tras el restablecimiento expreso por parte del Licenciante. Para evitar dudas, esta Secci\u00f3n 6(b) no afecta ning\u00fan derecho que el Licenciante pueda tener para buscar remedios por sus infracciones de esta Licencia P\u00fablica. c. Para evitar dudas, el Licenciante tambi\u00e9n puede ofrecer el Material Licenciado bajo t\u00e9rminos o condiciones separados o dejar de distribuir el Material Licenciado en cualquier momento; sin embargo, hacerlo no terminar\u00e1 esta Licencia P\u00fablica. d. Las Secciones 1, 5, 6, 7 y 8 sobreviven a la terminaci\u00f3n de esta Licencia P\u00fablica. Secci\u00f3n 7 \u2013 Otros T\u00e9rminos y Condiciones. a. El Licenciante no estar\u00e1 obligado por ning\u00fan t\u00e9rmino o condici\u00f3n adicional o diferente comunicado por Usted a menos que se acuerde expresamente. b. Todos los arreglos, entendimientos o acuerdos con respecto al Material Licenciado que no se indiquen en este documento son separados e independientes de los t\u00e9rminos y condiciones de esta Licencia P\u00fablica. Secci\u00f3n 8 \u2013 Interpretaci\u00f3n. a. Para evitar dudas, esta Licencia P\u00fablica no reduce, limita, restringe ni impone condiciones sobre ning\u00fan uso del Material Licenciado que pudiera realizarse legalmente sin permiso bajo esta Licencia P\u00fablica, y no se interpretar\u00e1 que lo hace. b. En la medida de lo posible, si alguna disposici\u00f3n de esta Licencia P\u00fablica se considera inaplicable, se reformar\u00e1 autom\u00e1ticamente en la medida m\u00ednima necesaria para que sea aplicable. Si la disposici\u00f3n no se puede reformar, se separar\u00e1 de esta Licencia P\u00fablica sin afectar la aplicabilidad de los t\u00e9rminos y condiciones restantes. c. No se eximir\u00e1 ning\u00fan t\u00e9rmino o condici\u00f3n de esta Licencia P\u00fablica ni se consentir\u00e1 ning\u00fan incumplimiento a menos que el Licenciante lo acepte expresamente. d. Nada de lo dispuesto en esta Licencia P\u00fablica constituye ni puede interpretarse como una limitaci\u00f3n o renuncia a los privilegios e inmunidades que se aplican al Licenciante o a Usted, incluidos los de los procesos legales de cualquier jurisdicci\u00f3n o autoridad. Creative Commons no es parte de sus licencias p\u00fablicas. No obstante, Creative Commons puede optar por aplicar una de sus licencias p\u00fablicas al material que publica y, en esos casos, se considerar\u00e1 el \"Licenciante\". Excepto con el prop\u00f3sito limitado de indicar que el material se comparte bajo una licencia p\u00fablica de Creative Commons o seg\u00fan lo permitan las pol\u00edticas de Creative Commons publicadas en [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons no autoriza el uso de la marca registrada \u201cCreative Commons\u201d ni de ninguna otra marca registrada o logotipo de Creative Commons sin su consentimiento previo por escrito, incluyendo, sin limitaci\u00f3n, en relaci\u00f3n con cualquier modificaci\u00f3n no autorizada de cualquiera de sus licencias p\u00fablicas o cualquier otro acuerdo, entendimiento o convenio relativo al uso de material con licencia. Para evitar dudas, este p\u00e1rrafo no forma parte de las licencias p\u00fablicas. Puede ponerse en contacto con Creative Commons en creativecommons.org","title":"LICENSE"},{"location":"LICENSE/#creative-commons","text":"","title":"creative commons"},{"location":"LICENSE/#attribution-sharealike-40-international","text":"Creative Commons Corporation (\u201cCreative Commons\u201d) no es un bufete de abogados y no proporciona servicios legales ni asesoramiento legal. La distribuci\u00f3n de licencias p\u00fablicas de Creative Commons no crea una relaci\u00f3n abogado-cliente ni de ning\u00fan otro tipo. Creative Commons pone a disposici\u00f3n sus licencias e informaci\u00f3n relacionada \u201ctal cual\u201d. Creative Commons no ofrece garant\u00edas con respecto a sus licencias, ning\u00fan material licenciado bajo sus t\u00e9rminos y condiciones, ni ninguna informaci\u00f3n relacionada. Creative Commons renuncia a toda responsabilidad por da\u00f1os resultantes de su uso en la mayor medida posible.","title":"Attribution-ShareAlike 4.0 International"},{"location":"LICENSE/#uso-de-licencias-publicas-de-creative-commons","text":"Las licencias p\u00fablicas de Creative Commons proporcionan un conjunto est\u00e1ndar de t\u00e9rminos y condiciones que los creadores y otros titulares de derechos pueden utilizar para compartir obras originales de autor\u00eda y otro material sujeto a derechos de autor y otros derechos especificados en la licencia p\u00fablica a continuaci\u00f3n. Las siguientes consideraciones son solo para fines informativos, no son exhaustivas y no forman parte de nuestras licencias. Consideraciones para los licenciantes: Nuestras licencias p\u00fablicas est\u00e1n destinadas a ser utilizadas por aquellos autorizados a dar al p\u00fablico permiso para usar material en formas que de otro modo estar\u00edan restringidas por los derechos de autor y otros derechos determinados. Nuestras licencias son irrevocables. Los licenciantes deben leer y comprender los t\u00e9rminos y condiciones de la licencia que elijan antes de aplicarla. Los licenciantes tambi\u00e9n deben asegurar todos los derechos necesarios antes de aplicar nuestras licencias para que el p\u00fablico pueda reutilizar el material como se espera. Los licenciantes deben marcar claramente cualquier material que no est\u00e9 sujeto a la licencia. Esto incluye otro material con licencia CC o material utilizado bajo una excepci\u00f3n o limitaci\u00f3n a los derechos de autor. M\u00e1s consideraciones para los licenciantes . Consideraciones para el p\u00fablico: Al utilizar una de nuestras licencias p\u00fablicas, un licenciante otorga al p\u00fablico permiso para usar el material con licencia bajo t\u00e9rminos y condiciones espec\u00edficos. Si el permiso del licenciante no es necesario por alg\u00fan motivo (por ejemplo, debido a alguna excepci\u00f3n o limitaci\u00f3n aplicable a los derechos de autor), entonces ese uso no est\u00e1 regulado por la licencia. Nuestras licencias otorgan \u00fanicamente permisos en virtud de los derechos de autor y otros derechos que el licenciante tiene autoridad para otorgar. El uso del material licenciado puede estar restringido por otros motivos, incluso porque otros tengan derechos de autor u otros derechos sobre el material. El licenciante puede hacer solicitudes especiales, como pedir que se marquen o describan todos los cambios. Aunque nuestras licencias no lo exigen, se recomienda que respete esas solicitudes cuando sea razonable. M\u00e1s consideraciones para el p\u00fablico .","title":"Uso de licencias p\u00fablicas de Creative Commons"},{"location":"LICENSE/#licencia-publica-internacional-creative-commons-attribution-sharealike-40","text":"Al ejercer los derechos licenciados (definidos a continuaci\u00f3n), acepta y se compromete a cumplir los t\u00e9rminos y condiciones de esta licencia p\u00fablica internacional Creative Commons Attribution-ShareAlike 4.0 (\"Licencia p\u00fablica\"). En la medida en que esta Licencia P\u00fablica pueda interpretarse como un contrato, se le otorgan los Derechos Licenciados a cambio de su aceptaci\u00f3n de estos t\u00e9rminos y condiciones, y el Licenciante le otorga dichos derechos a cambio de los beneficios que recibe al poner a disposici\u00f3n el Material Licenciado de conformidad con estos t\u00e9rminos y condiciones.","title":"Licencia p\u00fablica internacional Creative Commons Attribution-ShareAlike 4.0"},{"location":"LICENSE/#seccion-1-definiciones","text":"a. Material Adaptado significa material sujeto a Derechos de Autor y Derechos Similares que se deriva de o se basa en el Material Licenciado y en el que el Material Licenciado se traduce, altera, arregla, transforma o modifica de otra manera de una manera que requiere permiso de conformidad con los Derechos de Autor y Derechos Similares que posee el Licenciante. Para los fines de esta Licencia P\u00fablica, cuando el Material Licenciado es una obra musical, una interpretaci\u00f3n o una grabaci\u00f3n de sonido, el Material Adaptado siempre se produce cuando el Material Licenciado est\u00e1 sincronizado en relaci\u00f3n temporal con una imagen en movimiento. b. Licencia del Adaptador significa la licencia que Usted aplica a sus Derechos de Autor y Derechos Similares en sus contribuciones al Material Adaptado de conformidad con los t\u00e9rminos y condiciones de esta Licencia P\u00fablica. c. Licencia compatible con BY-SA significa una licencia incluida en creativecommons.org/compatiblelicenses , aprobada por Creative Commons como esencialmente equivalente a esta Licencia p\u00fablica. d. Copyright y derechos similares significa copyright y/o derechos similares estrechamente relacionados con el copyright, incluidos, sin limitaci\u00f3n, derechos de ejecuci\u00f3n, transmisi\u00f3n, grabaci\u00f3n de sonido y derechos de base de datos sui generis, sin importar c\u00f3mo se etiqueten o categoricen los derechos. Para los fines de esta Licencia p\u00fablica, los derechos especificados en la Secci\u00f3n 2(b)(1)-(2) no son derechos de autor y derechos similares. e. Medidas tecnol\u00f3gicas efectivas significa aquellas medidas que, en ausencia de una autoridad adecuada, no pueden eludirse en virtud de leyes que cumplan con las obligaciones establecidas en el Art\u00edculo 11 del Tratado de la OMPI sobre Derecho de Autor adoptado el 20 de diciembre de 1996 y/o acuerdos internacionales similares. f. Excepciones y limitaciones significa uso justo, trato justo y/o cualquier otra excepci\u00f3n o limitaci\u00f3n a los derechos de autor y derechos similares que se aplique a Su uso del Material con licencia. g. Elementos de la licencia significa los atributos de la licencia enumerados en el nombre de una Licencia p\u00fablica de Creative Commons. Los elementos de la licencia de esta Licencia p\u00fablica son Atribuci\u00f3n y Compartir por igual. h. Material con licencia significa la obra art\u00edstica o literaria, base de datos u otro material al que el Licenciante aplic\u00f3 esta Licencia p\u00fablica. i. Derechos Licenciados significa los derechos que se le otorgan a Usted sujetos a los t\u00e9rminos y condiciones de esta Licencia P\u00fablica, que se limitan a todos los Derechos de Autor y Derechos Similares que se aplican a Su uso del Material Licenciado y que el Licenciante tiene autoridad para licenciar. j. Licenciante significa la(s) persona(s) o entidad(es) que otorgan derechos bajo esta Licencia P\u00fablica. k. Compartir significa proporcionar material al p\u00fablico por cualquier medio o proceso que requiera permiso bajo los Derechos Licenciados, como reproducci\u00f3n, exhibici\u00f3n p\u00fablica, presentaci\u00f3n p\u00fablica, distribuci\u00f3n, difusi\u00f3n, comunicaci\u00f3n o importaci\u00f3n, y poner material a disposici\u00f3n del p\u00fablico, incluso de maneras en que los miembros del p\u00fablico puedan acceder al material desde un lugar y en un momento elegidos individualmente por ellos. l. Derechos Sui Generis de Bases de Datos significa derechos distintos de los derechos de autor resultantes de la Directiva 96/9/CE del Parlamento Europeo y del Consejo del 11 de marzo de 1996 sobre la protecci\u00f3n jur\u00eddica de las bases de datos, en su forma enmendada y/o sucedida, as\u00ed como otros derechos esencialmente equivalentes en cualquier parte del mundo. m. Usted significa la persona o entidad que ejerce los Derechos Licenciados bajo esta Licencia P\u00fablica. Su tiene un significado correspondiente.","title":"Secci\u00f3n 1 \u2013 Definiciones."},{"location":"LICENSE/#seccion-2-alcance","text":"a. Concesi\u00f3n de la licencia. Sujeto a los t\u00e9rminos y condiciones de esta Licencia P\u00fablica, el Licenciante le otorga por la presente una licencia mundial, libre de regal\u00edas, no sublicenciable, no exclusiva e irrevocable para ejercer los Derechos Licenciados en el Material Licenciado para: A. reproducir y Compartir el Material Licenciado, en su totalidad o en parte; y B. producir, reproducir y Compartir Material Adaptado. Excepciones y Limitaciones. Para evitar dudas, cuando las Excepciones y Limitaciones se aplican a Su uso, esta Licencia P\u00fablica no se aplica y Usted no necesita cumplir con sus t\u00e9rminos y condiciones. Plazo. El plazo de esta Licencia P\u00fablica se especifica en la Secci\u00f3n 6(a). Medios y formatos; modificaciones t\u00e9cnicas permitidas. El Licenciante lo autoriza a ejercer los Derechos Licenciados en todos los medios y formatos ya sean conocidos o creados en el futuro, y a realizar las modificaciones t\u00e9cnicas necesarias para ello. El Licenciante renuncia y/o acepta no hacer valer ning\u00fan derecho o autoridad para prohibirle realizar las modificaciones t\u00e9cnicas necesarias para ejercer los Derechos Licenciados, incluidas las modificaciones t\u00e9cnicas necesarias para eludir las Medidas Tecnol\u00f3gicas Efectivas. Para los fines de esta Licencia P\u00fablica, la simple realizaci\u00f3n de modificaciones autorizadas por esta Secci\u00f3n 2(a)(4) nunca produce Material Adaptado. Destinatarios posteriores. A. Oferta del Licenciante: Material Licenciado. Todo destinatario del Material Licenciado recibe autom\u00e1ticamente una oferta del Licenciante para ejercer los Derechos Licenciados seg\u00fan los t\u00e9rminos y condiciones de esta Licencia P\u00fablica. B. __Oferta adicional del Licenciante: Material Adaptado. Cada receptor de Material Adaptado de Usted recibe autom\u00e1ticamente una oferta del Licenciante para ejercer los Derechos Licenciados en el Material Adaptado bajo las condiciones de la Licencia del Adaptador que Usted aplique. C. Sin restricciones posteriores. Usted no puede ofrecer ni imponer t\u00e9rminos o condiciones adicionales o diferentes, ni aplicar Medidas Tecnol\u00f3gicas Efectivas al Material Licenciado si al hacerlo restringe el ejercicio de los Derechos Licenciados por cualquier receptor del Material Licenciado. Sin respaldo. Nada en esta Licencia P\u00fablica constituye ni puede interpretarse como un permiso para afirmar o implicar que Usted est\u00e1, o que Su uso del Material Licenciado est\u00e1, relacionado con, o patrocinado, respaldado o concedido estatus oficial por, el Licenciante u otros designados para recibir atribuci\u00f3n seg\u00fan lo dispuesto en la Secci\u00f3n 3(a)(1)(A)(i). b. Otros derechos. Los derechos morales, como el derecho a la integridad, no est\u00e1n licenciados bajo esta Licencia P\u00fablica, ni tampoco lo est\u00e1n los derechos de publicidad, privacidad y/u otros derechos de personalidad similares; Sin embargo, en la medida de lo posible, el Licenciante renuncia y/o acepta no hacer valer dichos derechos que posee en la medida limitada necesaria para permitirle ejercer los Derechos Licenciados, pero no de otra manera. Patente y cesi\u00f3n de derechos a cobrarle regal\u00edas por el ejercicio de los Derechos Licenciados, ya sea directamente o a trav\u00e9s de una sociedad de recaudaci\u00f3n en virtud de cualquier esquema de licencia obligatoria o estatutaria voluntaria o renunciable. En todos los dem\u00e1s casos, el Licenciante se reserva expresamente cualquier derecho a cobrar dichas regal\u00edas.","title":"Secci\u00f3n 2 \u2013 Alcance."},{"location":"LICENSE/#seccion-3-condiciones-de-la-licencia","text":"Su ejercicio de los Derechos Licenciados est\u00e1 expresamente sujeto a las siguientes condiciones. a. Atribuci\u00f3n. Si comparte el Material Licenciado (incluso en forma modificada), debe: A. conservar lo siguiente si el Licenciante lo proporciona con el Material Licenciado: i. identificaci\u00f3n del(los) creador(es) del Material Licenciado y cualquier otra persona designada para recibir atribuci\u00f3n, de cualquier manera razonable solicitada por el Licenciante (incluso mediante seud\u00f3nimo si se designa); ii. un aviso de derechos de autor; iii. un aviso que haga referencia a esta Licencia P\u00fablica; iv. un aviso que haga referencia a la exenci\u00f3n de garant\u00edas; v. un URI o hiperv\u00ednculo al Material Licenciado en la medida en que sea razonablemente posible; B. indicar si modific\u00f3 el Material Licenciado y conservar una indicaci\u00f3n de cualquier modificaci\u00f3n anterior; y C. indicar que el Material Licenciado est\u00e1 licenciado bajo esta Licencia P\u00fablica e incluir el texto de, o el URI o hiperv\u00ednculo a, esta Licencia P\u00fablica. Puede cumplir con las condiciones de la Secci\u00f3n 3(a)(1) de cualquier manera razonable seg\u00fan el medio, los medios y el contexto en los que comparta el Material Licenciado. Por ejemplo, puede ser razonable cumplir con las condiciones proporcionando un URI o hiperv\u00ednculo a un recurso que incluya la informaci\u00f3n requerida. Si el Licenciante lo solicita, debe eliminar cualquier informaci\u00f3n requerida por la Secci\u00f3n 3(a)(1)(A) en la medida en que sea razonablemente posible. b. ShareAlike. Adem\u00e1s de las condiciones de la Secci\u00f3n 3(a), si comparte material adaptado que produce, tambi\u00e9n se aplican las siguientes condiciones. La Licencia del Adaptador que usted aplica debe ser una licencia Creative Commons con los mismos Elementos de Licencia, esta versi\u00f3n o posterior, o una Licencia Compatible con BY-SA. Usted debe incluir el texto, el URI o el hiperv\u00ednculo a la Licencia del Adaptador que usted aplica. Usted puede satisfacer esta condici\u00f3n de cualquier manera razonable en funci\u00f3n del medio, los medios y el contexto en el que Usted Comparte el Material Adaptado. Usted no puede ofrecer ni imponer t\u00e9rminos o condiciones adicionales o diferentes, ni aplicar Medidas Tecnol\u00f3gicas Efectivas al Material Adaptado que restrinjan el ejercicio de los derechos otorgados bajo la Licencia del Adaptador que usted aplica.","title":"Secci\u00f3n 3 \u2013 Condiciones de la Licencia."},{"location":"LICENSE/#seccion-4-derechos-de-base-de-datos-sui-generis","text":"Cuando los Derechos Licenciados incluyen Derechos de Base de Datos Sui Generis que se aplican a Su uso del Material Licenciado: a. para evitar dudas, la Secci\u00f3n 2(a)(1) le otorga el derecho a extraer, reutilizar, reproducir y Compartir todo o una parte sustancial de los contenidos de la base de datos; b. Si incluye la totalidad o una parte sustancial del contenido de la base de datos en una base de datos en la que tiene derechos sui generis sobre la base de datos, entonces la base de datos en la que tiene derechos sui generis sobre la base de datos (pero no su contenido individual) es material adaptado, incluso a los efectos de la Secci\u00f3n 3(b); y c. Debe cumplir con las condiciones de la Secci\u00f3n 3(a) si comparte la totalidad o una parte sustancial del contenido de la base de datos. Para evitar dudas, esta Secci\u00f3n 4 complementa y no reemplaza sus obligaciones bajo esta Licencia P\u00fablica cuando los Derechos Licenciados incluyen otros Derechos de Autor y Derechos Similares.","title":"Secci\u00f3n 4 \u2013 Derechos de Base de Datos Sui Generis."},{"location":"LICENSE/#seccion-5-renuncia-de-garantias-y-limitacion-de-responsabilidad","text":"a. A menos que el Licenciante acuerde lo contrario por separado, en la medida de lo posible, el Licenciante ofrece el Material Licenciado tal como est\u00e1 y tal como est\u00e1 disponible, y no realiza declaraciones ni garant\u00edas de ning\u00fan tipo con respecto al Material Licenciado, ya sean expresas, impl\u00edcitas, legales u otras. Esto incluye, sin limitaci\u00f3n, garant\u00edas de t\u00edtulo, comerciabilidad, idoneidad para un fin determinado, no infracci\u00f3n, ausencia de defectos latentes o de otro tipo, precisi\u00f3n o presencia o ausencia de errores, sean o no conocidos o detectables. Cuando no se permitan descargos de responsabilidad de garant\u00edas en su totalidad o en parte, es posible que este descargo de responsabilidad no se aplique en su caso. b. En la medida de lo posible, en ning\u00fan caso el Licenciante ser\u00e1 responsable ante Usted en virtud de ninguna teor\u00eda legal (incluida, sin limitaci\u00f3n, la negligencia) o de otro modo por p\u00e9rdidas, costos, gastos o da\u00f1os directos, especiales, indirectos, incidentales, consecuentes, punitivos, ejemplares u otros que surjan de esta Licencia P\u00fablica o del uso del Material Licenciado, incluso si se le ha advertido al Licenciante de la posibilidad de dichas p\u00e9rdidas, costos, gastos o da\u00f1os. Cuando no se permita una limitaci\u00f3n de responsabilidad en su totalidad o en parte, es posible que esta limitaci\u00f3n no se aplique en su caso. c. La exenci\u00f3n de garant\u00edas y la limitaci\u00f3n de responsabilidad que se proporcionan anteriormente se interpretar\u00e1n de manera que, en la medida de lo posible, se respete la exenci\u00f3n de responsabilidad y la renuncia a toda responsabilidad.","title":"Secci\u00f3n 5 \u2013 Renuncia de garant\u00edas y limitaci\u00f3n de responsabilidad."},{"location":"LICENSE/#seccion-6-plazo-y-terminacion","text":"a. Esta Licencia P\u00fablica se aplica durante el plazo de los derechos de autor y derechos similares aqu\u00ed licenciados. Sin embargo, si no cumple con esta Licencia P\u00fablica, sus derechos bajo esta Licencia P\u00fablica terminar\u00e1n autom\u00e1ticamente. b. Cuando su derecho a usar el Material Licenciado haya terminado seg\u00fan la Secci\u00f3n 6(a), se restablecer\u00e1: autom\u00e1ticamente a partir de la fecha en que se corrija la infracci\u00f3n, siempre que se corrija dentro de los 30 d\u00edas posteriores a que usted descubra la infracci\u00f3n; o tras el restablecimiento expreso por parte del Licenciante. Para evitar dudas, esta Secci\u00f3n 6(b) no afecta ning\u00fan derecho que el Licenciante pueda tener para buscar remedios por sus infracciones de esta Licencia P\u00fablica. c. Para evitar dudas, el Licenciante tambi\u00e9n puede ofrecer el Material Licenciado bajo t\u00e9rminos o condiciones separados o dejar de distribuir el Material Licenciado en cualquier momento; sin embargo, hacerlo no terminar\u00e1 esta Licencia P\u00fablica. d. Las Secciones 1, 5, 6, 7 y 8 sobreviven a la terminaci\u00f3n de esta Licencia P\u00fablica.","title":"Secci\u00f3n 6: - Plazo y terminaci\u00f3n."},{"location":"LICENSE/#seccion-7-otros-terminos-y-condiciones","text":"a. El Licenciante no estar\u00e1 obligado por ning\u00fan t\u00e9rmino o condici\u00f3n adicional o diferente comunicado por Usted a menos que se acuerde expresamente. b. Todos los arreglos, entendimientos o acuerdos con respecto al Material Licenciado que no se indiquen en este documento son separados e independientes de los t\u00e9rminos y condiciones de esta Licencia P\u00fablica.","title":"Secci\u00f3n 7 \u2013 Otros T\u00e9rminos y Condiciones."},{"location":"LICENSE/#seccion-8-interpretacion","text":"a. Para evitar dudas, esta Licencia P\u00fablica no reduce, limita, restringe ni impone condiciones sobre ning\u00fan uso del Material Licenciado que pudiera realizarse legalmente sin permiso bajo esta Licencia P\u00fablica, y no se interpretar\u00e1 que lo hace. b. En la medida de lo posible, si alguna disposici\u00f3n de esta Licencia P\u00fablica se considera inaplicable, se reformar\u00e1 autom\u00e1ticamente en la medida m\u00ednima necesaria para que sea aplicable. Si la disposici\u00f3n no se puede reformar, se separar\u00e1 de esta Licencia P\u00fablica sin afectar la aplicabilidad de los t\u00e9rminos y condiciones restantes. c. No se eximir\u00e1 ning\u00fan t\u00e9rmino o condici\u00f3n de esta Licencia P\u00fablica ni se consentir\u00e1 ning\u00fan incumplimiento a menos que el Licenciante lo acepte expresamente. d. Nada de lo dispuesto en esta Licencia P\u00fablica constituye ni puede interpretarse como una limitaci\u00f3n o renuncia a los privilegios e inmunidades que se aplican al Licenciante o a Usted, incluidos los de los procesos legales de cualquier jurisdicci\u00f3n o autoridad. Creative Commons no es parte de sus licencias p\u00fablicas. No obstante, Creative Commons puede optar por aplicar una de sus licencias p\u00fablicas al material que publica y, en esos casos, se considerar\u00e1 el \"Licenciante\". Excepto con el prop\u00f3sito limitado de indicar que el material se comparte bajo una licencia p\u00fablica de Creative Commons o seg\u00fan lo permitan las pol\u00edticas de Creative Commons publicadas en [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons no autoriza el uso de la marca registrada \u201cCreative Commons\u201d ni de ninguna otra marca registrada o logotipo de Creative Commons sin su consentimiento previo por escrito, incluyendo, sin limitaci\u00f3n, en relaci\u00f3n con cualquier modificaci\u00f3n no autorizada de cualquiera de sus licencias p\u00fablicas o cualquier otro acuerdo, entendimiento o convenio relativo al uso de material con licencia. Para evitar dudas, este p\u00e1rrafo no forma parte de las licencias p\u00fablicas. Puede ponerse en contacto con Creative Commons en creativecommons.org","title":"Secci\u00f3n 8 \u2013 Interpretaci\u00f3n."},{"location":"about/","text":"Acerca de Esta es una versi\u00f3n en Espa\u00f1ol del curso Practical Python Programming Licencia Licencia de Uso","title":"About"},{"location":"about/#acerca-de","text":"Esta es una versi\u00f3n en Espa\u00f1ol del curso Practical Python Programming","title":"Acerca de"},{"location":"about/#licencia","text":"Licencia de Uso","title":"Licencia"},{"location":"01_Introduction/00_Overview/","text":"Contenido | Pr\u00f3ximo (2. Trabajar con datos) 1. Introducci\u00f3n a Python El objetivo de esta primera secci\u00f3n es presentar algunos conceptos b\u00e1sicos de Python desde cero. Comenzando desde cero, aprender\u00e1 a editar, ejecutar y depurar programas peque\u00f1os. Finalmente, escribir\u00e1 un script breve que lea un archivo de datos CSV y realice un c\u00e1lculo simple. 1.1 Introducci\u00f3n a Python 1.2 Un primer programa 1.3 N\u00fameros 1.4 Strings 1.5 Listas 1.6 Archivos 1.7 Funciones Contenido | Pr\u00f3ximo (2. Trabajar con datos)","title":"00 Overview"},{"location":"01_Introduction/00_Overview/#1-introduccion-a-python","text":"El objetivo de esta primera secci\u00f3n es presentar algunos conceptos b\u00e1sicos de Python desde cero. Comenzando desde cero, aprender\u00e1 a editar, ejecutar y depurar programas peque\u00f1os. Finalmente, escribir\u00e1 un script breve que lea un archivo de datos CSV y realice un c\u00e1lculo simple. 1.1 Introducci\u00f3n a Python 1.2 Un primer programa 1.3 N\u00fameros 1.4 Strings 1.5 Listas 1.6 Archivos 1.7 Funciones Contenido | Pr\u00f3ximo (2. Trabajar con datos)","title":"1. Introducci\u00f3n a Python"},{"location":"01_Introduction/01_Python/","text":"Contenido | Pr\u00f3ximo (1.2 Un primer programa) 1.1 Python Python es un lenguaje de programaci\u00f3n de alto nivel interpretado. A menudo se clasifica como un \"lenguaje de scripting\" y se considera similar a lenguajes como Perl, Tcl o Ruby. La sintaxis de Python est\u00e1 inspirada vagamente en elementos de la programaci\u00f3n en C. Python fue creado por Guido van Rossum alrededor de 1990, quien lo nombr\u00f3 en honor a Monty Python . \u00bfD\u00f3nde conseguir Python? Python.org es donde puedes obtener Python. Para los prop\u00f3sitos de este curso, usted s\u00f3lo necesita una instalaci\u00f3n b\u00e1sica. Recomiendo instalar Python 3.6 o m\u00e1s reciente. En las notas se utiliza Python 3.6 y soluciones. \u00bfPor qu\u00e9 se cre\u00f3 Python? En palabras del creador de Python: Mi motivaci\u00f3n original para crear Python fue la necesidad percibida de un lenguaje de nivel superior en el proyecto Amoeba [Sistemas Operativos]. Me di cuenta de que el desarrollo de utilidades de administraci\u00f3n de sistemas en C estaba tomando demasiado tiempo. Adem\u00e1s, hacer estas cosas en el shell no funcionar\u00eda por diversas razones. ... Entonces, hab\u00eda una necesidad de un lenguaje que pudiera cerrar la brecha entre C y el shell. Guido van Rossum \u00bfD\u00f3nde est\u00e1 Python en mi m\u00e1quina? Aunque existen muchos entornos en los que puedes ejecutar Python, Python normalmente se instala en su m\u00e1quina como un programa que se ejecuta desde el cmd, la terminal o shell de comandos. Desde la terminal, deber\u00edas ser capaz de escribir 'python' de esta manera: bash % python3 Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> >>> print(\"Hola Mundo\") Hola Mundo >>> En Windows bash % python3 deberia ser reemplazado por C:\\Users\\tu_nombre\\practical-python\\Work> python (sin el 3). Si no tienes experiencia en el uso del cmd, el shell o una terminal, probablemente deber\u00edas detenerte aqu\u00ed, examina un breve tutorial sobre CMD, shell o terminal y luego regresa. Aunque existen muchos entornos que no son de shell donde puedes codificar Python, ser\u00e1s un programador de Python m\u00e1s fuerte si eres capaz de ejecutar, depurar e interact\u00faar con Python en la terminal. Este es el entorno nativo de Python. Si puedes usar Python aqu\u00ed, podr\u00e1s usarlo en cualquier otro lugar. Ejercicios Ejercicio 1.1: Uso de Python como calculadora En su m\u00e1quina, inicie Python y \u00faselo como calculadora para resolver el problema. siguiente problema. Lucky Larry compr\u00f3 75 acciones de Google a un precio de 235,14 d\u00f3lares por acci\u00f3n. Hoy, las acciones de Google cotizan a 711,25 d\u00f3lares. Usando Python Modo interactivo como calculadora, averig\u00fce cu\u00e1nta ganancia obtendr\u00eda Larry. \u00bfQu\u00e9 har\u00eda si vendiera todas sus acciones? >>> (711,25 - 235,14) * 75 35708.25 >>> Consejo profesional: utilice la variable de gui\u00f3n bajo _ para utilizar el resultado del \u00faltimo c\u00e1lculo. Por ejemplo, >\u00bfcu\u00e1nto beneficio obtiene Larry despu\u00e9s que su malvado corredor se lleva \u00f9na comisi\u00f3n del 20%? >>> _ * 0,80 28566.600000000002 >>> Ejercicio 1.2: Obtener ayuda Utilice el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego usa help() para obtener ayuda sobre la funci\u00f3n round() . Escriba help() simplemente, sin ning\u00fan valor para ingresar al visor de ayuda interactivo. Una advertencia con help() : no funciona para Python b\u00e1sico. Declaraciones como for if , while , etc. (es decir, si escribe help(for) obtendr\u00e1 un error de sintaxis). Puedes intentar poner el tema del que requiere ayuda entre comillas como help('for') en su lugar. Si eso no funciona, tendr\u00e1s que recurrir a una b\u00fasqueda en Internet. Seguimiento: Vaya a ( http://docs.python.org ) y busque la documentaci\u00f3n para la funci\u00f3n abs() (pista: se encuentra en la referencia de la biblioteca relacionada con funciones integradas). Ejercicio 1.3: Cortar y pegar Este libro est\u00e1 estructurado como una serie de p\u00e1ginas donde se le recomienda probar ejemplos de c\u00f3digo Python interactiv: escribiendo . Si est\u00e1s aprendiendo Python por primera vez, se aconseja este \"enfoque lento\". Tendr\u00e1s una mejor idea del lenguaje disminuyendo la velocidad, escribiendo cosas y pensando \u00bfQu\u00e9 est\u00e1s haciendo? Si debe \"cortar y pegar\" ejemplos de c\u00f3digo, seleccione el c\u00f3digo comenzando despu\u00e9s del indicador >>> y llegando hasta, pero no m\u00e1s all\u00e1 que la primera l\u00ednea en blanco o el siguiente mensaje >>> (el que aparezca primero), seleccione copiar desde el navegador, vaya a la ventana de Python y seleccione pegar para copiarlo en el shell de Python. Para conseguir que el c\u00f3digo se ejecute, es posible que tengas que presionar \"Intro\" una vez que lo hayas pegado. Utilice cortar y pegar para ejecutar las declaraciones de Python en esta sesi\u00f3n: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia : nunca es posible pegar m\u00e1s de un comando de Python (declaraciones que aparecen despu\u00e9s de >>> ) al shell b\u00e1sico de Python . Tienes que pegar cada comando uno a la vez. Ahora que ya has hecho esto, recuerda que obtendr\u00e1s m\u00e1s provecho del libro escribiendo el c\u00f3digo lentamente y pensando en \u00e9l, no cortando y pegando. Contenido | Pr\u00f3ximo (1.2 Un primer programa)","title":"01_Python"},{"location":"01_Introduction/01_Python/#11-python","text":"Python es un lenguaje de programaci\u00f3n de alto nivel interpretado. A menudo se clasifica como un \"lenguaje de scripting\" y se considera similar a lenguajes como Perl, Tcl o Ruby. La sintaxis de Python est\u00e1 inspirada vagamente en elementos de la programaci\u00f3n en C. Python fue creado por Guido van Rossum alrededor de 1990, quien lo nombr\u00f3 en honor a Monty Python .","title":"1.1 Python"},{"location":"01_Introduction/01_Python/#donde-conseguir-python","text":"Python.org es donde puedes obtener Python. Para los prop\u00f3sitos de este curso, usted s\u00f3lo necesita una instalaci\u00f3n b\u00e1sica. Recomiendo instalar Python 3.6 o m\u00e1s reciente. En las notas se utiliza Python 3.6 y soluciones.","title":"\u00bfD\u00f3nde conseguir Python?"},{"location":"01_Introduction/01_Python/#por-que-se-creo-python","text":"En palabras del creador de Python: Mi motivaci\u00f3n original para crear Python fue la necesidad percibida de un lenguaje de nivel superior en el proyecto Amoeba [Sistemas Operativos]. Me di cuenta de que el desarrollo de utilidades de administraci\u00f3n de sistemas en C estaba tomando demasiado tiempo. Adem\u00e1s, hacer estas cosas en el shell no funcionar\u00eda por diversas razones. ... Entonces, hab\u00eda una necesidad de un lenguaje que pudiera cerrar la brecha entre C y el shell. Guido van Rossum","title":"\u00bfPor qu\u00e9 se cre\u00f3 Python?"},{"location":"01_Introduction/01_Python/#donde-esta-python-en-mi-maquina","text":"Aunque existen muchos entornos en los que puedes ejecutar Python, Python normalmente se instala en su m\u00e1quina como un programa que se ejecuta desde el cmd, la terminal o shell de comandos. Desde la terminal, deber\u00edas ser capaz de escribir 'python' de esta manera: bash % python3 Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> >>> print(\"Hola Mundo\") Hola Mundo >>> En Windows bash % python3 deberia ser reemplazado por C:\\Users\\tu_nombre\\practical-python\\Work> python (sin el 3). Si no tienes experiencia en el uso del cmd, el shell o una terminal, probablemente deber\u00edas detenerte aqu\u00ed, examina un breve tutorial sobre CMD, shell o terminal y luego regresa. Aunque existen muchos entornos que no son de shell donde puedes codificar Python, ser\u00e1s un programador de Python m\u00e1s fuerte si eres capaz de ejecutar, depurar e interact\u00faar con Python en la terminal. Este es el entorno nativo de Python. Si puedes usar Python aqu\u00ed, podr\u00e1s usarlo en cualquier otro lugar.","title":"\u00bfD\u00f3nde est\u00e1 Python en mi m\u00e1quina?"},{"location":"01_Introduction/01_Python/#ejercicios","text":"","title":"Ejercicios"},{"location":"01_Introduction/01_Python/#ejercicio-11-uso-de-python-como-calculadora","text":"En su m\u00e1quina, inicie Python y \u00faselo como calculadora para resolver el problema. siguiente problema. Lucky Larry compr\u00f3 75 acciones de Google a un precio de 235,14 d\u00f3lares por acci\u00f3n. Hoy, las acciones de Google cotizan a 711,25 d\u00f3lares. Usando Python Modo interactivo como calculadora, averig\u00fce cu\u00e1nta ganancia obtendr\u00eda Larry. \u00bfQu\u00e9 har\u00eda si vendiera todas sus acciones? >>> (711,25 - 235,14) * 75 35708.25 >>> Consejo profesional: utilice la variable de gui\u00f3n bajo _ para utilizar el resultado del \u00faltimo c\u00e1lculo. Por ejemplo, >\u00bfcu\u00e1nto beneficio obtiene Larry despu\u00e9s que su malvado corredor se lleva \u00f9na comisi\u00f3n del 20%? >>> _ * 0,80 28566.600000000002 >>>","title":"Ejercicio 1.1: Uso de Python como calculadora"},{"location":"01_Introduction/01_Python/#ejercicio-12-obtener-ayuda","text":"Utilice el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego usa help() para obtener ayuda sobre la funci\u00f3n round() . Escriba help() simplemente, sin ning\u00fan valor para ingresar al visor de ayuda interactivo. Una advertencia con help() : no funciona para Python b\u00e1sico. Declaraciones como for if , while , etc. (es decir, si escribe help(for) obtendr\u00e1 un error de sintaxis). Puedes intentar poner el tema del que requiere ayuda entre comillas como help('for') en su lugar. Si eso no funciona, tendr\u00e1s que recurrir a una b\u00fasqueda en Internet. Seguimiento: Vaya a ( http://docs.python.org ) y busque la documentaci\u00f3n para la funci\u00f3n abs() (pista: se encuentra en la referencia de la biblioteca relacionada con funciones integradas).","title":"Ejercicio 1.2: Obtener ayuda"},{"location":"01_Introduction/01_Python/#ejercicio-13-cortar-y-pegar","text":"Este libro est\u00e1 estructurado como una serie de p\u00e1ginas donde se le recomienda probar ejemplos de c\u00f3digo Python interactiv: escribiendo . Si est\u00e1s aprendiendo Python por primera vez, se aconseja este \"enfoque lento\". Tendr\u00e1s una mejor idea del lenguaje disminuyendo la velocidad, escribiendo cosas y pensando \u00bfQu\u00e9 est\u00e1s haciendo? Si debe \"cortar y pegar\" ejemplos de c\u00f3digo, seleccione el c\u00f3digo comenzando despu\u00e9s del indicador >>> y llegando hasta, pero no m\u00e1s all\u00e1 que la primera l\u00ednea en blanco o el siguiente mensaje >>> (el que aparezca primero), seleccione copiar desde el navegador, vaya a la ventana de Python y seleccione pegar para copiarlo en el shell de Python. Para conseguir que el c\u00f3digo se ejecute, es posible que tengas que presionar \"Intro\" una vez que lo hayas pegado. Utilice cortar y pegar para ejecutar las declaraciones de Python en esta sesi\u00f3n: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia : nunca es posible pegar m\u00e1s de un comando de Python (declaraciones que aparecen despu\u00e9s de >>> ) al shell b\u00e1sico de Python . Tienes que pegar cada comando uno a la vez. Ahora que ya has hecho esto, recuerda que obtendr\u00e1s m\u00e1s provecho del libro escribiendo el c\u00f3digo lentamente y pensando en \u00e9l, no cortando y pegando. Contenido | Pr\u00f3ximo (1.2 Un primer programa)","title":"Ejercicio 1.3: Cortar y pegar"},{"location":"01_Introduction/02_Hello_world/","text":"Contenido | Anterior (1.1 Introducci\u00f3n a Python) | Pr\u00f3ximo (1.3 N\u00fameros) 1.2 Un primer programa En esta secci\u00f3n se analiza la creaci\u00f3n de su primer programa y su ejecuci\u00f3n, int\u00e9rprete y algo de depuraci\u00f3n b\u00e1sica. Ejecuci\u00f3n de Python Los programas de Python siempre se ejecutan dentro de un int\u00e9rprete. El int\u00e9rprete es una aplicaci\u00f3n \"basada en consola\" que normalmente se ejecuta desde un shell de comandos. bash % python3 Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Los programadores expertos generalmente no tienen problemas para utilizar el int\u00e9rprete de esta manera, pero no es tan f\u00e1cil de usar para principiantes. Es posible que est\u00e9s usando un entorno que proporciona una interfaz diferente a Python. Est\u00e1 bien, pero aprender a ejecutar la terminal Python sigue siendo una habilidad \u00fatil. Modo interactivo Cuando inicias Python, obtienes un modo interactivo donde puedes experimentar. Si comienza a escribir declaraciones, se ejecutar\u00e1n inmediatamente. No hay ciclo de edici\u00f3n/compilaci\u00f3n/ejecuci\u00f3n/depuraci\u00f3n. >>> print('Hola Mundo') Hola Mundo >>> 37*42 1554 >>> for i in range(5): ...print(i) ... 0 1 2 3 4 >>> Este llamado bucle de lectura-evaluaci\u00f3n-impresi\u00f3n (o REPL) es muy \u00fatil para la depuraci\u00f3n y la exploraci\u00f3n. DETENTE : Si no puede entender c\u00f3mo interactuar con Python, detenga lo que est\u00e9 haciendo y descubra c\u00f3mo hacerlo. Si est\u00e1 utilizando un Entorno de Desarrollo Integrado (o IDE), es posible que est\u00e9 oculto detr\u00e1s de una Opci\u00f3n de men\u00fa u otra ventana. Muchas partes de este curso asumen que puedes Interactuar con el int\u00e9rprete. Echemos un vistazo m\u00e1s de cerca a los elementos del REPL: >>> es el indicador del int\u00e9rprete para iniciar una nueva declaraci\u00f3n. ... es el mensaje del int\u00e9rprete para continuar una declaraci\u00f3n. Ingrese una l\u00ednea en blanco para terminar de escribir y ejecutar lo que ha ingresado. El mensaje ... puede aparecer o no seg\u00fan su entorno. Para este curso, se muestra en blanco para facilitar cortar y pegar ejemplos de c\u00f3digo. El gui\u00f3n bajo _ contiene el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto s\u00f3lo es cierto en el modo interactivo. Nunca uses _ en un programa. Creando programas Los programas se colocan en archivos .py . # hola.py print('Hola Mundo') Puedes crear estos archivos con tu editor de texto favorito. Programas en ejecuci\u00f3n Para ejecutar un programa, ejec\u00fatelo en la terminal con el comando python . Por ejemplo, en la l\u00ednea de comandos de Unix: bash % python3 hola.py Hola Mundo bash % O desde el shell de Windows: C:\\Users\\tu_nombre\\practical-python\\Work> hola.py Hola Mundo C:\\Users\\tu_nombre\\practical-python\\Work> c:\\python313\\python hola.py Hola Mundo Nota: En Windows, es posible que deba especificar una ruta completa al int\u00e9rprete de Python, como c:\\python36\\python . Sin embargo, si Python est\u00e1 instalado de su forma habitual, es posible que puedas simplemente escribir el nombre del programa. como por ejemplo hola.py . Para conocer el directorio de instalaci\u00f3n de python, ejecute: C:\\Users\\tu_nombre\\practical-python\\Work> python >>> import sys >>> sys.executable 'C:\\\\Users\\\\Mario\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\python.exe' >>> Un programa de muestra Resolvamos el siguiente problema: Una ma\u00f1ana, sales y colocas un billete de un d\u00f3lar en la acera junto a la Torre Sears en Chicago. Cada d\u00eda siguiente, colocas el doble de billetes. \u00bfCu\u00e1nto tiempo tarda la pila de billetes en superar la altura de la torre? Aqu\u00ed hay una soluci\u00f3n: #sears.py espesor_de_billete = 0.11 * 0.001 # Metros (0,11 mm) altura_torre = 442 # Altura (metros) num_billetes = 1 dia= 1 while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de billetes', num_billetes) print('Altura final', num_billetes * espesor_de_billete) Cuando lo ejecutas, obtienes el siguiente resultado: bash % python3 sears.py 1 1 0,00011 2 2 0,00022 3 4 0,00044 4 8 0,00088 5 16 0,00176 6 32 0,00352 ... 21 1048576 115.34336 22 2097152 230.68672 N\u00famero de d\u00edas 23 N\u00famero de billetes 4194304 Altura final 461.37344 Usando este programa como gu\u00eda, podr\u00e1s aprender una serie de conceptos b\u00e1sicos importantes sobre Python. Declaraciones Un programa Python es una secuencia de declaraciones: a = 3 + 4 b = a * 2 print(b) Cada declaraci\u00f3n termina con una nueva l\u00ednea. Las declaraciones se ejecutan una tras otra hasta que el control llega al final del archivo. IMPORTANTE : A trav\u00e9s del curso los vocablos declaraci\u00f3n, sentencia e instrucci\u00f3n se utilizar\u00e1n con el mismo significado. Comentarios Los comentarios son texto que no se ejecutar\u00e1. a = 3 + 4 #Esto es un comentario b = a * 2 print(b) Los comentarios se indican con # y se extienden hasta el final de la l\u00ednea. Variables Una variable es un nombre para un valor. Puedes utilizar letras (min\u00fasculas y, min\u00fasculas y may\u00fasculas) de la a a la z. Adem\u00e1s del car\u00e1cter de subrayado _ , los n\u00fameros tambi\u00e9n pueden ser parte del nombre de una variable, excepto que se trate del primer caracter. altura = 442 # v\u00e1lido _altura = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2altura = 442 # no v\u00e1lido Tipos No es necesario declarar las variables con el tipo del valor. El tipo est\u00e1 asociado con el valor del lado derecho, no con el nombre de la variable. altura = 442 # Un entero `int` altura = 442.0 # Punto flotante `float` altura = 'Muy alto' # Una cadena o string `str` Python est\u00e1 tipado din\u00e1micamente. El \"tipo\" percibido de una variable podr\u00eda cambiar a medida que se ejecuta un programa dependiendo del valor actual asignado a ella. Sensibilidad a may\u00fasculas y min\u00fasculas Python distingue entre may\u00fasculas y min\u00fasculas. Las letras may\u00fasculas y min\u00fasculas se consideran letras diferentes. Todas estas son variables diferentes: nombre = 'Jake' Nombre = 'Elwood' NOMBRE = 'Guido' Las declaraciones del lenguaje siempre est\u00e1n en min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR Bucle La instrucci\u00f3n while ejecuta un bucle. while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de d\u00edas', d\u00eda) Las declaraciones sangradas debajo del while se ejecutar\u00e1n siempre que la expresi\u00f3n despu\u00e9s del while sea true . Sangr\u00eda La sangr\u00eda se utiliza para indicar grupos de declaraciones que van juntas. Consideremos el ejemplo anterior: while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de d\u00edas', d\u00eda) La sangr\u00eda agrupa las siguientes declaraciones como operaciones que se repiten: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 Debido a que la declaraci\u00f3n print() al final no est\u00e1 sangrada, no pertenece al bucle. La l\u00ednea vac\u00eda es solo para legibilidad. No afecta la ejecuci\u00f3n. Pr\u00e1cticas recomendadas de sangr\u00eda Utilice espacios en lugar de tabulaciones. Utilice 4 espacios por nivel. Utilice un editor compatible con Python. El \u00fanico requisito de Python es que la sangr\u00eda est\u00e9 dentro del mismo bloque. Se consistente. Por ejemplo, esto es un error: while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 # ERROR num_billetes = num_billetes * 2 Condicionales La declaraci\u00f3n if se utiliza para ejecutar una condici\u00f3n: if a > b: print('La computadora dice que no') else: print('La computadora dice que si') Puede comprobar m\u00faltiples condiciones agregando comprobaciones adicionales mediante elif . if a > b: print('La computadora dice que no') elif a == b: print('La computadora dice que s\u00ed') else: print('La computadora dice tal vez') Impresi\u00f3n La funci\u00f3n print produce una sola l\u00ednea de texto con los valores pasados. print('\u00a1Hola mundo!') # Imprime el texto \u00a1Hola mundo! Puedes utilizar variables. El texto impreso ser\u00e1 el valor de la variable, no el nombre. x = 100 print(x) # Imprime el texto 100 Si pasa m\u00e1s de un valor a print , los mismos se separan con espacios. nombre = 'Jake' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Jake' print() siempre pone una nueva l\u00ednea al final. print('Hola') print('Mi nombre es', 'Jake') Esto imprime: Hola Mi nombre es Jake El car\u00e1cter de nueva l\u00ednea adicional se puede suprimir: print('Hola', end=' ') print('mi nombre es', 'Jake') Este c\u00f3digo ahora imprimir\u00e1: Hola mi nombre es Jake Entrada del usuario Para leer una l\u00ednea de entrada escrita por el usuario, utilice la funci\u00f3n input() : nombre = input('Ingrese su nombre: ') print('Tu nombre es', nombre) input imprime un mensaje para el usuario y devuelve su respuesta. Esto es \u00fatil para programas peque\u00f1os, ejercicios de aprendizaje o depuraci\u00f3n simple. No se utiliza mucho para programas reales. Declaraci\u00f3n pass A veces es necesario especificar un bloque de c\u00f3digo vac\u00edo. Para ello se utiliza la palabra clave pass . if a > b: pass else: print('La computadora dice falso') Esto tambi\u00e9n se llama declaraci\u00f3n de \"no operaci\u00f3n\". No hace nada, sirve como marcador de posici\u00f3n para declaraciones que posiblemente se agregar\u00e1n m\u00e1s adelante. Ejercicios Este es el primer conjunto de ejercicios en los que debes crear archivos Python y ejecutarlos. A partir de este momento, se asume que usted est\u00e1n editando archivos en el directorio practical-python/Work/ . Para ayudar a ubicar el lugar adecuado, hay varios archivos de inicio vac\u00edos, que se han creado con los nombres de archivo apropiados. Busque el archivo Work/bounce.py que se utiliza en el primer ejercicio. Ejercicio 1.5: La pelota que rebota Se deja caer una pelota de goma desde una altura de 100 metros y cada vez que golpea el suelo, rebota hasta 3/5 de la altura desde la que cay\u00f3. Escribir un programa bounce.py que imprime una tabla que muestra la altura de la primeros 10 rebotes. Su programa deber\u00eda crear una tabla que se parezca a esto: 1 60,0 2 36,0 3 21.5999999999999998 4 12.9599999999999999 5 7.7759999999999999 6 4.66559999999999995 7 2.799359999999996 8 1.6796159999999998 9 1.0077695999999998 10 0,6046617599999998 Nota: Puedes limpiar un poco la salida si usas la funci\u00f3n round() . Intente usarlo para redondear la salida a 4 d\u00edgitos. 1 60.0 2 36.0 3 21.6 4 12.96 5 7.776 6 4.6656 7 2.7994 8 1.6796 9 1.0078 10 0.6047 Ejercicio 1.6: Depuraci\u00f3n El siguiente fragmento de c\u00f3digo contiene c\u00f3digo del problema de la Torre Sears. Tambi\u00e9n tiene un error. #sears.py espesor_de_billete = 0.11 * 0.001 # Metros (0,11 mm) altura_torre = 442 # Altura (metros) num_billetes = 1 dia= 1 while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dias + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de billetes', num_billetes) print('Altura final', num_billetes * espesor_de_billete) Copie y pegue el c\u00f3digo que aparece arriba en un nuevo programa llamado sears.py . Cuando ejecute el c\u00f3digo, recibir\u00e1 un mensaje de error que se provoca. El programa se bloquea as\u00ed: Traceback (most recent call last): File \"c:\\Users\\Mario\\practical-python\\Exercises\\Ex1_6.py\", line 11, in <module> d\u00eda = d\u00edas + 1 ^^^^ NameError: name 'd\u00edas' is not defined. Did you mean: 'd\u00eda'? La lectura de mensajes de error es una parte importante del c\u00f3digo Python. Si su programa se bloquea, la \u00faltima l\u00ednea del mensaje de seguimiento es la verdadera raz\u00f3n por la que el programa fall\u00f3. Encima de eso, deber\u00edas ver un fragmento del c\u00f3digo fuente y luego un nombre de archivo identificativo y un n\u00famero de l\u00ednea. \u00bfEn qu\u00e9 l\u00ednea est\u00e1 el error? \u00bfCu\u00e1l es el error? Arreglar el error Ejecutar el programa exitosamente Contenido | Anterior (1.1 Introducci\u00f3n a Python) | Pr\u00f3ximo (1.3 N\u00fameros)","title":"02_Hello_world"},{"location":"01_Introduction/02_Hello_world/#12-un-primer-programa","text":"En esta secci\u00f3n se analiza la creaci\u00f3n de su primer programa y su ejecuci\u00f3n, int\u00e9rprete y algo de depuraci\u00f3n b\u00e1sica.","title":"1.2 Un primer programa"},{"location":"01_Introduction/02_Hello_world/#ejecucion-de-python","text":"Los programas de Python siempre se ejecutan dentro de un int\u00e9rprete. El int\u00e9rprete es una aplicaci\u00f3n \"basada en consola\" que normalmente se ejecuta desde un shell de comandos. bash % python3 Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Los programadores expertos generalmente no tienen problemas para utilizar el int\u00e9rprete de esta manera, pero no es tan f\u00e1cil de usar para principiantes. Es posible que est\u00e9s usando un entorno que proporciona una interfaz diferente a Python. Est\u00e1 bien, pero aprender a ejecutar la terminal Python sigue siendo una habilidad \u00fatil.","title":"Ejecuci\u00f3n de Python"},{"location":"01_Introduction/02_Hello_world/#modo-interactivo","text":"Cuando inicias Python, obtienes un modo interactivo donde puedes experimentar. Si comienza a escribir declaraciones, se ejecutar\u00e1n inmediatamente. No hay ciclo de edici\u00f3n/compilaci\u00f3n/ejecuci\u00f3n/depuraci\u00f3n. >>> print('Hola Mundo') Hola Mundo >>> 37*42 1554 >>> for i in range(5): ...print(i) ... 0 1 2 3 4 >>> Este llamado bucle de lectura-evaluaci\u00f3n-impresi\u00f3n (o REPL) es muy \u00fatil para la depuraci\u00f3n y la exploraci\u00f3n. DETENTE : Si no puede entender c\u00f3mo interactuar con Python, detenga lo que est\u00e9 haciendo y descubra c\u00f3mo hacerlo. Si est\u00e1 utilizando un Entorno de Desarrollo Integrado (o IDE), es posible que est\u00e9 oculto detr\u00e1s de una Opci\u00f3n de men\u00fa u otra ventana. Muchas partes de este curso asumen que puedes Interactuar con el int\u00e9rprete. Echemos un vistazo m\u00e1s de cerca a los elementos del REPL: >>> es el indicador del int\u00e9rprete para iniciar una nueva declaraci\u00f3n. ... es el mensaje del int\u00e9rprete para continuar una declaraci\u00f3n. Ingrese una l\u00ednea en blanco para terminar de escribir y ejecutar lo que ha ingresado. El mensaje ... puede aparecer o no seg\u00fan su entorno. Para este curso, se muestra en blanco para facilitar cortar y pegar ejemplos de c\u00f3digo. El gui\u00f3n bajo _ contiene el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto s\u00f3lo es cierto en el modo interactivo. Nunca uses _ en un programa.","title":"Modo interactivo"},{"location":"01_Introduction/02_Hello_world/#creando-programas","text":"Los programas se colocan en archivos .py . # hola.py print('Hola Mundo') Puedes crear estos archivos con tu editor de texto favorito.","title":"Creando programas"},{"location":"01_Introduction/02_Hello_world/#programas-en-ejecucion","text":"Para ejecutar un programa, ejec\u00fatelo en la terminal con el comando python . Por ejemplo, en la l\u00ednea de comandos de Unix: bash % python3 hola.py Hola Mundo bash % O desde el shell de Windows: C:\\Users\\tu_nombre\\practical-python\\Work> hola.py Hola Mundo C:\\Users\\tu_nombre\\practical-python\\Work> c:\\python313\\python hola.py Hola Mundo Nota: En Windows, es posible que deba especificar una ruta completa al int\u00e9rprete de Python, como c:\\python36\\python . Sin embargo, si Python est\u00e1 instalado de su forma habitual, es posible que puedas simplemente escribir el nombre del programa. como por ejemplo hola.py . Para conocer el directorio de instalaci\u00f3n de python, ejecute: C:\\Users\\tu_nombre\\practical-python\\Work> python >>> import sys >>> sys.executable 'C:\\\\Users\\\\Mario\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python313\\\\python.exe' >>>","title":"Programas en ejecuci\u00f3n"},{"location":"01_Introduction/02_Hello_world/#un-programa-de-muestra","text":"Resolvamos el siguiente problema: Una ma\u00f1ana, sales y colocas un billete de un d\u00f3lar en la acera junto a la Torre Sears en Chicago. Cada d\u00eda siguiente, colocas el doble de billetes. \u00bfCu\u00e1nto tiempo tarda la pila de billetes en superar la altura de la torre? Aqu\u00ed hay una soluci\u00f3n: #sears.py espesor_de_billete = 0.11 * 0.001 # Metros (0,11 mm) altura_torre = 442 # Altura (metros) num_billetes = 1 dia= 1 while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de billetes', num_billetes) print('Altura final', num_billetes * espesor_de_billete) Cuando lo ejecutas, obtienes el siguiente resultado: bash % python3 sears.py 1 1 0,00011 2 2 0,00022 3 4 0,00044 4 8 0,00088 5 16 0,00176 6 32 0,00352 ... 21 1048576 115.34336 22 2097152 230.68672 N\u00famero de d\u00edas 23 N\u00famero de billetes 4194304 Altura final 461.37344 Usando este programa como gu\u00eda, podr\u00e1s aprender una serie de conceptos b\u00e1sicos importantes sobre Python.","title":"Un programa de muestra"},{"location":"01_Introduction/02_Hello_world/#declaraciones","text":"Un programa Python es una secuencia de declaraciones: a = 3 + 4 b = a * 2 print(b) Cada declaraci\u00f3n termina con una nueva l\u00ednea. Las declaraciones se ejecutan una tras otra hasta que el control llega al final del archivo. IMPORTANTE : A trav\u00e9s del curso los vocablos declaraci\u00f3n, sentencia e instrucci\u00f3n se utilizar\u00e1n con el mismo significado.","title":"Declaraciones"},{"location":"01_Introduction/02_Hello_world/#comentarios","text":"Los comentarios son texto que no se ejecutar\u00e1. a = 3 + 4 #Esto es un comentario b = a * 2 print(b) Los comentarios se indican con # y se extienden hasta el final de la l\u00ednea.","title":"Comentarios"},{"location":"01_Introduction/02_Hello_world/#variables","text":"Una variable es un nombre para un valor. Puedes utilizar letras (min\u00fasculas y, min\u00fasculas y may\u00fasculas) de la a a la z. Adem\u00e1s del car\u00e1cter de subrayado _ , los n\u00fameros tambi\u00e9n pueden ser parte del nombre de una variable, excepto que se trate del primer caracter. altura = 442 # v\u00e1lido _altura = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2altura = 442 # no v\u00e1lido","title":"Variables"},{"location":"01_Introduction/02_Hello_world/#tipos","text":"No es necesario declarar las variables con el tipo del valor. El tipo est\u00e1 asociado con el valor del lado derecho, no con el nombre de la variable. altura = 442 # Un entero `int` altura = 442.0 # Punto flotante `float` altura = 'Muy alto' # Una cadena o string `str` Python est\u00e1 tipado din\u00e1micamente. El \"tipo\" percibido de una variable podr\u00eda cambiar a medida que se ejecuta un programa dependiendo del valor actual asignado a ella.","title":"Tipos"},{"location":"01_Introduction/02_Hello_world/#sensibilidad-a-mayusculas-y-minusculas","text":"Python distingue entre may\u00fasculas y min\u00fasculas. Las letras may\u00fasculas y min\u00fasculas se consideran letras diferentes. Todas estas son variables diferentes: nombre = 'Jake' Nombre = 'Elwood' NOMBRE = 'Guido' Las declaraciones del lenguaje siempre est\u00e1n en min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR","title":"Sensibilidad a may\u00fasculas y min\u00fasculas"},{"location":"01_Introduction/02_Hello_world/#bucle","text":"La instrucci\u00f3n while ejecuta un bucle. while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de d\u00edas', d\u00eda) Las declaraciones sangradas debajo del while se ejecutar\u00e1n siempre que la expresi\u00f3n despu\u00e9s del while sea true .","title":"Bucle"},{"location":"01_Introduction/02_Hello_world/#sangria","text":"La sangr\u00eda se utiliza para indicar grupos de declaraciones que van juntas. Consideremos el ejemplo anterior: while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de d\u00edas', d\u00eda) La sangr\u00eda agrupa las siguientes declaraciones como operaciones que se repiten: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 num_billetes = num_billetes * 2 Debido a que la declaraci\u00f3n print() al final no est\u00e1 sangrada, no pertenece al bucle. La l\u00ednea vac\u00eda es solo para legibilidad. No afecta la ejecuci\u00f3n.","title":"Sangr\u00eda"},{"location":"01_Introduction/02_Hello_world/#practicas-recomendadas-de-sangria","text":"Utilice espacios en lugar de tabulaciones. Utilice 4 espacios por nivel. Utilice un editor compatible con Python. El \u00fanico requisito de Python es que la sangr\u00eda est\u00e9 dentro del mismo bloque. Se consistente. Por ejemplo, esto es un error: while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dia + 1 # ERROR num_billetes = num_billetes * 2","title":"Pr\u00e1cticas recomendadas de sangr\u00eda"},{"location":"01_Introduction/02_Hello_world/#condicionales","text":"La declaraci\u00f3n if se utiliza para ejecutar una condici\u00f3n: if a > b: print('La computadora dice que no') else: print('La computadora dice que si') Puede comprobar m\u00faltiples condiciones agregando comprobaciones adicionales mediante elif . if a > b: print('La computadora dice que no') elif a == b: print('La computadora dice que s\u00ed') else: print('La computadora dice tal vez')","title":"Condicionales"},{"location":"01_Introduction/02_Hello_world/#impresion","text":"La funci\u00f3n print produce una sola l\u00ednea de texto con los valores pasados. print('\u00a1Hola mundo!') # Imprime el texto \u00a1Hola mundo! Puedes utilizar variables. El texto impreso ser\u00e1 el valor de la variable, no el nombre. x = 100 print(x) # Imprime el texto 100 Si pasa m\u00e1s de un valor a print , los mismos se separan con espacios. nombre = 'Jake' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Jake' print() siempre pone una nueva l\u00ednea al final. print('Hola') print('Mi nombre es', 'Jake') Esto imprime: Hola Mi nombre es Jake El car\u00e1cter de nueva l\u00ednea adicional se puede suprimir: print('Hola', end=' ') print('mi nombre es', 'Jake') Este c\u00f3digo ahora imprimir\u00e1: Hola mi nombre es Jake","title":"Impresi\u00f3n"},{"location":"01_Introduction/02_Hello_world/#entrada-del-usuario","text":"Para leer una l\u00ednea de entrada escrita por el usuario, utilice la funci\u00f3n input() : nombre = input('Ingrese su nombre: ') print('Tu nombre es', nombre) input imprime un mensaje para el usuario y devuelve su respuesta. Esto es \u00fatil para programas peque\u00f1os, ejercicios de aprendizaje o depuraci\u00f3n simple. No se utiliza mucho para programas reales.","title":"Entrada del usuario"},{"location":"01_Introduction/02_Hello_world/#declaracion-pass","text":"A veces es necesario especificar un bloque de c\u00f3digo vac\u00edo. Para ello se utiliza la palabra clave pass . if a > b: pass else: print('La computadora dice falso') Esto tambi\u00e9n se llama declaraci\u00f3n de \"no operaci\u00f3n\". No hace nada, sirve como marcador de posici\u00f3n para declaraciones que posiblemente se agregar\u00e1n m\u00e1s adelante.","title":"Declaraci\u00f3n pass"},{"location":"01_Introduction/02_Hello_world/#ejercicios","text":"Este es el primer conjunto de ejercicios en los que debes crear archivos Python y ejecutarlos. A partir de este momento, se asume que usted est\u00e1n editando archivos en el directorio practical-python/Work/ . Para ayudar a ubicar el lugar adecuado, hay varios archivos de inicio vac\u00edos, que se han creado con los nombres de archivo apropiados. Busque el archivo Work/bounce.py que se utiliza en el primer ejercicio.","title":"Ejercicios"},{"location":"01_Introduction/02_Hello_world/#ejercicio-15-la-pelota-que-rebota","text":"Se deja caer una pelota de goma desde una altura de 100 metros y cada vez que golpea el suelo, rebota hasta 3/5 de la altura desde la que cay\u00f3. Escribir un programa bounce.py que imprime una tabla que muestra la altura de la primeros 10 rebotes. Su programa deber\u00eda crear una tabla que se parezca a esto: 1 60,0 2 36,0 3 21.5999999999999998 4 12.9599999999999999 5 7.7759999999999999 6 4.66559999999999995 7 2.799359999999996 8 1.6796159999999998 9 1.0077695999999998 10 0,6046617599999998 Nota: Puedes limpiar un poco la salida si usas la funci\u00f3n round() . Intente usarlo para redondear la salida a 4 d\u00edgitos. 1 60.0 2 36.0 3 21.6 4 12.96 5 7.776 6 4.6656 7 2.7994 8 1.6796 9 1.0078 10 0.6047","title":"Ejercicio 1.5: La pelota que rebota"},{"location":"01_Introduction/02_Hello_world/#ejercicio-16-depuracion","text":"El siguiente fragmento de c\u00f3digo contiene c\u00f3digo del problema de la Torre Sears. Tambi\u00e9n tiene un error. #sears.py espesor_de_billete = 0.11 * 0.001 # Metros (0,11 mm) altura_torre = 442 # Altura (metros) num_billetes = 1 dia= 1 while num_billetes * espesor_de_billete < altura_torre: print(dia, num_billetes, num_billetes * espesor_de_billete) dia = dias + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de billetes', num_billetes) print('Altura final', num_billetes * espesor_de_billete) Copie y pegue el c\u00f3digo que aparece arriba en un nuevo programa llamado sears.py . Cuando ejecute el c\u00f3digo, recibir\u00e1 un mensaje de error que se provoca. El programa se bloquea as\u00ed: Traceback (most recent call last): File \"c:\\Users\\Mario\\practical-python\\Exercises\\Ex1_6.py\", line 11, in <module> d\u00eda = d\u00edas + 1 ^^^^ NameError: name 'd\u00edas' is not defined. Did you mean: 'd\u00eda'? La lectura de mensajes de error es una parte importante del c\u00f3digo Python. Si su programa se bloquea, la \u00faltima l\u00ednea del mensaje de seguimiento es la verdadera raz\u00f3n por la que el programa fall\u00f3. Encima de eso, deber\u00edas ver un fragmento del c\u00f3digo fuente y luego un nombre de archivo identificativo y un n\u00famero de l\u00ednea. \u00bfEn qu\u00e9 l\u00ednea est\u00e1 el error? \u00bfCu\u00e1l es el error? Arreglar el error Ejecutar el programa exitosamente Contenido | Anterior (1.1 Introducci\u00f3n a Python) | Pr\u00f3ximo (1.3 N\u00fameros)","title":"Ejercicio 1.6: Depuraci\u00f3n"},{"location":"01_Introduction/03_Numbers/","text":"Contenido | Anterior (1.2 Un primer programa) | Pr\u00f3ximo (1.4 Strings) 1.3 N\u00fameros En esta secci\u00f3n es acerca de c\u00e1lculos matem\u00e1ticos. Tipos de n\u00fameros Python tiene 4 tipos de n\u00fameros: Booleanos bool N\u00fameros enteros int Punto flotante float Complejos (n\u00fameros imaginarios) complex Booleanos bool Los valores booleanos tienen dos valores: \"Verdadero\" True y \"Falso\" False . a = True b = False Num\u00e9ricamente, se eval\u00faan como n\u00fameros enteros con valor \u00ab1\u00bb, \u00ab0\u00bb. c = 4 + True # 5 d = False if d == 0: print('d es falso') Pero no escribas c\u00f3digo as\u00ed. Ser\u00eda extra\u00f1o. N\u00fameros enteros int Valores con signo, de tama\u00f1o y base arbitrarios: a = 37 b = -299392993727716627377128481812241231 c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones comunes: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divici\u00f3n (produce un `float`) x // y Divisi\u00f3n de piso (produce un `int`) x % y M\u00f3dulo (resto) x ** y Potencia x << n Desplazamiento de bit a la izquierda x >> n Desplazamiento de bit a la derecha x & y AND bit a bit y | y OR bit a bit x ^ y XOR bit a bit ~x Bit a bit NO abs(x) Valor absoluto Punto flotante float Utilice una notaci\u00f3n decimal o exponencial para especificar un valor de punto flotante: a = 37.45 b = 4e5 # 4 x 10**5 o 400.000 c = -1.345e-10 Los flotantes se representan como doble precisi\u00f3n utilizando la representaci\u00f3n nativa del CPU IEEE 754 . Esto es lo mismo que el tipo double en el lenguaje de programaci\u00f3n C. 17 d\u00edgitos de precisi\u00f3n Exponente de -308 a 308 Tenga en cuenta que los n\u00fameros de punto flotante son inexactos cuando se representan decimales. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.3000000000000001 >>> Este no es un problema de Python , sino del hardware de punto flotante subyacente en la CPU. Operaciones comunes: x + y Suma x - y Resta x * y Multiplica x/y Divisi\u00f3n x // y Divisi\u00f3n de piso x % y M\u00f3dulo x ** y Potencia abs(x) Valor absoluto Estos son los mismos operadores que los n\u00fameros enteros, excepto los operadores bit a bit. Funciones matem\u00e1ticas adicionales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x) Comparaciones Los siguientes operadores de comparaci\u00f3n o relacionales funcionan con n\u00fameros: x < y Menor que x <= y Menor o igual que x > y Mayor que x >= y Mayor o igual que x == y Igual a x != y No es igual a Puedes formar expresiones booleanas m\u00e1s complejas usando and , or , not A continuaci\u00f3n se muestran algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b todav\u00eda est\u00e1 entre a y c') Conversi\u00f3n de n\u00fameros El nombre del tipo se puede utilizar para convertir valores: a = int(x) # Convertir x a entero b = float(x) # Convertir x a float Pru\u00e9balo. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con strings que contienen n\u00fameros >>> float(b) 3.14159 >>> Ejercicios Recordatorio: Estos ejercicios suponen que est\u00e1s trabajando en el directorio practical-python/Work . Mira el archivo mortgage.py . Ejercicio 1.7: La hipoteca de Dave Dave ha decidido contratar una hipoteca a tasa de interes fija a 30 a\u00f1os por 500.000 d\u00f3lares. con Guido\u2019s Mortgage Stock Investment and Bitcoin trading corporation. La tasa de inter\u00e9s es del 5% anual y el pago mensual es $2684.11. Aqu\u00ed hay un programa que calcula la cantidad total que tendr\u00e1 Dave a pagar durante la vida de la hipoteca: # mortgage.py principal = 500000.0 rate = 0.05 payment = 2684.11 total_paid = 0.0 while principal > 0: principal = principal * (1+rate/12) - payment total_paid = total_paid + payment print('Total paid', total_paid) Ingrese a este programa y ejec\u00fatelo. Deber\u00eda obtener una respuesta de Total paid 966279.6 . Ejercicio 1.8: Pagos extra Supongamos que Dave paga $1000 extra al mes durante los primeros 12 meses de la hipoteca. Modifique el programa para incorporar este pago adicional y haga que imprima el monto total pagado junto con el n\u00famero de meses requeridos. Al ejecutar el nuevo programa, deber\u00eda informar pago total de 929965.62 en 342 cuotas Ejercicio 1.9: Calculadora para realizar un pago adicional Modificar el programa para que la informaci\u00f3n de pago adicional pueda manejarse de forma m\u00e1s general. Haga que el usuario pueda configurar estas variables: extra_payment_start_month = 61 extra_payment_end_month = 108 extra_payment = 1000 Haga que el programa tome estas variables y calcule el total a pagar. \u00bfCu\u00e1nto pagar\u00e1 Dave si paga $1000 adicionales al mes durante 4 a\u00f1os a partir de que ya se hayan pagado los primeros cinco a\u00f1os? Ejercicio 1.10: Hacer una tabla Modifique el programa para imprimir una tabla que muestre el mes, el total pagado hasta el momento y el capital restante. El resultado deber\u00eda verse as\u00ed: 1 2684.11 499399.22 2 5368,22 498795,94 3 8052.33 498190 4 10736,44 497581,83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389.99 809.21 310 880074.1 -1871.53 Total paid 880074.1 Months 310 Ejercicio 1.11: Bonificaci\u00f3n Mientras est\u00e9 en ello, arregle el programa para corregir el pago en exceso que ocurri\u00f3 en el \u00faltimo mes. Ejercicio 1.12: Un misterio int() y float() se pueden usar para convertir n\u00fameros. Por ejemplo, >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con esto en mente, \u00bfpuedes explicar este comportamiento? >>> bool(\"False\") True >>> Contenido | Anterior (1.2 Un primer programa) | Pr\u00f3ximo (1.4 Strings)","title":"03_Numbers"},{"location":"01_Introduction/03_Numbers/#13-numeros","text":"En esta secci\u00f3n es acerca de c\u00e1lculos matem\u00e1ticos.","title":"1.3 N\u00fameros"},{"location":"01_Introduction/03_Numbers/#tipos-de-numeros","text":"Python tiene 4 tipos de n\u00fameros: Booleanos bool N\u00fameros enteros int Punto flotante float Complejos (n\u00fameros imaginarios) complex","title":"Tipos de n\u00fameros"},{"location":"01_Introduction/03_Numbers/#booleanos-bool","text":"Los valores booleanos tienen dos valores: \"Verdadero\" True y \"Falso\" False . a = True b = False Num\u00e9ricamente, se eval\u00faan como n\u00fameros enteros con valor \u00ab1\u00bb, \u00ab0\u00bb. c = 4 + True # 5 d = False if d == 0: print('d es falso') Pero no escribas c\u00f3digo as\u00ed. Ser\u00eda extra\u00f1o.","title":"Booleanos bool"},{"location":"01_Introduction/03_Numbers/#numeros-enteros-int","text":"Valores con signo, de tama\u00f1o y base arbitrarios: a = 37 b = -299392993727716627377128481812241231 c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones comunes: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divici\u00f3n (produce un `float`) x // y Divisi\u00f3n de piso (produce un `int`) x % y M\u00f3dulo (resto) x ** y Potencia x << n Desplazamiento de bit a la izquierda x >> n Desplazamiento de bit a la derecha x & y AND bit a bit y | y OR bit a bit x ^ y XOR bit a bit ~x Bit a bit NO abs(x) Valor absoluto","title":"N\u00fameros enteros int"},{"location":"01_Introduction/03_Numbers/#punto-flotante-float","text":"Utilice una notaci\u00f3n decimal o exponencial para especificar un valor de punto flotante: a = 37.45 b = 4e5 # 4 x 10**5 o 400.000 c = -1.345e-10 Los flotantes se representan como doble precisi\u00f3n utilizando la representaci\u00f3n nativa del CPU IEEE 754 . Esto es lo mismo que el tipo double en el lenguaje de programaci\u00f3n C. 17 d\u00edgitos de precisi\u00f3n Exponente de -308 a 308 Tenga en cuenta que los n\u00fameros de punto flotante son inexactos cuando se representan decimales. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.3000000000000001 >>> Este no es un problema de Python , sino del hardware de punto flotante subyacente en la CPU. Operaciones comunes: x + y Suma x - y Resta x * y Multiplica x/y Divisi\u00f3n x // y Divisi\u00f3n de piso x % y M\u00f3dulo x ** y Potencia abs(x) Valor absoluto Estos son los mismos operadores que los n\u00fameros enteros, excepto los operadores bit a bit. Funciones matem\u00e1ticas adicionales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x)","title":"Punto flotante float"},{"location":"01_Introduction/03_Numbers/#comparaciones","text":"Los siguientes operadores de comparaci\u00f3n o relacionales funcionan con n\u00fameros: x < y Menor que x <= y Menor o igual que x > y Mayor que x >= y Mayor o igual que x == y Igual a x != y No es igual a Puedes formar expresiones booleanas m\u00e1s complejas usando and , or , not A continuaci\u00f3n se muestran algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b todav\u00eda est\u00e1 entre a y c')","title":"Comparaciones"},{"location":"01_Introduction/03_Numbers/#conversion-de-numeros","text":"El nombre del tipo se puede utilizar para convertir valores: a = int(x) # Convertir x a entero b = float(x) # Convertir x a float Pru\u00e9balo. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con strings que contienen n\u00fameros >>> float(b) 3.14159 >>>","title":"Conversi\u00f3n de n\u00fameros"},{"location":"01_Introduction/03_Numbers/#ejercicios","text":"Recordatorio: Estos ejercicios suponen que est\u00e1s trabajando en el directorio practical-python/Work . Mira el archivo mortgage.py .","title":"Ejercicios"},{"location":"01_Introduction/03_Numbers/#ejercicio-17-la-hipoteca-de-dave","text":"Dave ha decidido contratar una hipoteca a tasa de interes fija a 30 a\u00f1os por 500.000 d\u00f3lares. con Guido\u2019s Mortgage Stock Investment and Bitcoin trading corporation. La tasa de inter\u00e9s es del 5% anual y el pago mensual es $2684.11. Aqu\u00ed hay un programa que calcula la cantidad total que tendr\u00e1 Dave a pagar durante la vida de la hipoteca: # mortgage.py principal = 500000.0 rate = 0.05 payment = 2684.11 total_paid = 0.0 while principal > 0: principal = principal * (1+rate/12) - payment total_paid = total_paid + payment print('Total paid', total_paid) Ingrese a este programa y ejec\u00fatelo. Deber\u00eda obtener una respuesta de Total paid 966279.6 .","title":"Ejercicio 1.7: La hipoteca de Dave"},{"location":"01_Introduction/03_Numbers/#ejercicio-18-pagos-extra","text":"Supongamos que Dave paga $1000 extra al mes durante los primeros 12 meses de la hipoteca. Modifique el programa para incorporar este pago adicional y haga que imprima el monto total pagado junto con el n\u00famero de meses requeridos. Al ejecutar el nuevo programa, deber\u00eda informar pago total de 929965.62 en 342 cuotas","title":"Ejercicio 1.8: Pagos extra"},{"location":"01_Introduction/03_Numbers/#ejercicio-19-calculadora-para-realizar-un-pago-adicional","text":"Modificar el programa para que la informaci\u00f3n de pago adicional pueda manejarse de forma m\u00e1s general. Haga que el usuario pueda configurar estas variables: extra_payment_start_month = 61 extra_payment_end_month = 108 extra_payment = 1000 Haga que el programa tome estas variables y calcule el total a pagar. \u00bfCu\u00e1nto pagar\u00e1 Dave si paga $1000 adicionales al mes durante 4 a\u00f1os a partir de que ya se hayan pagado los primeros cinco a\u00f1os?","title":"Ejercicio 1.9: Calculadora para realizar un pago adicional"},{"location":"01_Introduction/03_Numbers/#ejercicio-110-hacer-una-tabla","text":"Modifique el programa para imprimir una tabla que muestre el mes, el total pagado hasta el momento y el capital restante. El resultado deber\u00eda verse as\u00ed: 1 2684.11 499399.22 2 5368,22 498795,94 3 8052.33 498190 4 10736,44 497581,83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389.99 809.21 310 880074.1 -1871.53 Total paid 880074.1 Months 310","title":"Ejercicio 1.10: Hacer una tabla"},{"location":"01_Introduction/03_Numbers/#ejercicio-111-bonificacion","text":"Mientras est\u00e9 en ello, arregle el programa para corregir el pago en exceso que ocurri\u00f3 en el \u00faltimo mes.","title":"Ejercicio 1.11: Bonificaci\u00f3n"},{"location":"01_Introduction/03_Numbers/#ejercicio-112-un-misterio","text":"int() y float() se pueden usar para convertir n\u00fameros. Por ejemplo, >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con esto en mente, \u00bfpuedes explicar este comportamiento? >>> bool(\"False\") True >>> Contenido | Anterior (1.2 Un primer programa) | Pr\u00f3ximo (1.4 Strings)","title":"Ejercicio 1.12: Un misterio"},{"location":"01_Introduction/04_Strings/","text":"Contenido | Anterior (1.3 N\u00fameros) | Pr\u00f3ximo (1.5 Listas) 1.4 Strings Esta secci\u00f3n presenta formas de trabajar con texto. IMPORTANTE: Las palabras string y cadena son utilizadas con el mismo significado Representaci\u00f3n de texto literal Los literales de cadena se escriben en programas con comillas. # Comillas simples a = 'S\u00ed, pero no, pero s\u00ed, pero...' # Comillas dobles b = \"la computadora dice que no\" # Comillas triples c = ''' M\u00edrame a los ojos, m\u00edrame a los ojos, a los ojos, a los ojos, a los ojos, No alrededor de los ojos, no mires alrededor de los ojos, m\u00edrame a los ojos, est\u00e1s debajo. ''' Normalmente, los strings solo pueden abarcar una \u00fanica l\u00ednea. Las comillas triples capturan todo el texto encerrado en varias l\u00edneas, incluido todo el formato. No hay diferencia entre usar comillas simples ' o dobles \" . Sin embargo, se debe usar el mismo tipo de comillas utilizadas para iniciar una cadena para terminarla . C\u00f3digos de escape de cadenas Los c\u00f3digos de escape se utilizan para representar caracteres de control y caracteres que no se pueden escribir f\u00e1cilmente directamente en el teclado. A continuaci\u00f3n se muestran algunos c\u00f3digos de escape comunes: '\\n' Salto de l\u00ednea '\\r' Retorno de carro '\\t' Tabulador '\\'' Comilla simple literal '\\\"' Comillas dobles literal '\\\\' Barra invertida literal Representaci\u00f3n de cadena Cada car\u00e1cter de una cadena se almacena internamente como un denominado punto de c\u00f3digo Unicode, que es un n\u00famero entero. Puede especificar un valor de punto de c\u00f3digo exacto utilizando las siguientes secuencias de escape: a = '\\xf1' # a = '\u00f1' b = '\\u2200' # b = '\u2200' c = '\\U0001D122' # c = '\ud834\udd22' d = '\\N{FOR ALL}' # d = '\u2200' La base de datos de caracteres Unicode es una referencia para todos los c\u00f3digos de caracteres disponibles. Indexaci\u00f3n de strings Los strings funcionan como una matriz para acceder a caracteres individuales. Se utiliza un \u00edndice entero, que comienza en 0. Los \u00edndices negativos especifican una posici\u00f3n relativa al final del string. a = 'Hola mundo' b = a[0] # 'H' c = a[4] # '' d = a[-1] # 'o' (fin de la cadena) Tambi\u00e9n puedes cortar o seleccionar substrings especificando un rango de \u00edndices con : . d = a[:5] # 'Hola' e = a[6:] # 'undo' f = a[3:8] # 'a mun' g = a[-5:] # 'mundo' El car\u00e1cter del \u00edndice final no est\u00e1 incluido. Los \u00edndices faltantes suponen el principio o el final de la cadena. Operaciones con cadenas Concatenaci\u00f3n, longitud, membres\u00eda y replicaci\u00f3n. # Concatenaci\u00f3n (+) a = 'Hola' + 'Mundo' # 'HolaMundo' b = 'Decir ' + a # 'Decir HolaMundo' # Longitud (len) s = 'Hola' len(s) # 4 # Prueba de membres\u00eda (`in`, `not in`) t = 'o' in s # True f = 'x' in s # False g = 'hola' not in s # True # Replicaci\u00f3n (s * n) rep = s * 5 # 'HolaHolaHolaHolaHola' M\u00e9todos de cadena Los strings tienen m\u00e9todos que realizan varias operaciones con los datos de los mismos. Ejemplo: eliminar cualquier espacio en blanco inicial o final. s = ' Hola ' t = s.strip() # 'Hola' Ejemplo: Conversi\u00f3n de may\u00fasculas y min\u00fasculas. s = 'Hola' l = s.lower() # 'hola' u = s.upper() # 'HOLA' Ejemplo: Reemplazar texto. s = 'Hola mundo' t = s.replace('Hola' , 'Hello') # 'Hello mundo' M\u00e1s m\u00e9todos de String: Las cadenas tienen una amplia variedad de otros m\u00e9todos para probar y manipular los datos de texto. Esta es una peque\u00f1a muestra de m\u00e9todos: s.endswith(suffix) # Verifica si la cadena termina con suffix s.find(t) # Primera aparici\u00f3n de t en s s.index(t) # Primera aparici\u00f3n de t en s s.isalpha() # Comprueba si los caracteres son alfab\u00e9ticos s.isdigit() # Comprueba si los caracteres son num\u00e9ricos s.islower() # Verifica si los caracteres est\u00e1n en min\u00fasculas s.isupper() # Verifica si los caracteres est\u00e1n en may\u00fasculas s.join(slist) # Une una lista de cadenas usando s como delimitador s.lower() # Convierte a min\u00fasculas s.replace(old,new) # Reemplaza texto s.rfind(t) # Busca t desde el final de la cadena s.rindex(t) # Busca t desde el final de la cadena s.split([delim]) # Divide la cadena en una lista de subcadenas s.startswith(prefix) # Verifica si la cadena comienza con prefijo s.strip() # Elimina los espacios iniciales y finales s.upper() # Convierte a may\u00fasculas Mutabilidad de los strings Los strings son \"inmutables\" o de s\u00f3lo lectura. Una vez creado, el valor no se puede cambiar. >>> s = 'Hola mundo' >>> s[1] = 'a' Traceback (most recent call last): File \"<python-input-5>\", line 1, in <module> s[1] = 'a' ~^^^ TypeError: 'str' object does not support item assignment >>> Todas las operaciones y m\u00e9todos que manipulan datos de strings, siempre crean nuevos strings. Conversiones de strings Utilice str() para convertir cualquier valor en un string. El resultado es un string que contiene el mismo texto que habr\u00eda sido producido por la declaraci\u00f3n print() . >>> x = 42 >>> str(x) '42' >>> Cadenas de bytes Una cadena de bytes de 8 bits, que se encuentra com\u00fanmente en E/S de bajo nivel, se escribe de la siguiente manera: datos = b'Hola mundo\\r\\n' Al colocar una b min\u00fascula antes de la primera comilla, especifica que se trata de una cadena de bytes y no de una cadena de texto. La mayor\u00eda de las operaciones de cadena habituales funcionan. len(datos) # 12 datos[0:4] # b'Hola' datos.replace(b'Hola', b'Cruel') # b'Cruel mundo\\r\\n' La indexaci\u00f3n es un poco diferente porque devuelve valores de bytes como n\u00fameros enteros. datos[0] # 72 (c\u00f3digo ASCII para 'H') Conversi\u00f3n a/desde cadenas de texto. texto = datos.decode('utf-8') # bytes -> texto datos = texto.encode('utf-8') # texto -> bytes El argumento \"utf-8\" especifica una codificaci\u00f3n de caracteres. Otros valores comunes incluyen \"ascii\" y \"latin1\". Stings sin procesar Los strings sin formato son literales de strings con una barra invertida no interpretada. Ellos se especifican anteponiendo la comilla inicial con una \"r\" min\u00fascula. >>> rs = r'c:\\newdata\\test' # Sin formato (barra invertida no interpretada) >>> rs 'c:\\\\newdata\\\\prueba' Los strings son el texto literal incluido en el interior, exactamente como se escribe. Esto es \u00fatil en situaciones donde la barra invertida tiene un significado especial. Ejemplo: nombre de archivo, expresiones regulares, etc. f-strings Una cadena con sustituci\u00f3n de expresi\u00f3n formateada. >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {acciones:10d} {precio:10.2f}' >>> a 'IBM 100 91.10' >>> b = f'Costo = ${acciones*precio:0.2f}' >>>b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o m\u00e1s reciente. El significado de los c\u00f3digos de formato se trata m\u00e1s adelante. Ejercicios En estos ejercicios, experimentar\u00e1 con operaciones usando el tipo de cadena de Python. Debes hacer esto en el modo interactivo de Python, donde podr\u00e1s ver f\u00e1cilmente los resultados. Nota importante: En ejercicios en los que se supone que debes interactuar con el int\u00e9rprete, >>> es el mensaje de solicitud del int\u00e9rprete que aparece cuando Python desea que escribas una nueva declaraci\u00f3n. Algunas afirmaciones en el ejercicio abarcan varias l\u00edneas: para que se ejecuten estas instrucciones, es posible que tenga que presionar 'Enter' unas cuantas veces. Solo un recordatorio de que NO debes escribir el >>> al trabajar estos ejemplos. Comience por definir una cadena que contenga una serie de s\u00edmbolos burs\u00e1tiles como este: >>> >>> symbols = 'AAPL,IBM,MSFT,YHOO,SCO' >>> Ejercicio 1.13: Extracci\u00f3n de caracteres individuales y subcadenas Las cadenas son matrices de caracteres. Intente extraer algunos caracteres: >>> symbols[0] ? >>> symbols[1] ? >>> symbols[2] ? >>> symbols[-1] # \u00daltimo car\u00e1cter ? >>> symbols[-2] # Los \u00edndices negativos son desde el final de la cadena ? >>> En Python, las cadenas son de solo lectura. Verifique esto intentando cambiar el primer car\u00e1cter de 'symbols' a una 'a' min\u00fascula. >>> symbols[0] = 'a' Traceback (most recent call last): File \"<python-input-3>\", line 1, in <module> symbols[0] = 'a' ~~~~~~~^^^ TypeError: 'str' object does not support item assignment >>> Ejercicio 1.14: Concatenaci\u00f3n de cadenas Aunque los datos de cadena son de solo lectura, siempre puedes reasignar una variable a una cadena reci\u00e9n creada. Pruebe la siguiente declaraci\u00f3n que concatena un nuevo s\u00edmbolo \"GOOG\" a El final de los `symbols': >>> symbols = symbols + 'GOOG' >>> symbols 'AAPL,IBM,MSFT,YHOO,SCOGOOG' >>> \u00a1Ups! Eso no es lo que quer\u00edas. Arr\u00e9glelo para que la variable symbols contenga el valor 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' . >>> symbols = ? >>> symbols 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> A\u00f1ade 'HPQ' al principio de la cadena: >>> symbols = ? >>> symbols 'HPQ,AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> En estos ejemplos, podr\u00eda parecer que se est\u00e1 modificando la cadena original, en una aparente violaci\u00f3n del principio de que las cadenas son de solo lectura. No es as\u00ed. Las operaciones sobre cadenas crean una cadena completamente nueva cada vez. Cuando se reasigna el nombre de la variable symbols , apunta a la cadena reci\u00e9n creada. Posteriormente la cadena vieja se destruye porque ya no se utiliza. Ejercicio 1.15: Prueba de pertenencia (prueba de subcadenas) Experimente con el operador in para comprobar si hay subcadenas. En modo interactivo: pruebe estas operaciones: >>> 'IBM' in symbols ? >>> 'AA' in symbols True >>> 'CAT' in symbols ? >>> \u00bfPor qu\u00e9 la verificaci\u00f3n de 'AA' devolvi\u00f3 True ? Ejercicio 1.16: M\u00e9todos de cadena En el modo interactivo de Python, intente experimentar con algunos de los m\u00e9todos de cadena. >>> symbols.lower() ? >>> symbols ? >>> Recuerde, las cadenas siempre son de solo lectura. Si desea guardar el resultado de una operaci\u00f3n, debe colocarlo en una variable: >>> lowersyms = symbols.lower() >>> Pruebe algunas operaciones m\u00e1s: >>> symbols.find('MSFT') ? >>> symbols[13:17] ? >>> symbols = symbols.replace('SCO','DOA') >>> symbols ? >>> name = ' IBM \\n' >>> name = name.strip() # Elimina los espacios en blanco circundantes >>> name ? >>> Ejercicio 1.17: f-string A veces quieres crear una cadena e incrustar los valores de variables en ella. Para hacer esto, utiliza una f-string. Por ejemplo: >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{shares} acciones de {name} a ${price:0.2f}' '100 acciones de IBM a $91.10' >>> Modifique el programa mortgage.py del [Ejercicio 1.1] usando f-strings. Intente hacer que la salida est\u00e9 bien alineada. Ejercicio 1.18: Expresiones regulares Una limitaci\u00f3n de las operaciones de cadenas b\u00e1sicas es que no admiten ning\u00fan tipo de coincidencia de patrones avanzada. Para ello, es necesario recurrir al m\u00f3dulo re de Python y a las expresiones regulares. El manejo de expresiones regulares es un tema amplio, pero aqu\u00ed hay un breve ejemplo: >>> texto = 'Hoy es 27/3/2018. Ma\u00f1ana es 28/03/2018.' >>> # Encuentra todas las ocurrencias de una fecha >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', texto) ['27/3/2018', '28/3/2018'] >>> # Reemplaza todas las apariciones de una fecha con el texto de reemplazo >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\1-\\2', texto) 'Hoy es 2018-27-3. Ma\u00f1ana es 2018-28-03.' >>> Para obtener m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , consulte la documentaci\u00f3n oficial en https://docs.python.org/library/re.html . Comentario A medida que comienza a experimentar con el int\u00e9rprete, a menudo desea saber m\u00e1s sobre las operaciones admitidas por los diferentes objetos. Por ejemplo, \u00bfc\u00f3mo saber qu\u00e9 operaciones est\u00e1n disponibles en una cadena? Dependiendo de su entorno de Python, es posible que pueda ver una lista de m\u00e9todos disponibles mediante la funci\u00f3n de completar tabulaciones. Por ejemplo, intenta escribir esto: >>> s = 'hola mundo' >>> s.<tecla de tabulaci\u00f3n> # Algunas veces tendr\u00e1s que colocar <tecla de tabulaci\u00f3n> dos veces. >>> Si presionar la tecla tab no hace nada, puedes recurrir a la funci\u00f3n incorporada dir() . Por ejemplo: >>> s = 'hola' >>> dir(s) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista de todas las operaciones que pueden aparecer despu\u00e9s de (.) . Utilice el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: help(s.upper) Help on built-in function upper: upper() method of builtins.str instance Return a copy of the string converted to uppercase. >>> Devuelve una copia de la cadena s convertida a may\u00fasculas. Contenido | Anterior (1.3 N\u00fameros) | Pr\u00f3ximo (1.5 Listas)","title":"04_Strings"},{"location":"01_Introduction/04_Strings/#14-strings","text":"Esta secci\u00f3n presenta formas de trabajar con texto. IMPORTANTE: Las palabras string y cadena son utilizadas con el mismo significado","title":"1.4 Strings"},{"location":"01_Introduction/04_Strings/#representacion-de-texto-literal","text":"Los literales de cadena se escriben en programas con comillas. # Comillas simples a = 'S\u00ed, pero no, pero s\u00ed, pero...' # Comillas dobles b = \"la computadora dice que no\" # Comillas triples c = ''' M\u00edrame a los ojos, m\u00edrame a los ojos, a los ojos, a los ojos, a los ojos, No alrededor de los ojos, no mires alrededor de los ojos, m\u00edrame a los ojos, est\u00e1s debajo. ''' Normalmente, los strings solo pueden abarcar una \u00fanica l\u00ednea. Las comillas triples capturan todo el texto encerrado en varias l\u00edneas, incluido todo el formato. No hay diferencia entre usar comillas simples ' o dobles \" . Sin embargo, se debe usar el mismo tipo de comillas utilizadas para iniciar una cadena para terminarla .","title":"Representaci\u00f3n de texto literal"},{"location":"01_Introduction/04_Strings/#codigos-de-escape-de-cadenas","text":"Los c\u00f3digos de escape se utilizan para representar caracteres de control y caracteres que no se pueden escribir f\u00e1cilmente directamente en el teclado. A continuaci\u00f3n se muestran algunos c\u00f3digos de escape comunes: '\\n' Salto de l\u00ednea '\\r' Retorno de carro '\\t' Tabulador '\\'' Comilla simple literal '\\\"' Comillas dobles literal '\\\\' Barra invertida literal","title":"C\u00f3digos de escape de cadenas"},{"location":"01_Introduction/04_Strings/#representacion-de-cadena","text":"Cada car\u00e1cter de una cadena se almacena internamente como un denominado punto de c\u00f3digo Unicode, que es un n\u00famero entero. Puede especificar un valor de punto de c\u00f3digo exacto utilizando las siguientes secuencias de escape: a = '\\xf1' # a = '\u00f1' b = '\\u2200' # b = '\u2200' c = '\\U0001D122' # c = '\ud834\udd22' d = '\\N{FOR ALL}' # d = '\u2200' La base de datos de caracteres Unicode es una referencia para todos los c\u00f3digos de caracteres disponibles.","title":"Representaci\u00f3n de cadena"},{"location":"01_Introduction/04_Strings/#indexacion-de-strings","text":"Los strings funcionan como una matriz para acceder a caracteres individuales. Se utiliza un \u00edndice entero, que comienza en 0. Los \u00edndices negativos especifican una posici\u00f3n relativa al final del string. a = 'Hola mundo' b = a[0] # 'H' c = a[4] # '' d = a[-1] # 'o' (fin de la cadena) Tambi\u00e9n puedes cortar o seleccionar substrings especificando un rango de \u00edndices con : . d = a[:5] # 'Hola' e = a[6:] # 'undo' f = a[3:8] # 'a mun' g = a[-5:] # 'mundo' El car\u00e1cter del \u00edndice final no est\u00e1 incluido. Los \u00edndices faltantes suponen el principio o el final de la cadena.","title":"Indexaci\u00f3n de strings"},{"location":"01_Introduction/04_Strings/#operaciones-con-cadenas","text":"Concatenaci\u00f3n, longitud, membres\u00eda y replicaci\u00f3n. # Concatenaci\u00f3n (+) a = 'Hola' + 'Mundo' # 'HolaMundo' b = 'Decir ' + a # 'Decir HolaMundo' # Longitud (len) s = 'Hola' len(s) # 4 # Prueba de membres\u00eda (`in`, `not in`) t = 'o' in s # True f = 'x' in s # False g = 'hola' not in s # True # Replicaci\u00f3n (s * n) rep = s * 5 # 'HolaHolaHolaHolaHola'","title":"Operaciones con cadenas"},{"location":"01_Introduction/04_Strings/#metodos-de-cadena","text":"Los strings tienen m\u00e9todos que realizan varias operaciones con los datos de los mismos. Ejemplo: eliminar cualquier espacio en blanco inicial o final. s = ' Hola ' t = s.strip() # 'Hola' Ejemplo: Conversi\u00f3n de may\u00fasculas y min\u00fasculas. s = 'Hola' l = s.lower() # 'hola' u = s.upper() # 'HOLA' Ejemplo: Reemplazar texto. s = 'Hola mundo' t = s.replace('Hola' , 'Hello') # 'Hello mundo' M\u00e1s m\u00e9todos de String: Las cadenas tienen una amplia variedad de otros m\u00e9todos para probar y manipular los datos de texto. Esta es una peque\u00f1a muestra de m\u00e9todos: s.endswith(suffix) # Verifica si la cadena termina con suffix s.find(t) # Primera aparici\u00f3n de t en s s.index(t) # Primera aparici\u00f3n de t en s s.isalpha() # Comprueba si los caracteres son alfab\u00e9ticos s.isdigit() # Comprueba si los caracteres son num\u00e9ricos s.islower() # Verifica si los caracteres est\u00e1n en min\u00fasculas s.isupper() # Verifica si los caracteres est\u00e1n en may\u00fasculas s.join(slist) # Une una lista de cadenas usando s como delimitador s.lower() # Convierte a min\u00fasculas s.replace(old,new) # Reemplaza texto s.rfind(t) # Busca t desde el final de la cadena s.rindex(t) # Busca t desde el final de la cadena s.split([delim]) # Divide la cadena en una lista de subcadenas s.startswith(prefix) # Verifica si la cadena comienza con prefijo s.strip() # Elimina los espacios iniciales y finales s.upper() # Convierte a may\u00fasculas","title":"M\u00e9todos de cadena"},{"location":"01_Introduction/04_Strings/#mutabilidad-de-los-strings","text":"Los strings son \"inmutables\" o de s\u00f3lo lectura. Una vez creado, el valor no se puede cambiar. >>> s = 'Hola mundo' >>> s[1] = 'a' Traceback (most recent call last): File \"<python-input-5>\", line 1, in <module> s[1] = 'a' ~^^^ TypeError: 'str' object does not support item assignment >>> Todas las operaciones y m\u00e9todos que manipulan datos de strings, siempre crean nuevos strings.","title":"Mutabilidad de los strings"},{"location":"01_Introduction/04_Strings/#conversiones-de-strings","text":"Utilice str() para convertir cualquier valor en un string. El resultado es un string que contiene el mismo texto que habr\u00eda sido producido por la declaraci\u00f3n print() . >>> x = 42 >>> str(x) '42' >>>","title":"Conversiones de strings"},{"location":"01_Introduction/04_Strings/#cadenas-de-bytes","text":"Una cadena de bytes de 8 bits, que se encuentra com\u00fanmente en E/S de bajo nivel, se escribe de la siguiente manera: datos = b'Hola mundo\\r\\n' Al colocar una b min\u00fascula antes de la primera comilla, especifica que se trata de una cadena de bytes y no de una cadena de texto. La mayor\u00eda de las operaciones de cadena habituales funcionan. len(datos) # 12 datos[0:4] # b'Hola' datos.replace(b'Hola', b'Cruel') # b'Cruel mundo\\r\\n' La indexaci\u00f3n es un poco diferente porque devuelve valores de bytes como n\u00fameros enteros. datos[0] # 72 (c\u00f3digo ASCII para 'H') Conversi\u00f3n a/desde cadenas de texto. texto = datos.decode('utf-8') # bytes -> texto datos = texto.encode('utf-8') # texto -> bytes El argumento \"utf-8\" especifica una codificaci\u00f3n de caracteres. Otros valores comunes incluyen \"ascii\" y \"latin1\".","title":"Cadenas de bytes"},{"location":"01_Introduction/04_Strings/#stings-sin-procesar","text":"Los strings sin formato son literales de strings con una barra invertida no interpretada. Ellos se especifican anteponiendo la comilla inicial con una \"r\" min\u00fascula. >>> rs = r'c:\\newdata\\test' # Sin formato (barra invertida no interpretada) >>> rs 'c:\\\\newdata\\\\prueba' Los strings son el texto literal incluido en el interior, exactamente como se escribe. Esto es \u00fatil en situaciones donde la barra invertida tiene un significado especial. Ejemplo: nombre de archivo, expresiones regulares, etc.","title":"Stings sin procesar"},{"location":"01_Introduction/04_Strings/#f-strings","text":"Una cadena con sustituci\u00f3n de expresi\u00f3n formateada. >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {acciones:10d} {precio:10.2f}' >>> a 'IBM 100 91.10' >>> b = f'Costo = ${acciones*precio:0.2f}' >>>b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o m\u00e1s reciente. El significado de los c\u00f3digos de formato se trata m\u00e1s adelante.","title":"f-strings"},{"location":"01_Introduction/04_Strings/#ejercicios","text":"En estos ejercicios, experimentar\u00e1 con operaciones usando el tipo de cadena de Python. Debes hacer esto en el modo interactivo de Python, donde podr\u00e1s ver f\u00e1cilmente los resultados. Nota importante: En ejercicios en los que se supone que debes interactuar con el int\u00e9rprete, >>> es el mensaje de solicitud del int\u00e9rprete que aparece cuando Python desea que escribas una nueva declaraci\u00f3n. Algunas afirmaciones en el ejercicio abarcan varias l\u00edneas: para que se ejecuten estas instrucciones, es posible que tenga que presionar 'Enter' unas cuantas veces. Solo un recordatorio de que NO debes escribir el >>> al trabajar estos ejemplos. Comience por definir una cadena que contenga una serie de s\u00edmbolos burs\u00e1tiles como este: >>> >>> symbols = 'AAPL,IBM,MSFT,YHOO,SCO' >>>","title":"Ejercicios"},{"location":"01_Introduction/04_Strings/#ejercicio-113-extraccion-de-caracteres-individuales-y-subcadenas","text":"Las cadenas son matrices de caracteres. Intente extraer algunos caracteres: >>> symbols[0] ? >>> symbols[1] ? >>> symbols[2] ? >>> symbols[-1] # \u00daltimo car\u00e1cter ? >>> symbols[-2] # Los \u00edndices negativos son desde el final de la cadena ? >>> En Python, las cadenas son de solo lectura. Verifique esto intentando cambiar el primer car\u00e1cter de 'symbols' a una 'a' min\u00fascula. >>> symbols[0] = 'a' Traceback (most recent call last): File \"<python-input-3>\", line 1, in <module> symbols[0] = 'a' ~~~~~~~^^^ TypeError: 'str' object does not support item assignment >>>","title":"Ejercicio 1.13: Extracci\u00f3n de caracteres individuales y subcadenas"},{"location":"01_Introduction/04_Strings/#ejercicio-114-concatenacion-de-cadenas","text":"Aunque los datos de cadena son de solo lectura, siempre puedes reasignar una variable a una cadena reci\u00e9n creada. Pruebe la siguiente declaraci\u00f3n que concatena un nuevo s\u00edmbolo \"GOOG\" a El final de los `symbols': >>> symbols = symbols + 'GOOG' >>> symbols 'AAPL,IBM,MSFT,YHOO,SCOGOOG' >>> \u00a1Ups! Eso no es lo que quer\u00edas. Arr\u00e9glelo para que la variable symbols contenga el valor 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' . >>> symbols = ? >>> symbols 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> A\u00f1ade 'HPQ' al principio de la cadena: >>> symbols = ? >>> symbols 'HPQ,AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> En estos ejemplos, podr\u00eda parecer que se est\u00e1 modificando la cadena original, en una aparente violaci\u00f3n del principio de que las cadenas son de solo lectura. No es as\u00ed. Las operaciones sobre cadenas crean una cadena completamente nueva cada vez. Cuando se reasigna el nombre de la variable symbols , apunta a la cadena reci\u00e9n creada. Posteriormente la cadena vieja se destruye porque ya no se utiliza.","title":"Ejercicio 1.14: Concatenaci\u00f3n de cadenas"},{"location":"01_Introduction/04_Strings/#ejercicio-115-prueba-de-pertenencia-prueba-de-subcadenas","text":"Experimente con el operador in para comprobar si hay subcadenas. En modo interactivo: pruebe estas operaciones: >>> 'IBM' in symbols ? >>> 'AA' in symbols True >>> 'CAT' in symbols ? >>> \u00bfPor qu\u00e9 la verificaci\u00f3n de 'AA' devolvi\u00f3 True ?","title":"Ejercicio 1.15: Prueba de pertenencia (prueba de subcadenas)"},{"location":"01_Introduction/04_Strings/#ejercicio-116-metodos-de-cadena","text":"En el modo interactivo de Python, intente experimentar con algunos de los m\u00e9todos de cadena. >>> symbols.lower() ? >>> symbols ? >>> Recuerde, las cadenas siempre son de solo lectura. Si desea guardar el resultado de una operaci\u00f3n, debe colocarlo en una variable: >>> lowersyms = symbols.lower() >>> Pruebe algunas operaciones m\u00e1s: >>> symbols.find('MSFT') ? >>> symbols[13:17] ? >>> symbols = symbols.replace('SCO','DOA') >>> symbols ? >>> name = ' IBM \\n' >>> name = name.strip() # Elimina los espacios en blanco circundantes >>> name ? >>>","title":"Ejercicio 1.16: M\u00e9todos de cadena"},{"location":"01_Introduction/04_Strings/#ejercicio-117-f-string","text":"A veces quieres crear una cadena e incrustar los valores de variables en ella. Para hacer esto, utiliza una f-string. Por ejemplo: >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{shares} acciones de {name} a ${price:0.2f}' '100 acciones de IBM a $91.10' >>> Modifique el programa mortgage.py del [Ejercicio 1.1] usando f-strings. Intente hacer que la salida est\u00e9 bien alineada.","title":"Ejercicio 1.17: f-string"},{"location":"01_Introduction/04_Strings/#ejercicio-118-expresiones-regulares","text":"Una limitaci\u00f3n de las operaciones de cadenas b\u00e1sicas es que no admiten ning\u00fan tipo de coincidencia de patrones avanzada. Para ello, es necesario recurrir al m\u00f3dulo re de Python y a las expresiones regulares. El manejo de expresiones regulares es un tema amplio, pero aqu\u00ed hay un breve ejemplo: >>> texto = 'Hoy es 27/3/2018. Ma\u00f1ana es 28/03/2018.' >>> # Encuentra todas las ocurrencias de una fecha >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', texto) ['27/3/2018', '28/3/2018'] >>> # Reemplaza todas las apariciones de una fecha con el texto de reemplazo >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\1-\\2', texto) 'Hoy es 2018-27-3. Ma\u00f1ana es 2018-28-03.' >>> Para obtener m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , consulte la documentaci\u00f3n oficial en https://docs.python.org/library/re.html .","title":"Ejercicio 1.18: Expresiones regulares"},{"location":"01_Introduction/04_Strings/#comentario","text":"A medida que comienza a experimentar con el int\u00e9rprete, a menudo desea saber m\u00e1s sobre las operaciones admitidas por los diferentes objetos. Por ejemplo, \u00bfc\u00f3mo saber qu\u00e9 operaciones est\u00e1n disponibles en una cadena? Dependiendo de su entorno de Python, es posible que pueda ver una lista de m\u00e9todos disponibles mediante la funci\u00f3n de completar tabulaciones. Por ejemplo, intenta escribir esto: >>> s = 'hola mundo' >>> s.<tecla de tabulaci\u00f3n> # Algunas veces tendr\u00e1s que colocar <tecla de tabulaci\u00f3n> dos veces. >>> Si presionar la tecla tab no hace nada, puedes recurrir a la funci\u00f3n incorporada dir() . Por ejemplo: >>> s = 'hola' >>> dir(s) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista de todas las operaciones que pueden aparecer despu\u00e9s de (.) . Utilice el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: help(s.upper) Help on built-in function upper: upper() method of builtins.str instance Return a copy of the string converted to uppercase. >>> Devuelve una copia de la cadena s convertida a may\u00fasculas. Contenido | Anterior (1.3 N\u00fameros) | Pr\u00f3ximo (1.5 Listas)","title":"Comentario"},{"location":"01_Introduction/05_Lists/","text":"Contenido | Anterior (1.4 Strings) | Pr\u00f3ximo (1.6 Archivos) 1.5 Listas Esta secci\u00f3n presenta las listas, el tipo principal de Python para almacenar una colecci\u00f3n ordenada de valores. Creando una lista Utilice corchetes para definir una lista literal: names = [ 'Elwood', 'Jake', 'Curtis' ] nums = [ 39, 38, 42, 65, 111] A veces las listas se crean mediante otros m\u00e9todos. Por ejemplo, una cadena se puede dividir en una lista usando el m\u00e9todo split() : >>> line = 'GOOG,100,490.10' >>> row = line.split(',') >>> row ['GOOG', '100', '490.10'] >>> Operaciones de lista Las listas pueden contener elementos de cualquier tipo. Agregue un nuevo elemento usando append() : >>> names.append('Murphy') # Agrega al final >>> names.insert(2, 'Aretha') # Inserta en el medio >>> names ['Elwood', 'Jake', 'Aretha', 'Curtis', 'Murphy'] Utilice + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas se indexan mediante n\u00fameros enteros. Empezando desde 0. names = [ 'Elwood', 'Jake', 'Curtis' ] names[0] # 'Elwood' names[1] # 'Jake' names[2] # 'Curtis' Los \u00edndices negativos cuentan desde el final. names[-1] # 'Curtis' Puede cambiar cualquier elemento de una lista. names[1] = 'Joliet Jake' names # [ 'Elwood', 'Joliet Jake', 'Curtis' ] Longitud de la lista. names = ['Elwood','Jake','Curtis'] len(names) # 3 Prueba de membres\u00eda ( in , not in ). 'Elwood' in names # True 'Britney' not in names # True Replicaci\u00f3n ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3] Iteraci\u00f3n y b\u00fasqueda en listas Utilice for para iterar sobre el contenido de la lista. for name in names: # use name # e.g. print(name) ... Esto es similar a una declaraci\u00f3n foreach de otros lenguajes de programaci\u00f3n. Para encontrar la posici\u00f3n de algo r\u00e1pidamente, utilice index() . names = ['Elwood','Jake','Curtis'] names.index('Curtis') # 2 Si el elemento est\u00e1 presente m\u00e1s de una vez, index() devolver\u00e1 el \u00edndice de la primera aparici\u00f3n. Si no se encuentra el elemento, se generar\u00e1 una excepci\u00f3n 'ValueError'. Eliminaci\u00f3n de lista Puede eliminar elementos por valor de elemento o por \u00edndice: # Usando el valor names.remove('Curtis') # Usando el \u00edndice del names[1] Quitar un elemento no crea un agujero. Otros elementos se mover\u00e1n hacia abajo para llenar el espacio dejado vacante. Si hay m\u00e1s de una ocurrencia del elemento, remove() eliminar\u00e1 solo la primera ocurrencia. Ordenaci\u00f3n de listas Las listas se pueden ordenar \"en el lugar\" (\"in-place\"). s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Orden inverso s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # Funciona con cualquier dato ordenado s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Utilice sorted() si desea crear una nueva lista: t = sorted(s) # s sin cambios, t contiene valores ordenados Listas y matem\u00e1ticas Precauci\u00f3n: Las listas no fueron dise\u00f1adas para operaciones matem\u00e1ticas. >>> nums = [1, 2, 3, 4, 5] >>> nums * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nums + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores/matrices como en MATLAB, Octave, R, etc. Sin embargo, existen algunos paquetes que pueden ayudarte con eso (por ejemplo, numpy ). Ejercicios En este ejercicio, experimentamos con el tipo de datos de lista de Python. En la \u00faltima secci\u00f3n, trabajaste con cadenas que conten\u00edan s\u00edmbolos burs\u00e1tiles. >>> symbols = 'HPQ,AAPL,IBM,MSFT,YHOO,DOA,GOOG' Div\u00eddalo en una lista de nombres utilizando la operaci\u00f3n split() de cadenas: >>> symlist = symbols.split(',') Ejercicio 1.19: Extracci\u00f3n y reasignaci\u00f3n de elementos de lista Pruebe algunas b\u00fasquedas: >>> symlist[0] 'HPQ' >>> symlist[1] 'AAPL' >>> symlist[-1] 'GOOG' >>> symlist[-2] 'DOA' >>> Intente reasignar un valor: >>> symlist[2] = 'AIG' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG'] >>> Tome algunas rebanadas: >>> symlist[0:3] ['HPQ', 'AAPL', 'AIG'] >>> symlist[-2:] ['DOA', 'GOOG'] >>> Crea una lista vac\u00eda y agr\u00e9gale un elemento. >>> mysyms = [] >>> mysyms.append('GOOG') >>> mysyms ['GOOG'] Puede reasignar una parte de una lista a otra lista. Por ejemplo: >>> symlist[-2:] = mysyms >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG'] >>> Al hacer esto, la lista del lado izquierdo ( symlist ) se redimensionar\u00e1 seg\u00fan corresponda para que encaje en el lado derecho ( mysyms ). Por ejemplo, en el ejemplo anterior, los dos \u00faltimos elementos de symlist fueron reemplazados por el \u00fanico elemento de la lista mysyms . Ejercicio 1.20: Recorrer los elementos de la lista El bucle for funciona recorriendo los datos de una secuencia, como por ejemplo una lista. Compru\u00e9belo escribiendo el siguiente bucle y observando lo que sucede: >>> for s in symlist: print('s =', s) # Mire la salida Ejercicio 1.21: Pruebas de pertenencia Utilice el operador in o not in para comprobar si 'AIG' , 'AA' y 'CAT' est\u00e1n en la lista de s\u00edmbolos. >>> # Est\u00e1 'AIG' en `symlist`? True >>> # Est\u00e1 'AA' en `symlist`? False >>> # NO Est\u00e1 'CAT' en `symlist`? True >>> Ejercicio 1.22: A\u00f1adir, insertar y eliminar elementos Utilice el m\u00e9todo append() para agregar el s\u00edmbolo 'RHT' al final de symlist . >>> # append 'RHT' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo insert() para insertar el s\u00edmbolo 'AA' como el segundo elemento de la lista. >>> # Inserta 'AA' como el segundo elemento de la lista >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo remove() para eliminar 'MSFT' de la lista. >>> # Elimina 'MSFT' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT'] >>> A\u00f1ade una entrada duplicada para 'YHOO' al final de la lista. Nota: Es perfectamente correcto que una lista tenga elementos duplicados. >>> # A\u00f1ade 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO'] >>> Utilice el m\u00e9todo index() para encontrar la primera posici\u00f3n de 'YHOO' en la lista. >>> # Encuentra el primer \u00edndice de 'YHOO' 4 >>> symlist[4] 'YHOO' >>> Cuenta cu\u00e1ntas veces aparece 'YHOO' en la lista: >>> symlist.count('YHOO') 2 >>> Elimina la primera aparici\u00f3n de \"YHOO\". >>> # Elimina la primera aparici\u00f3n de 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO'] >>> Para que lo sepas, no existe ning\u00fan m\u00e9todo para encontrar o eliminar todas las apariciones de un elemento. Sin embargo, veremos una forma elegante de hacerlo en la secci\u00f3n 2. Ejercicio 1.23: Ordenamiento \u00bfQuieres ordenar una lista? Utilice el m\u00e9todo sort() . Pru\u00e9balo: >>> symlist.sort() >>> symlist ['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO'] >>> \u00bfQuieres ordenar en sentido inverso? Prueba esto: >>> symlist.sort(reverse=True) >>> symlist ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> Nota: Ordenar una lista modifica su contenido \"en el lugar\". Es decir, los elementos de la lista se ordenan, pero no se crea ninguna lista nueva como resultado. Ejercicio 1.24: Poni\u00e9ndolo todo junto de nuevo \u00bfQuieres tomar una lista de cadenas y unirlas en una sola cadena? Utilice el m\u00e9todo join() de cadenas como esta (nota: esto parece extra\u00f1o al principio). >>> a = ','.join(symlist) >>> a 'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA' >>> b = ':'.join(symlist) >>> b 'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA' >>> c = ''.join(symlist) >>> c 'YHOORHTHPQGOOGAIGAAPLAA' >>> Ejercicio 1.25: Listas de cualquier cosa Las listas pueden contener cualquier tipo de objeto, incluidas otras listas (por ejemplo, listas anidadas). Prueba esto: >>> nums = [101, 102, 103] >>> items = ['spam', symlist, nums] >>> items ['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]] Preste mucha atenci\u00f3n al resultado anterior. items es una lista con tres elementos. El primer elemento es una cadena, pero los otros dos elementos son listas. Puede acceder a los elementos de las listas anidadas mediante m\u00faltiples operaciones de indexaci\u00f3n. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> items[1][1] 'RHT' >>> items[1][1][2] 'T' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> Si bien es t\u00e9cnicamente posible crear estructuras de listas muy complicadas, como regla general, conviene mantener las cosas simples. Generalmente las listas contienen elementos que tienen todos el mismo tipo de valor. Por ejemplo, una lista que consta enteramente de n\u00fameros o una lista de cadenas de texto. Mezclar distintos tipos de datos en la misma lista suele ser una buena forma de hacer que te explote la cabeza, por lo que es mejor evitarlo. Contenido | Anterior (1.4 Strings) | Pr\u00f3ximo (1.6 Archivos)","title":"05_Lists"},{"location":"01_Introduction/05_Lists/#15-listas","text":"Esta secci\u00f3n presenta las listas, el tipo principal de Python para almacenar una colecci\u00f3n ordenada de valores.","title":"1.5 Listas"},{"location":"01_Introduction/05_Lists/#creando-una-lista","text":"Utilice corchetes para definir una lista literal: names = [ 'Elwood', 'Jake', 'Curtis' ] nums = [ 39, 38, 42, 65, 111] A veces las listas se crean mediante otros m\u00e9todos. Por ejemplo, una cadena se puede dividir en una lista usando el m\u00e9todo split() : >>> line = 'GOOG,100,490.10' >>> row = line.split(',') >>> row ['GOOG', '100', '490.10'] >>>","title":"Creando una lista"},{"location":"01_Introduction/05_Lists/#operaciones-de-lista","text":"Las listas pueden contener elementos de cualquier tipo. Agregue un nuevo elemento usando append() : >>> names.append('Murphy') # Agrega al final >>> names.insert(2, 'Aretha') # Inserta en el medio >>> names ['Elwood', 'Jake', 'Aretha', 'Curtis', 'Murphy'] Utilice + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas se indexan mediante n\u00fameros enteros. Empezando desde 0. names = [ 'Elwood', 'Jake', 'Curtis' ] names[0] # 'Elwood' names[1] # 'Jake' names[2] # 'Curtis' Los \u00edndices negativos cuentan desde el final. names[-1] # 'Curtis' Puede cambiar cualquier elemento de una lista. names[1] = 'Joliet Jake' names # [ 'Elwood', 'Joliet Jake', 'Curtis' ] Longitud de la lista. names = ['Elwood','Jake','Curtis'] len(names) # 3 Prueba de membres\u00eda ( in , not in ). 'Elwood' in names # True 'Britney' not in names # True Replicaci\u00f3n ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3]","title":"Operaciones de lista"},{"location":"01_Introduction/05_Lists/#iteracion-y-busqueda-en-listas","text":"Utilice for para iterar sobre el contenido de la lista. for name in names: # use name # e.g. print(name) ... Esto es similar a una declaraci\u00f3n foreach de otros lenguajes de programaci\u00f3n. Para encontrar la posici\u00f3n de algo r\u00e1pidamente, utilice index() . names = ['Elwood','Jake','Curtis'] names.index('Curtis') # 2 Si el elemento est\u00e1 presente m\u00e1s de una vez, index() devolver\u00e1 el \u00edndice de la primera aparici\u00f3n. Si no se encuentra el elemento, se generar\u00e1 una excepci\u00f3n 'ValueError'.","title":"Iteraci\u00f3n y b\u00fasqueda en listas"},{"location":"01_Introduction/05_Lists/#eliminacion-de-lista","text":"Puede eliminar elementos por valor de elemento o por \u00edndice: # Usando el valor names.remove('Curtis') # Usando el \u00edndice del names[1] Quitar un elemento no crea un agujero. Otros elementos se mover\u00e1n hacia abajo para llenar el espacio dejado vacante. Si hay m\u00e1s de una ocurrencia del elemento, remove() eliminar\u00e1 solo la primera ocurrencia.","title":"Eliminaci\u00f3n de lista"},{"location":"01_Introduction/05_Lists/#ordenacion-de-listas","text":"Las listas se pueden ordenar \"en el lugar\" (\"in-place\"). s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Orden inverso s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # Funciona con cualquier dato ordenado s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Utilice sorted() si desea crear una nueva lista: t = sorted(s) # s sin cambios, t contiene valores ordenados","title":"Ordenaci\u00f3n de listas"},{"location":"01_Introduction/05_Lists/#listas-y-matematicas","text":"Precauci\u00f3n: Las listas no fueron dise\u00f1adas para operaciones matem\u00e1ticas. >>> nums = [1, 2, 3, 4, 5] >>> nums * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nums + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores/matrices como en MATLAB, Octave, R, etc. Sin embargo, existen algunos paquetes que pueden ayudarte con eso (por ejemplo, numpy ).","title":"Listas y matem\u00e1ticas"},{"location":"01_Introduction/05_Lists/#ejercicios","text":"En este ejercicio, experimentamos con el tipo de datos de lista de Python. En la \u00faltima secci\u00f3n, trabajaste con cadenas que conten\u00edan s\u00edmbolos burs\u00e1tiles. >>> symbols = 'HPQ,AAPL,IBM,MSFT,YHOO,DOA,GOOG' Div\u00eddalo en una lista de nombres utilizando la operaci\u00f3n split() de cadenas: >>> symlist = symbols.split(',')","title":"Ejercicios"},{"location":"01_Introduction/05_Lists/#ejercicio-119-extraccion-y-reasignacion-de-elementos-de-lista","text":"Pruebe algunas b\u00fasquedas: >>> symlist[0] 'HPQ' >>> symlist[1] 'AAPL' >>> symlist[-1] 'GOOG' >>> symlist[-2] 'DOA' >>> Intente reasignar un valor: >>> symlist[2] = 'AIG' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG'] >>> Tome algunas rebanadas: >>> symlist[0:3] ['HPQ', 'AAPL', 'AIG'] >>> symlist[-2:] ['DOA', 'GOOG'] >>> Crea una lista vac\u00eda y agr\u00e9gale un elemento. >>> mysyms = [] >>> mysyms.append('GOOG') >>> mysyms ['GOOG'] Puede reasignar una parte de una lista a otra lista. Por ejemplo: >>> symlist[-2:] = mysyms >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG'] >>> Al hacer esto, la lista del lado izquierdo ( symlist ) se redimensionar\u00e1 seg\u00fan corresponda para que encaje en el lado derecho ( mysyms ). Por ejemplo, en el ejemplo anterior, los dos \u00faltimos elementos de symlist fueron reemplazados por el \u00fanico elemento de la lista mysyms .","title":"Ejercicio 1.19: Extracci\u00f3n y reasignaci\u00f3n de elementos de lista"},{"location":"01_Introduction/05_Lists/#ejercicio-120-recorrer-los-elementos-de-la-lista","text":"El bucle for funciona recorriendo los datos de una secuencia, como por ejemplo una lista. Compru\u00e9belo escribiendo el siguiente bucle y observando lo que sucede: >>> for s in symlist: print('s =', s) # Mire la salida","title":"Ejercicio 1.20: Recorrer los elementos de la lista"},{"location":"01_Introduction/05_Lists/#ejercicio-121-pruebas-de-pertenencia","text":"Utilice el operador in o not in para comprobar si 'AIG' , 'AA' y 'CAT' est\u00e1n en la lista de s\u00edmbolos. >>> # Est\u00e1 'AIG' en `symlist`? True >>> # Est\u00e1 'AA' en `symlist`? False >>> # NO Est\u00e1 'CAT' en `symlist`? True >>>","title":"Ejercicio 1.21: Pruebas de pertenencia"},{"location":"01_Introduction/05_Lists/#ejercicio-122-anadir-insertar-y-eliminar-elementos","text":"Utilice el m\u00e9todo append() para agregar el s\u00edmbolo 'RHT' al final de symlist . >>> # append 'RHT' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo insert() para insertar el s\u00edmbolo 'AA' como el segundo elemento de la lista. >>> # Inserta 'AA' como el segundo elemento de la lista >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo remove() para eliminar 'MSFT' de la lista. >>> # Elimina 'MSFT' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT'] >>> A\u00f1ade una entrada duplicada para 'YHOO' al final de la lista. Nota: Es perfectamente correcto que una lista tenga elementos duplicados. >>> # A\u00f1ade 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO'] >>> Utilice el m\u00e9todo index() para encontrar la primera posici\u00f3n de 'YHOO' en la lista. >>> # Encuentra el primer \u00edndice de 'YHOO' 4 >>> symlist[4] 'YHOO' >>> Cuenta cu\u00e1ntas veces aparece 'YHOO' en la lista: >>> symlist.count('YHOO') 2 >>> Elimina la primera aparici\u00f3n de \"YHOO\". >>> # Elimina la primera aparici\u00f3n de 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO'] >>> Para que lo sepas, no existe ning\u00fan m\u00e9todo para encontrar o eliminar todas las apariciones de un elemento. Sin embargo, veremos una forma elegante de hacerlo en la secci\u00f3n 2.","title":"Ejercicio 1.22: A\u00f1adir, insertar y eliminar elementos"},{"location":"01_Introduction/05_Lists/#ejercicio-123-ordenamiento","text":"\u00bfQuieres ordenar una lista? Utilice el m\u00e9todo sort() . Pru\u00e9balo: >>> symlist.sort() >>> symlist ['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO'] >>> \u00bfQuieres ordenar en sentido inverso? Prueba esto: >>> symlist.sort(reverse=True) >>> symlist ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> Nota: Ordenar una lista modifica su contenido \"en el lugar\". Es decir, los elementos de la lista se ordenan, pero no se crea ninguna lista nueva como resultado.","title":"Ejercicio 1.23: Ordenamiento"},{"location":"01_Introduction/05_Lists/#ejercicio-124-poniendolo-todo-junto-de-nuevo","text":"\u00bfQuieres tomar una lista de cadenas y unirlas en una sola cadena? Utilice el m\u00e9todo join() de cadenas como esta (nota: esto parece extra\u00f1o al principio). >>> a = ','.join(symlist) >>> a 'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA' >>> b = ':'.join(symlist) >>> b 'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA' >>> c = ''.join(symlist) >>> c 'YHOORHTHPQGOOGAIGAAPLAA' >>>","title":"Ejercicio 1.24: Poni\u00e9ndolo todo junto de nuevo"},{"location":"01_Introduction/05_Lists/#ejercicio-125-listas-de-cualquier-cosa","text":"Las listas pueden contener cualquier tipo de objeto, incluidas otras listas (por ejemplo, listas anidadas). Prueba esto: >>> nums = [101, 102, 103] >>> items = ['spam', symlist, nums] >>> items ['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]] Preste mucha atenci\u00f3n al resultado anterior. items es una lista con tres elementos. El primer elemento es una cadena, pero los otros dos elementos son listas. Puede acceder a los elementos de las listas anidadas mediante m\u00faltiples operaciones de indexaci\u00f3n. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> items[1][1] 'RHT' >>> items[1][1][2] 'T' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> Si bien es t\u00e9cnicamente posible crear estructuras de listas muy complicadas, como regla general, conviene mantener las cosas simples. Generalmente las listas contienen elementos que tienen todos el mismo tipo de valor. Por ejemplo, una lista que consta enteramente de n\u00fameros o una lista de cadenas de texto. Mezclar distintos tipos de datos en la misma lista suele ser una buena forma de hacer que te explote la cabeza, por lo que es mejor evitarlo. Contenido | Anterior (1.4 Strings) | Pr\u00f3ximo (1.6 Archivos)","title":"Ejercicio 1.25: Listas de cualquier cosa"},{"location":"01_Introduction/06_Files/","text":"Contents | Previous (1.5 Lists) | Pr\u00f3ximo (1.7 Functions) 1.6 Gesti\u00f3n de archivos La mayor\u00eda de los programas necesitan leer la entrada desde alg\u00fan lugar. Esta secci\u00f3n analiza el acceso a archivos. Entrada y salida de archivos Abrir un archivo. f = open('foo.txt', 'rt') # Abrir para lectura (r) (texto) (t) g = open('bar.txt', 'wt') # Abrir para escritura (w) (texto) (t) Leer todos los datos. data = f.read() # Leer solo hasta 'maxbytes' bytes data = f.read([maxbytes]) Escribe alg\u00fan texto. g.write('alg\u00fan texto') Ci\u00e9rralo cuando hayas terminado. f.close() g.close() Los archivos deben estar correctamente cerrados y es un paso f\u00e1cil de olvidar. Por lo tanto, el enfoque preferido es utilizar la declaraci\u00f3n with de esta manera. with open(filename, 'rt') as file: # Utilice el archivo `file` ... # No es necesario cerrar expl\u00edcitamente ...declaraciones Esto cierra autom\u00e1ticamente el archivo cuando el control abandona el bloque de c\u00f3digo sangrado. Modismos comunes para leer datos de archivos Leer un archivo completo de una sola vez como una cadena. with open('foo.txt', 'rt') as file: data = file.read() # `data` es una cadena con todo el texto en `foo.txt` Leer un archivo l\u00ednea por l\u00ednea iterando. with open(filename, 'rt') as file: for line in file: # Procesar la l\u00ednea Modismos comunes para escribir en un archivo Escribe datos de cadena. with open('outfile', 'wt') as out: out.write('Hola mundo\\n') ... Redirigir la funci\u00f3n de impresi\u00f3n. with open('outfile', 'wt') as out: print('Hola mundo', file=out) ... Ejercicios Estos ejercicios dependen del archivo Data/portfolio.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre una cartera de acciones. Se supone que est\u00e1 trabajando en el directorio practical-python/Work/ . Si no est\u00e1 seguro, puede averiguar d\u00f3nde cree Python que se est\u00e1 ejecutando, haciendo esto: >>> import os >>> os.getcwd() '/Users/beazley/practical-python/Work' # La salida var\u00eda >>> Ejercicio 1.26: Preliminares del archivo Primero, intente leer el archivo completo de una sola vez como una gran cadena: >>> with open('Data/portfolio.csv', 'rt') as f: data = f.read() >>> data 'name,shares,price\\n\"AA\",100,32.20\\n\"IBM\",50,91.10\\n\"CAT\",150,83.44\\n\"MSFT\",200,51.23\\n\"GE\",95,40.37\\n\"MSFT\",50,65.10\\n\"IBM\",100,70.44\\n' >>> print(data) name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> En el ejemplo anterior, debe tenerse en cuenta que Python tiene dos modos de salida. En el primer modo, donde escribe data en modo interactivo, Python le muestra la representaci\u00f3n de la cadena sin procesar, incluidas comillas y c\u00f3digos de escape. Cuando escribe print(data) , obtiene la salida formateada real de la cadena. Aunque leer un archivo de una sola vez es sencillo, a menudo no es la forma m\u00e1s adecuada de hacerlo, especialmente si el archivo es enorme o si contiene l\u00edneas de texto que desea manejar de a una por vez. Para leer un archivo l\u00ednea por l\u00ednea, utilice un bucle for como este: >>> with open('Data/portfolio.csv', 'rt') as f: for line in f: print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> Cuando se utiliza este c\u00f3digo, las l\u00edneas se leen hasta llegar al final del archivo, momento en el que el bucle se detiene. En ciertas ocasiones, es posible que desees leer o omitir manualmente una sola l\u00ednea de texto (por ejemplo, tal vez desees omitir la primera l\u00ednea de los encabezados de columna). >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f) >>> headers 'name,shares,price\\n' >>> for line in f: print(line, end='') \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> f.close() >>> next() devuelve la siguiente l\u00ednea de texto en el archivo. Si lo llamaras repetidamente obtendr\u00edas l\u00edneas sucesivas. Sin embargo, para que lo sepas, el bucle for ya utiliza next() para obtener sus datos. Por lo tanto, normalmente no lo llamar\u00edas directamente a menos que intentes omitir o leer expl\u00edcitamente una sola l\u00ednea como se muestra. Una vez que est\u00e9 leyendo l\u00edneas de un archivo, puede comenzar a realizar m\u00e1s procesamiento, como dividirlo. Por ejemplo, prueba esto: >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['name', 'shares', 'price\\n'] >>> for line in f: row = line.split(',') print(row) ['\"AA\"', '100', '32.20\\n'] ['\"IBM\"', '50', '91.10\\n'] ... >>> f.close() Nota: En estos ejemplos, se llama expl\u00edcitamente a f.close() porque no se est\u00e1 utilizando la declaraci\u00f3n with . Ejercicio 1.27: Lectura de un archivo de datos Ahora que sabes c\u00f3mo leer un archivo, escribamos un programa para realizar un c\u00e1lculo simple. Las columnas en portfolio.csv corresponden al nombre de la acci\u00f3n, el n\u00famero de acciones y el precio de compra de una sola participaci\u00f3n en acciones. Escriba un programa llamado pcost.py que abra este archivo, lea todas las l\u00edneas y calcule cu\u00e1nto cuesta comprar todas las acciones de la cartera. Sugerencia: para convertir una cadena en un entero, utilice int(s) . Para convertir una cadena en un punto flotante, utilice float(s) . Su programa deber\u00eda imprimir una salida como la siguiente: Total cost 44671.15 Ejercicio 1.28: Otro tipo de \"archivos\" \u00bfQu\u00e9 sucede si desea leer un archivo que no es de texto, como un archivo de datos comprimido con gzip? La funci\u00f3n incorporada open() no te ayudar\u00e1 aqu\u00ed, pero Python tiene un m\u00f3dulo de biblioteca gzip que puede leer archivos comprimidos gzip. Pru\u00e9balo: >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f: for line in f: print(line, end='') ... look at the output ... >>> Nota: Incluir el modo de archivo \"rt\" es fundamental aqu\u00ed. Si olvidas esto, obtendr\u00e1s cadenas de bytes en lugar de cadenas de texto normales. Comentario: \u00bfNo deber\u00edamos usar Pandas para esto? Los cient\u00edficos de datos se apresuran a se\u00f1alar que bibliotecas como Pandas ya tienen una funci\u00f3n para leer archivos CSV. Esto es cierto y funciona bastante bien. Sin embargo, este no es un curso para aprender Pandas. La lectura de archivos es un problema m\u00e1s general que los detalles espec\u00edficos de los archivos CSV. La raz\u00f3n principal por la que trabajamos con un archivo CSV es que es un formato familiar para la mayor\u00eda de los codificadores y es relativamente f\u00e1cil trabajar con \u00e9l directamente, lo que ilustra muchas caracter\u00edsticas de Python en el proceso. As\u00ed que, sin duda, utiliza Pandas cuando vuelvas a trabajar. Sin embargo, durante el resto de este curso nos quedaremos con la funcionalidad est\u00e1ndar de Python. Contents | Previous (1.5 Lists) | Pr\u00f3ximo (1.7 Functions)","title":"06_Files"},{"location":"01_Introduction/06_Files/#16-gestion-de-archivos","text":"La mayor\u00eda de los programas necesitan leer la entrada desde alg\u00fan lugar. Esta secci\u00f3n analiza el acceso a archivos.","title":"1.6 Gesti\u00f3n de archivos"},{"location":"01_Introduction/06_Files/#entrada-y-salida-de-archivos","text":"Abrir un archivo. f = open('foo.txt', 'rt') # Abrir para lectura (r) (texto) (t) g = open('bar.txt', 'wt') # Abrir para escritura (w) (texto) (t) Leer todos los datos. data = f.read() # Leer solo hasta 'maxbytes' bytes data = f.read([maxbytes]) Escribe alg\u00fan texto. g.write('alg\u00fan texto') Ci\u00e9rralo cuando hayas terminado. f.close() g.close() Los archivos deben estar correctamente cerrados y es un paso f\u00e1cil de olvidar. Por lo tanto, el enfoque preferido es utilizar la declaraci\u00f3n with de esta manera. with open(filename, 'rt') as file: # Utilice el archivo `file` ... # No es necesario cerrar expl\u00edcitamente ...declaraciones Esto cierra autom\u00e1ticamente el archivo cuando el control abandona el bloque de c\u00f3digo sangrado.","title":"Entrada y salida de archivos"},{"location":"01_Introduction/06_Files/#modismos-comunes-para-leer-datos-de-archivos","text":"Leer un archivo completo de una sola vez como una cadena. with open('foo.txt', 'rt') as file: data = file.read() # `data` es una cadena con todo el texto en `foo.txt` Leer un archivo l\u00ednea por l\u00ednea iterando. with open(filename, 'rt') as file: for line in file: # Procesar la l\u00ednea","title":"Modismos comunes para leer datos de archivos"},{"location":"01_Introduction/06_Files/#modismos-comunes-para-escribir-en-un-archivo","text":"Escribe datos de cadena. with open('outfile', 'wt') as out: out.write('Hola mundo\\n') ... Redirigir la funci\u00f3n de impresi\u00f3n. with open('outfile', 'wt') as out: print('Hola mundo', file=out) ...","title":"Modismos comunes para escribir en un archivo"},{"location":"01_Introduction/06_Files/#ejercicios","text":"Estos ejercicios dependen del archivo Data/portfolio.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre una cartera de acciones. Se supone que est\u00e1 trabajando en el directorio practical-python/Work/ . Si no est\u00e1 seguro, puede averiguar d\u00f3nde cree Python que se est\u00e1 ejecutando, haciendo esto: >>> import os >>> os.getcwd() '/Users/beazley/practical-python/Work' # La salida var\u00eda >>>","title":"Ejercicios"},{"location":"01_Introduction/06_Files/#ejercicio-126-preliminares-del-archivo","text":"Primero, intente leer el archivo completo de una sola vez como una gran cadena: >>> with open('Data/portfolio.csv', 'rt') as f: data = f.read() >>> data 'name,shares,price\\n\"AA\",100,32.20\\n\"IBM\",50,91.10\\n\"CAT\",150,83.44\\n\"MSFT\",200,51.23\\n\"GE\",95,40.37\\n\"MSFT\",50,65.10\\n\"IBM\",100,70.44\\n' >>> print(data) name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> En el ejemplo anterior, debe tenerse en cuenta que Python tiene dos modos de salida. En el primer modo, donde escribe data en modo interactivo, Python le muestra la representaci\u00f3n de la cadena sin procesar, incluidas comillas y c\u00f3digos de escape. Cuando escribe print(data) , obtiene la salida formateada real de la cadena. Aunque leer un archivo de una sola vez es sencillo, a menudo no es la forma m\u00e1s adecuada de hacerlo, especialmente si el archivo es enorme o si contiene l\u00edneas de texto que desea manejar de a una por vez. Para leer un archivo l\u00ednea por l\u00ednea, utilice un bucle for como este: >>> with open('Data/portfolio.csv', 'rt') as f: for line in f: print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> Cuando se utiliza este c\u00f3digo, las l\u00edneas se leen hasta llegar al final del archivo, momento en el que el bucle se detiene. En ciertas ocasiones, es posible que desees leer o omitir manualmente una sola l\u00ednea de texto (por ejemplo, tal vez desees omitir la primera l\u00ednea de los encabezados de columna). >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f) >>> headers 'name,shares,price\\n' >>> for line in f: print(line, end='') \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> f.close() >>> next() devuelve la siguiente l\u00ednea de texto en el archivo. Si lo llamaras repetidamente obtendr\u00edas l\u00edneas sucesivas. Sin embargo, para que lo sepas, el bucle for ya utiliza next() para obtener sus datos. Por lo tanto, normalmente no lo llamar\u00edas directamente a menos que intentes omitir o leer expl\u00edcitamente una sola l\u00ednea como se muestra. Una vez que est\u00e9 leyendo l\u00edneas de un archivo, puede comenzar a realizar m\u00e1s procesamiento, como dividirlo. Por ejemplo, prueba esto: >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['name', 'shares', 'price\\n'] >>> for line in f: row = line.split(',') print(row) ['\"AA\"', '100', '32.20\\n'] ['\"IBM\"', '50', '91.10\\n'] ... >>> f.close() Nota: En estos ejemplos, se llama expl\u00edcitamente a f.close() porque no se est\u00e1 utilizando la declaraci\u00f3n with .","title":"Ejercicio 1.26: Preliminares del archivo"},{"location":"01_Introduction/06_Files/#ejercicio-127-lectura-de-un-archivo-de-datos","text":"Ahora que sabes c\u00f3mo leer un archivo, escribamos un programa para realizar un c\u00e1lculo simple. Las columnas en portfolio.csv corresponden al nombre de la acci\u00f3n, el n\u00famero de acciones y el precio de compra de una sola participaci\u00f3n en acciones. Escriba un programa llamado pcost.py que abra este archivo, lea todas las l\u00edneas y calcule cu\u00e1nto cuesta comprar todas las acciones de la cartera. Sugerencia: para convertir una cadena en un entero, utilice int(s) . Para convertir una cadena en un punto flotante, utilice float(s) . Su programa deber\u00eda imprimir una salida como la siguiente: Total cost 44671.15","title":"Ejercicio 1.27: Lectura de un archivo de datos"},{"location":"01_Introduction/06_Files/#ejercicio-128-otro-tipo-de-archivos","text":"\u00bfQu\u00e9 sucede si desea leer un archivo que no es de texto, como un archivo de datos comprimido con gzip? La funci\u00f3n incorporada open() no te ayudar\u00e1 aqu\u00ed, pero Python tiene un m\u00f3dulo de biblioteca gzip que puede leer archivos comprimidos gzip. Pru\u00e9balo: >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f: for line in f: print(line, end='') ... look at the output ... >>> Nota: Incluir el modo de archivo \"rt\" es fundamental aqu\u00ed. Si olvidas esto, obtendr\u00e1s cadenas de bytes en lugar de cadenas de texto normales.","title":"Ejercicio 1.28: Otro tipo de \"archivos\""},{"location":"01_Introduction/06_Files/#comentario-no-deberiamos-usar-pandas-para-esto","text":"Los cient\u00edficos de datos se apresuran a se\u00f1alar que bibliotecas como Pandas ya tienen una funci\u00f3n para leer archivos CSV. Esto es cierto y funciona bastante bien. Sin embargo, este no es un curso para aprender Pandas. La lectura de archivos es un problema m\u00e1s general que los detalles espec\u00edficos de los archivos CSV. La raz\u00f3n principal por la que trabajamos con un archivo CSV es que es un formato familiar para la mayor\u00eda de los codificadores y es relativamente f\u00e1cil trabajar con \u00e9l directamente, lo que ilustra muchas caracter\u00edsticas de Python en el proceso. As\u00ed que, sin duda, utiliza Pandas cuando vuelvas a trabajar. Sin embargo, durante el resto de este curso nos quedaremos con la funcionalidad est\u00e1ndar de Python. Contents | Previous (1.5 Lists) | Pr\u00f3ximo (1.7 Functions)","title":"Comentario: \u00bfNo deber\u00edamos usar Pandas para esto?"},{"location":"01_Introduction/07_Functions/","text":"Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2. Trabajar con datos) 1.7 Funciones A medida que sus programas se hagan m\u00e1s grandes, querr\u00e1 organizarse. Esta secci\u00f3n presenta brevemente las funciones y los m\u00f3dulos de la biblioteca est\u00e1ndar de Python. Tambi\u00e9n se presenta el manejo de errores con excepciones. Funciones personalizadas Utilice funciones para el c\u00f3digo que desea reutilizar. Aqu\u00ed hay una definici\u00f3n de funci\u00f3n: def sumcount(n): ''' Returns the sum of the first n integers ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar a una funci\u00f3n. a = sumcount(100) Una funci\u00f3n es una serie de instrucciones que realizan una tarea y devuelven un resultado. La palabra clave return es necesaria para especificar expl\u00edcitamente el valor de retorno de la funci\u00f3n. Funciones de la biblioteca Python viene con una gran biblioteca est\u00e1ndar. Se accede a los m\u00f3dulos de la biblioteca mediante import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Cubriremos bibliotecas y m\u00f3dulos con m\u00e1s detalle m\u00e1s adelante. Errores y excepciones Las funciones informan los errores como excepciones. Una excepci\u00f3n provoca la interrupci\u00f3n de una funci\u00f3n y puede provocar que todo el programa se detenga si no se controla. Pruebe esto en su REPL de Python. >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para fines de depuraci\u00f3n, el mensaje describe qu\u00e9 sucedi\u00f3, d\u00f3nde ocurri\u00f3 el error y un seguimiento que muestra las otras llamadas de funci\u00f3n que llevaron a la falla. Captura y manejo de excepciones Se pueden detectar y gestionar excepciones. Para capturarlo, utilice la instrucci\u00f3n try - except . for line in file: fields = line.split(',') try: shares = int(fields[1]) except ValueError: print(\"No puede analizarse\", line) ... El nombre ValueError debe coincidir con el tipo de error que est\u00e1s intentando detectar. A menudo es dif\u00edcil saber con antelaci\u00f3n qu\u00e9 tipos de errores podr\u00edan producirse en funci\u00f3n de la operaci\u00f3n que se est\u00e9 realizando. Para bien o para mal, el manejo de excepciones a menudo se agrega despu\u00e9s de que un programa falla inesperadamente (es decir, \"oh, olvidamos detectar ese error. \u00a1Deber\u00edamos manejarlo!\"). Generar excepciones Para generar una excepci\u00f3n, utilice la declaraci\u00f3n raise . raise RuntimeError('Que alboroto') Esto provocar\u00e1 que el programa se cancele con un seguimiento de excepci\u00f3n. A menos que sea detectado por un bloque try-except . bash % python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <module> raise RuntimeError(\"Que alboroto\") RuntimeError: Que alboroto Ejercicios Ejercicio 1.29: Definici\u00f3n de una funci\u00f3n Intente definir una funci\u00f3n simple: >>> def greeting(name): 'Emite un saludo' print('Hola', name) >>> greeting('Guido') Hola Guido >>> greeting('Paula') Hola Paula >>> Si la primera declaraci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n. Intente escribir un comando como help(greeting) para verlo mostrado. Ejercicio 1.30: Convertir un script en una funci\u00f3n Tome el c\u00f3digo que escribi\u00f3 para el programa pcost.py en el [Ejercicio 1.27] y convi\u00e9rtalo en una funci\u00f3n portfolio_cost(filename) . Esta funci\u00f3n toma un nombre de archivo como entrada, lee los datos de la cartera en ese archivo y devuelve el costo total de la cartera como un n\u00famero tipo float . Para utilizar su funci\u00f3n, cambie su programa para que se parezca a esto: def portfolio_cost(filename): ... # Su c\u00f3digo aqu\u00ed ... cost = portfolio_cost('Data/portfolio.csv') print('Costo Total:', cost) Cuando ejecute su programa, deber\u00eda ver el mismo resultado que antes. Despu\u00e9s de ejecutar su programa, tambi\u00e9n puede llamar a su funci\u00f3n de forma interactiva escribiendo lo siguiente: bash % python3 -i pcost.py Esto le permitir\u00e1 llamar a su funci\u00f3n desde el modo interactivo. >>> portfolio_cost('Data/portfolio.csv') 44671.15 >>> Poder experimentar con su c\u00f3digo en modo interactivo es \u00fatil para realizar pruebas y depuraciones. Ejercicio 1.31: Manejo de errores \u00bfQu\u00e9 sucede si prueba su funci\u00f3n en un archivo con algunos campos faltantes? >>> portfolio_cost('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"pcost.py\", line 11, in portfolio_cost nshares = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> En este punto, usted se enfrenta a una decisi\u00f3n. Para que el programa funcione, puede desinfectar el archivo de entrada original eliminando las l\u00edneas defectuosas o puede modificar su c\u00f3digo para manejar las l\u00edneas defectuosas de alguna manera. Modifique el programa pcost.py para capturar la excepci\u00f3n, imprimir un mensaje de advertencia y continuar procesando el resto del archivo. Ejercicio 1.32: Uso de una funci\u00f3n de biblioteca Python viene con una gran biblioteca est\u00e1ndar de funciones \u00fatiles. Una biblioteca que podr\u00eda ser \u00fatil aqu\u00ed es el m\u00f3dulo csv . Debes usarlo siempre que tengas que trabajar con archivos de datos CSV. He aqu\u00ed un ejemplo de c\u00f3mo funciona: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> for row in rows: print(row) ['AA', '100', '32.20'] ['IBM', '50', '91.10'] ['CAT', '150', '83.44'] ['MSFT', '200', '51.23'] ['GE', '95', '40.37'] ['MSFT', '50', '65.10'] ['IBM', '100', '70.44'] >>> f.close() >>> Una de las ventajas del m\u00f3dulo csv es que se ocupa de una variedad de detalles de bajo nivel, como citas y divisi\u00f3n adecuada de comas. En el resultado anterior, notar\u00e1s que se han eliminado las comillas dobles de los nombres en la primera columna. Modifique su programa pcost.py para que utilice el m\u00f3dulo csv para analizar e intente ejecutar ejemplos anteriores. Ejercicio 1.33: Lectura desde la l\u00ednea de comandos En el programa pcost.py , el nombre del archivo de entrada se ha incorporado al c\u00f3digo: # pcost.py def portfolio_cost(filename): ... # Tu c\u00f3digo aqu\u00ed ... cost = portfolio_cost('Data/portfolio.csv') print('Costo Total:', cost) Eso est\u00e1 bien para aprender y probar, pero en un programa real probablemente no lo har\u00edas. En lugar de ello, puedes pasar el nombre del archivo como argumento a un script. Intente cambiar la parte inferior del programa de la siguiente manera: # pcost.py import sys def portfolio_cost(filename): ... # Tu c\u00f3digo aqu\u00ed ... if len(sys.argv) == 2: filename = sys.argv[1] else: filename = 'Data/portfolio.csv' cost = portfolio_cost(filename) print('Costo total:', cost) sys.argv es una lista que contiene los argumentos pasados en la l\u00ednea de comando (si los hay). Para ejecutar su programa, necesitar\u00e1 ejecutar Python desde la terminal. Por ejemplo, desde bash en Unix: bash % python3 pcost.py Data/portfolio.csv Costo Total: 44671.15 bash % Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2. Trabajar con datos)","title":"07_Functions"},{"location":"01_Introduction/07_Functions/#17-funciones","text":"A medida que sus programas se hagan m\u00e1s grandes, querr\u00e1 organizarse. Esta secci\u00f3n presenta brevemente las funciones y los m\u00f3dulos de la biblioteca est\u00e1ndar de Python. Tambi\u00e9n se presenta el manejo de errores con excepciones.","title":"1.7 Funciones"},{"location":"01_Introduction/07_Functions/#funciones-personalizadas","text":"Utilice funciones para el c\u00f3digo que desea reutilizar. Aqu\u00ed hay una definici\u00f3n de funci\u00f3n: def sumcount(n): ''' Returns the sum of the first n integers ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar a una funci\u00f3n. a = sumcount(100) Una funci\u00f3n es una serie de instrucciones que realizan una tarea y devuelven un resultado. La palabra clave return es necesaria para especificar expl\u00edcitamente el valor de retorno de la funci\u00f3n.","title":"Funciones personalizadas"},{"location":"01_Introduction/07_Functions/#funciones-de-la-biblioteca","text":"Python viene con una gran biblioteca est\u00e1ndar. Se accede a los m\u00f3dulos de la biblioteca mediante import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Cubriremos bibliotecas y m\u00f3dulos con m\u00e1s detalle m\u00e1s adelante.","title":"Funciones de la biblioteca"},{"location":"01_Introduction/07_Functions/#errores-y-excepciones","text":"Las funciones informan los errores como excepciones. Una excepci\u00f3n provoca la interrupci\u00f3n de una funci\u00f3n y puede provocar que todo el programa se detenga si no se controla. Pruebe esto en su REPL de Python. >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para fines de depuraci\u00f3n, el mensaje describe qu\u00e9 sucedi\u00f3, d\u00f3nde ocurri\u00f3 el error y un seguimiento que muestra las otras llamadas de funci\u00f3n que llevaron a la falla.","title":"Errores y excepciones"},{"location":"01_Introduction/07_Functions/#captura-y-manejo-de-excepciones","text":"Se pueden detectar y gestionar excepciones. Para capturarlo, utilice la instrucci\u00f3n try - except . for line in file: fields = line.split(',') try: shares = int(fields[1]) except ValueError: print(\"No puede analizarse\", line) ... El nombre ValueError debe coincidir con el tipo de error que est\u00e1s intentando detectar. A menudo es dif\u00edcil saber con antelaci\u00f3n qu\u00e9 tipos de errores podr\u00edan producirse en funci\u00f3n de la operaci\u00f3n que se est\u00e9 realizando. Para bien o para mal, el manejo de excepciones a menudo se agrega despu\u00e9s de que un programa falla inesperadamente (es decir, \"oh, olvidamos detectar ese error. \u00a1Deber\u00edamos manejarlo!\").","title":"Captura y manejo de excepciones"},{"location":"01_Introduction/07_Functions/#generar-excepciones","text":"Para generar una excepci\u00f3n, utilice la declaraci\u00f3n raise . raise RuntimeError('Que alboroto') Esto provocar\u00e1 que el programa se cancele con un seguimiento de excepci\u00f3n. A menos que sea detectado por un bloque try-except . bash % python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <module> raise RuntimeError(\"Que alboroto\") RuntimeError: Que alboroto","title":"Generar excepciones"},{"location":"01_Introduction/07_Functions/#ejercicios","text":"","title":"Ejercicios"},{"location":"01_Introduction/07_Functions/#ejercicio-129-definicion-de-una-funcion","text":"Intente definir una funci\u00f3n simple: >>> def greeting(name): 'Emite un saludo' print('Hola', name) >>> greeting('Guido') Hola Guido >>> greeting('Paula') Hola Paula >>> Si la primera declaraci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n. Intente escribir un comando como help(greeting) para verlo mostrado.","title":"Ejercicio 1.29: Definici\u00f3n de una funci\u00f3n"},{"location":"01_Introduction/07_Functions/#ejercicio-130-convertir-un-script-en-una-funcion","text":"Tome el c\u00f3digo que escribi\u00f3 para el programa pcost.py en el [Ejercicio 1.27] y convi\u00e9rtalo en una funci\u00f3n portfolio_cost(filename) . Esta funci\u00f3n toma un nombre de archivo como entrada, lee los datos de la cartera en ese archivo y devuelve el costo total de la cartera como un n\u00famero tipo float . Para utilizar su funci\u00f3n, cambie su programa para que se parezca a esto: def portfolio_cost(filename): ... # Su c\u00f3digo aqu\u00ed ... cost = portfolio_cost('Data/portfolio.csv') print('Costo Total:', cost) Cuando ejecute su programa, deber\u00eda ver el mismo resultado que antes. Despu\u00e9s de ejecutar su programa, tambi\u00e9n puede llamar a su funci\u00f3n de forma interactiva escribiendo lo siguiente: bash % python3 -i pcost.py Esto le permitir\u00e1 llamar a su funci\u00f3n desde el modo interactivo. >>> portfolio_cost('Data/portfolio.csv') 44671.15 >>> Poder experimentar con su c\u00f3digo en modo interactivo es \u00fatil para realizar pruebas y depuraciones.","title":"Ejercicio 1.30: Convertir un script en una funci\u00f3n"},{"location":"01_Introduction/07_Functions/#ejercicio-131-manejo-de-errores","text":"\u00bfQu\u00e9 sucede si prueba su funci\u00f3n en un archivo con algunos campos faltantes? >>> portfolio_cost('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"pcost.py\", line 11, in portfolio_cost nshares = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> En este punto, usted se enfrenta a una decisi\u00f3n. Para que el programa funcione, puede desinfectar el archivo de entrada original eliminando las l\u00edneas defectuosas o puede modificar su c\u00f3digo para manejar las l\u00edneas defectuosas de alguna manera. Modifique el programa pcost.py para capturar la excepci\u00f3n, imprimir un mensaje de advertencia y continuar procesando el resto del archivo.","title":"Ejercicio 1.31: Manejo de errores"},{"location":"01_Introduction/07_Functions/#ejercicio-132-uso-de-una-funcion-de-biblioteca","text":"Python viene con una gran biblioteca est\u00e1ndar de funciones \u00fatiles. Una biblioteca que podr\u00eda ser \u00fatil aqu\u00ed es el m\u00f3dulo csv . Debes usarlo siempre que tengas que trabajar con archivos de datos CSV. He aqu\u00ed un ejemplo de c\u00f3mo funciona: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> for row in rows: print(row) ['AA', '100', '32.20'] ['IBM', '50', '91.10'] ['CAT', '150', '83.44'] ['MSFT', '200', '51.23'] ['GE', '95', '40.37'] ['MSFT', '50', '65.10'] ['IBM', '100', '70.44'] >>> f.close() >>> Una de las ventajas del m\u00f3dulo csv es que se ocupa de una variedad de detalles de bajo nivel, como citas y divisi\u00f3n adecuada de comas. En el resultado anterior, notar\u00e1s que se han eliminado las comillas dobles de los nombres en la primera columna. Modifique su programa pcost.py para que utilice el m\u00f3dulo csv para analizar e intente ejecutar ejemplos anteriores.","title":"Ejercicio 1.32: Uso de una funci\u00f3n de biblioteca"},{"location":"01_Introduction/07_Functions/#ejercicio-133-lectura-desde-la-linea-de-comandos","text":"En el programa pcost.py , el nombre del archivo de entrada se ha incorporado al c\u00f3digo: # pcost.py def portfolio_cost(filename): ... # Tu c\u00f3digo aqu\u00ed ... cost = portfolio_cost('Data/portfolio.csv') print('Costo Total:', cost) Eso est\u00e1 bien para aprender y probar, pero en un programa real probablemente no lo har\u00edas. En lugar de ello, puedes pasar el nombre del archivo como argumento a un script. Intente cambiar la parte inferior del programa de la siguiente manera: # pcost.py import sys def portfolio_cost(filename): ... # Tu c\u00f3digo aqu\u00ed ... if len(sys.argv) == 2: filename = sys.argv[1] else: filename = 'Data/portfolio.csv' cost = portfolio_cost(filename) print('Costo total:', cost) sys.argv es una lista que contiene los argumentos pasados en la l\u00ednea de comando (si los hay). Para ejecutar su programa, necesitar\u00e1 ejecutar Python desde la terminal. Por ejemplo, desde bash en Unix: bash % python3 pcost.py Data/portfolio.csv Costo Total: 44671.15 bash % Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2. Trabajar con datos)","title":"Ejercicio 1.33: Lectura desde la l\u00ednea de comandos"},{"location":"02_Working_with_data/00_Overview/","text":"Contenido | Anterior (1. Introducci\u00f3n a Python) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa) 2. Trabajar con datos Para escribir programas \u00fatiles, es necesario saber trabajar con datos. Esta secci\u00f3n presenta las estructuras de datos centrales de Python: tuplas, listas, conjuntos y diccionarios, y analiza los lenguajes comunes de manejo de datos. La \u00faltima parte de esta secci\u00f3n profundiza un poco m\u00e1s en el modelo de objetos subyacente de Python. 2.1 Tipos y estructuras de datos 2.2 Contenedores 2.3 Salida con formato 2.4 Secuencias 2.5 M\u00f3dulo Collections 2.6 Listas por comprensi\u00f3n 2.7 Objetos Contenido | Anterior (1. Introducci\u00f3n a Python) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa)","title":"00_Overview"},{"location":"02_Working_with_data/00_Overview/#2-trabajar-con-datos","text":"Para escribir programas \u00fatiles, es necesario saber trabajar con datos. Esta secci\u00f3n presenta las estructuras de datos centrales de Python: tuplas, listas, conjuntos y diccionarios, y analiza los lenguajes comunes de manejo de datos. La \u00faltima parte de esta secci\u00f3n profundiza un poco m\u00e1s en el modelo de objetos subyacente de Python. 2.1 Tipos y estructuras de datos 2.2 Contenedores 2.3 Salida con formato 2.4 Secuencias 2.5 M\u00f3dulo Collections 2.6 Listas por comprensi\u00f3n 2.7 Objetos Contenido | Anterior (1. Introducci\u00f3n a Python) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa)","title":"2. Trabajar con datos"},{"location":"02_Working_with_data/01_Datatypes/","text":"Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2.2 Contenedores) 2.1 Tipos y estructuras de datos Esta secci\u00f3n presenta estructuras de datos en forma de tuplas y diccionarios. Tipos de datos primitivos Python tiene algunos tipos de datos primitivos: N\u00fameros enteros int N\u00fameros de punto flotante float Strings (texto) str Aprendimos sobre esto en la introducci\u00f3n. Tipo None email_address = None None se utiliza a menudo como marcador de posici\u00f3n para valores opcionales o faltantes. Se eval\u00faa como False en condicionales. if email_address: send_email(email_address, msg) Estructuras de datos Los programas reales tienen datos m\u00e1s complejos. Por ejemplo, informaci\u00f3n sobre una tenencia de acciones: 100 shares of GOOG at $490.10 Este es un \"objeto\" con tres partes: Nombre o s\u00edmbolo de la acci\u00f3n (\"GOOG\", un string) N\u00famero de acciones (100, un entero) Precio (490.10 por acci\u00f3n, un flotante) Tuplas Una tupla es una colecci\u00f3n de valores agrupados. Ejemplo: s = ('GOOG', 100, 490.1) A veces se omite el () en la sintaxis. s = 'GOOG', 100, 490.1 Casos especiales (tupla-0, tupla-1). t = () # Una tupla vac\u00eda w = ('GOOG', ) # Una tupla de 1 elemento Las tuplas se utilizan a menudo para representar registros o estructuras simples . Por lo general, se trata de un \u00fanico objeto formado por m\u00faltiples partes. Una buena analog\u00eda: Una tupla es como una sola fila en una tabla de base de datos. Los contenidos de las tuplas est\u00e1n ordenados (como una matriz). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Sin embargo, el contenido no se puede modificar. >>> s[1] = 75 TypeError: 'tuple' object does not support item assignment Sin embargo, puedes crear una nueva tupla basada en una tupla actual. ``` python s = (s[0], 75, s[2]) Empaquetado de tuplas Las tuplas tratan m\u00e1s bien de agrupar elementos relacionados en una sola entidad . s = ('GOOG', 100, 490.1) La tupla es luego f\u00e1cil de pasar a otras partes de un programa como un \u00fanico objeto. Desempaquetado de tuplas Para utilizar la tupla en otro lugar, puedes desempaquetar sus partes en variables. name, shares, price = s print('Cost', shares * price) El n\u00famero de variables de la izquierda en principio deber\u00eda coincidir con la estructura de la tupla. name, shares = s # ERROR Traceback (most recent call last): File \"<python-input-1>\", line 1, in <module> name, shares = s # ERROR ^^^^^^^^^^^^ ValueError: too many values to unpack (expected 2) Pero podr\u00eda hacer algo como esto tambi\u00e9n: name, *_ = s print(name) # 'GOOG' o incluso esto: *_ , price = s print(price) # 490.1 En ambos casos *_ completa las variables faltantes. Incluir m\u00e1s asterisco en el lado izquierdo de la asignaci\u00f3n provocar\u00e1 un SyntaxError: multiple starred expressions in assignment Tuplas vs. Listas Las tuplas parecen listas de solo lectura. Sin embargo, las tuplas se utilizan con mayor frecuencia para un \u00fanico elemento que consta de varias partes. Las listas suelen ser una colecci\u00f3n de elementos distintos, normalmente todos del mismo tipo. record = ('GOOG', 100, 490.1) # Una tupla que representa un registro en un portafolio de inversi\u00f3n symbols = [ 'GOOG', 'AAPL', 'IBM' ] # Una lista que representa tres s\u00edmbolos burs\u00e1tiles Diccionarios Un diccionario es una asignaci\u00f3n de claves a valores. A veces tambi\u00e9n se le llama tabla hash o matriz asociativa. Las claves sirven como \u00edndices para acceder a los valores. s = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } Operaciones comunes Para obtener valores de un diccionario utilice los nombres de clave. >>> print(s['name'], s['shares']) GOOG 100 >>> s['price'] 490.10 >>> Para agregar o modificar valores se asignan utilizando los nombres de las teclas. >>> s['shares'] = 75 >>> s['date'] = '6/6/2007' >>> Para eliminar un valor utilice la instrucci\u00f3n del . >>> del s['date'] >>> \u00bfPor qu\u00e9 diccionarios? Los diccionarios son \u00fatiles cuando hay muchos valores diferentes y esos valores pueden modificarse o manipularse. Los diccionarios hacen que su c\u00f3digo sea m\u00e1s legible. s['precio'] # en lugar de es[2] Ejercicios En los \u00faltimos ejercicios, escribi\u00f3 un programa que lee un archivo de datos Data/portfolio.csv . Usando el m\u00f3dulo csv , es f\u00e1cil leer el archivo fila por fila. >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> next(rows) ['name', 'shares', 'price'] >>> row = next(rows) >>> row ['AA', '100', '32.20'] f.close() >>> Aunque leer el archivo es f\u00e1cil, a menudo deseamos hacer m\u00e1s con los datos que leerlos. Por ejemplo, quiz\u00e1s desee almacenarlos y comenzar a realizar algunos c\u00e1lculos en ellos. Desafortunadamente, una \"fila\" de datos sin procesar no le brinda suficiente informaci\u00f3n con la que trabajar. Por ejemplo, ni siquiera un c\u00e1lculo matem\u00e1tico simple funciona: >>> row = ['AA', '100', '32.20'] >>> cost = row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Para hacer m\u00e1s, normalmente desear\u00e1s interpretar los datos sin procesar de alguna manera y convertirlos en un tipo de objeto m\u00e1s \u00fatil para poder trabajar con ellos m\u00e1s adelante. Dos opciones simples son tuplas o diccionarios. Ejercicio 2.1: Tuplas En el modo interactivo, cree la siguiente tupla que representa la fila anterior, pero con las columnas num\u00e9ricas convertidas en n\u00fameros adecuados: >>> t = (row[0], int(row[1]), float(row[2])) >>> t ('AA', 100, 32.2) >>> Con esto, ahora puedes calcular el costo total multiplicando las acciones y el precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfLas matem\u00e1ticas est\u00e1n rotas en Python? \u00bfCu\u00e1l es el problema con la respuesta 3220.0000000000005? Esto es un dispositivo del hardware de punto flotante de su computadora que solo puede representar con precisi\u00f3n decimales en base 2, no en base 10. Incluso en c\u00e1lculos sencillos que involucran decimales de base 10 se introducen peque\u00f1os errores. Esto es normal, aunque quiz\u00e1 resulte un poco sorprendente si no lo has visto antes. Esto sucede en todos los lenguajes de programaci\u00f3n que utilizan decimales de punto flotante, pero a menudo queda oculto al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de solo lectura. Verifique esto intentando cambiar el n\u00famero de acciones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no puedes cambiar el contenido de una tupla, siempre puedes crear una tupla completamente nueva que reemplace a la anterior. >>> t = (t[0], 75, t[2]) >>> t ('AA', 75, 32.2) >>> Cada vez que se reasigna un nombre de variable existente como \u00e9ste, se descarta el valor anterior. Aunque la tarea anterior puede parecer que est\u00e1s modificando la tupla, en realidad est\u00e1s creando una nueva tupla y descartando la anterior. Las tuplas se utilizan a menudo para empaquetar y desempaquetar valores en variables. Pruebe lo siguiente: >>> name, shares, price = t >>> name 'AA' >>> shares 75 >>> price 32.2 >>> Tome las variables anteriores y vuelva a empaquetarlas en una tupla >>> t = (name, 2*shares, price) >>> t ('AA', 150, 32.2) >>> Ejercicio 2.2: Diccionarios como estructura de datos Una alternativa a una tupla es crear un diccionario. >>> d = { 'name' : row[0], 'shares' : int(row[1]), 'price' : float(row[2]) } >>> d {'name': 'AA', 'shares': 100, 'price': 32.2 } >>> Calcular el costo total de esta tenencia: >>> cost = d['shares'] * d['price'] >>> cost 3220.0000000000005 >>> Compare este ejemplo con el mismo c\u00e1lculo que involucra tuplas mencionado anteriormente. Cambie el n\u00famero de acciones a 75. >>> d['shares'] = 75 >>> d {'name': 'AA', 'shares': 75, 'price': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. A\u00f1ade algunos atributos: >>> d['date'] = (6, 11, 2007) >>> d['account'] = 12345 >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345} >>> Ejercicio 2.3: Algunas operaciones adicionales del diccionario Si conviertes un diccionario en una lista, obtendr\u00e1s todas sus claves: >>> list(d) ['name', 'shares', 'price', 'date', 'account'] >>> De manera similar, si utiliza la declaraci\u00f3n for para iterar sobre un diccionario, obtendr\u00e1 las claves: >>> for k in d: print('k =', k) k = name k = shares k = price k = date k = account >>> Pruebe esta variante que realiza una b\u00fasqueda al mismo tiempo: >>> for k in d: print(k, '=', d[k]) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) account = 12345 >>> Tambi\u00e9n puedes obtener todas las claves utilizando el m\u00e9todo keys() : >>> keys = d.keys() >>> keys dict_keys(['name', 'shares', 'price', 'date', 'account']) >>> keys() es un poco inusual ya que devuelve un objeto dict_keys especial. Esta es una superposici\u00f3n sobre el diccionario original que siempre le brinda las claves actuales, incluso si el diccionario cambia. Por ejemplo, prueba esto: >>> del d['account'] >>> keys dict_keys(['name', 'shares', 'price', 'date']) >>> Tenga en cuenta cuidadosamente que la 'account' desapareci\u00f3 de keys aunque no volvi\u00f3 a llamar a d.keys() . Una forma m\u00e1s elegante de trabajar con claves y valores juntos es utilizar el m\u00e9todo items() . Esto le proporciona tuplas (clave, valor) : >>> items = d.items() >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> for k, v in items: print(k, '=', v) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) >>> Si tiene tuplas como items , puede crear un diccionario usando la funci\u00f3n dict() . Pru\u00e9balo: >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> d = dict(items) >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)} >>> Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2.2 Contenedores)","title":"01_Datatypes"},{"location":"02_Working_with_data/01_Datatypes/#21-tipos-y-estructuras-de-datos","text":"Esta secci\u00f3n presenta estructuras de datos en forma de tuplas y diccionarios.","title":"2.1 Tipos y estructuras de datos"},{"location":"02_Working_with_data/01_Datatypes/#tipos-de-datos-primitivos","text":"Python tiene algunos tipos de datos primitivos: N\u00fameros enteros int N\u00fameros de punto flotante float Strings (texto) str Aprendimos sobre esto en la introducci\u00f3n.","title":"Tipos de datos primitivos"},{"location":"02_Working_with_data/01_Datatypes/#tipo-none","text":"email_address = None None se utiliza a menudo como marcador de posici\u00f3n para valores opcionales o faltantes. Se eval\u00faa como False en condicionales. if email_address: send_email(email_address, msg)","title":"Tipo None"},{"location":"02_Working_with_data/01_Datatypes/#estructuras-de-datos","text":"Los programas reales tienen datos m\u00e1s complejos. Por ejemplo, informaci\u00f3n sobre una tenencia de acciones: 100 shares of GOOG at $490.10 Este es un \"objeto\" con tres partes: Nombre o s\u00edmbolo de la acci\u00f3n (\"GOOG\", un string) N\u00famero de acciones (100, un entero) Precio (490.10 por acci\u00f3n, un flotante)","title":"Estructuras de datos"},{"location":"02_Working_with_data/01_Datatypes/#tuplas","text":"Una tupla es una colecci\u00f3n de valores agrupados. Ejemplo: s = ('GOOG', 100, 490.1) A veces se omite el () en la sintaxis. s = 'GOOG', 100, 490.1 Casos especiales (tupla-0, tupla-1). t = () # Una tupla vac\u00eda w = ('GOOG', ) # Una tupla de 1 elemento Las tuplas se utilizan a menudo para representar registros o estructuras simples . Por lo general, se trata de un \u00fanico objeto formado por m\u00faltiples partes. Una buena analog\u00eda: Una tupla es como una sola fila en una tabla de base de datos. Los contenidos de las tuplas est\u00e1n ordenados (como una matriz). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Sin embargo, el contenido no se puede modificar. >>> s[1] = 75 TypeError: 'tuple' object does not support item assignment Sin embargo, puedes crear una nueva tupla basada en una tupla actual. ``` python s = (s[0], 75, s[2])","title":"Tuplas"},{"location":"02_Working_with_data/01_Datatypes/#empaquetado-de-tuplas","text":"Las tuplas tratan m\u00e1s bien de agrupar elementos relacionados en una sola entidad . s = ('GOOG', 100, 490.1) La tupla es luego f\u00e1cil de pasar a otras partes de un programa como un \u00fanico objeto.","title":"Empaquetado de tuplas"},{"location":"02_Working_with_data/01_Datatypes/#desempaquetado-de-tuplas","text":"Para utilizar la tupla en otro lugar, puedes desempaquetar sus partes en variables. name, shares, price = s print('Cost', shares * price) El n\u00famero de variables de la izquierda en principio deber\u00eda coincidir con la estructura de la tupla. name, shares = s # ERROR Traceback (most recent call last): File \"<python-input-1>\", line 1, in <module> name, shares = s # ERROR ^^^^^^^^^^^^ ValueError: too many values to unpack (expected 2) Pero podr\u00eda hacer algo como esto tambi\u00e9n: name, *_ = s print(name) # 'GOOG' o incluso esto: *_ , price = s print(price) # 490.1 En ambos casos *_ completa las variables faltantes. Incluir m\u00e1s asterisco en el lado izquierdo de la asignaci\u00f3n provocar\u00e1 un SyntaxError: multiple starred expressions in assignment","title":"Desempaquetado de tuplas"},{"location":"02_Working_with_data/01_Datatypes/#tuplas-vs-listas","text":"Las tuplas parecen listas de solo lectura. Sin embargo, las tuplas se utilizan con mayor frecuencia para un \u00fanico elemento que consta de varias partes. Las listas suelen ser una colecci\u00f3n de elementos distintos, normalmente todos del mismo tipo. record = ('GOOG', 100, 490.1) # Una tupla que representa un registro en un portafolio de inversi\u00f3n symbols = [ 'GOOG', 'AAPL', 'IBM' ] # Una lista que representa tres s\u00edmbolos burs\u00e1tiles","title":"Tuplas vs. Listas"},{"location":"02_Working_with_data/01_Datatypes/#diccionarios","text":"Un diccionario es una asignaci\u00f3n de claves a valores. A veces tambi\u00e9n se le llama tabla hash o matriz asociativa. Las claves sirven como \u00edndices para acceder a los valores. s = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 }","title":"Diccionarios"},{"location":"02_Working_with_data/01_Datatypes/#operaciones-comunes","text":"Para obtener valores de un diccionario utilice los nombres de clave. >>> print(s['name'], s['shares']) GOOG 100 >>> s['price'] 490.10 >>> Para agregar o modificar valores se asignan utilizando los nombres de las teclas. >>> s['shares'] = 75 >>> s['date'] = '6/6/2007' >>> Para eliminar un valor utilice la instrucci\u00f3n del . >>> del s['date'] >>>","title":"Operaciones comunes"},{"location":"02_Working_with_data/01_Datatypes/#por-que-diccionarios","text":"Los diccionarios son \u00fatiles cuando hay muchos valores diferentes y esos valores pueden modificarse o manipularse. Los diccionarios hacen que su c\u00f3digo sea m\u00e1s legible. s['precio'] # en lugar de es[2]","title":"\u00bfPor qu\u00e9 diccionarios?"},{"location":"02_Working_with_data/01_Datatypes/#ejercicios","text":"En los \u00faltimos ejercicios, escribi\u00f3 un programa que lee un archivo de datos Data/portfolio.csv . Usando el m\u00f3dulo csv , es f\u00e1cil leer el archivo fila por fila. >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> next(rows) ['name', 'shares', 'price'] >>> row = next(rows) >>> row ['AA', '100', '32.20'] f.close() >>> Aunque leer el archivo es f\u00e1cil, a menudo deseamos hacer m\u00e1s con los datos que leerlos. Por ejemplo, quiz\u00e1s desee almacenarlos y comenzar a realizar algunos c\u00e1lculos en ellos. Desafortunadamente, una \"fila\" de datos sin procesar no le brinda suficiente informaci\u00f3n con la que trabajar. Por ejemplo, ni siquiera un c\u00e1lculo matem\u00e1tico simple funciona: >>> row = ['AA', '100', '32.20'] >>> cost = row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Para hacer m\u00e1s, normalmente desear\u00e1s interpretar los datos sin procesar de alguna manera y convertirlos en un tipo de objeto m\u00e1s \u00fatil para poder trabajar con ellos m\u00e1s adelante. Dos opciones simples son tuplas o diccionarios.","title":"Ejercicios"},{"location":"02_Working_with_data/01_Datatypes/#ejercicio-21-tuplas","text":"En el modo interactivo, cree la siguiente tupla que representa la fila anterior, pero con las columnas num\u00e9ricas convertidas en n\u00fameros adecuados: >>> t = (row[0], int(row[1]), float(row[2])) >>> t ('AA', 100, 32.2) >>> Con esto, ahora puedes calcular el costo total multiplicando las acciones y el precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfLas matem\u00e1ticas est\u00e1n rotas en Python? \u00bfCu\u00e1l es el problema con la respuesta 3220.0000000000005? Esto es un dispositivo del hardware de punto flotante de su computadora que solo puede representar con precisi\u00f3n decimales en base 2, no en base 10. Incluso en c\u00e1lculos sencillos que involucran decimales de base 10 se introducen peque\u00f1os errores. Esto es normal, aunque quiz\u00e1 resulte un poco sorprendente si no lo has visto antes. Esto sucede en todos los lenguajes de programaci\u00f3n que utilizan decimales de punto flotante, pero a menudo queda oculto al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de solo lectura. Verifique esto intentando cambiar el n\u00famero de acciones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no puedes cambiar el contenido de una tupla, siempre puedes crear una tupla completamente nueva que reemplace a la anterior. >>> t = (t[0], 75, t[2]) >>> t ('AA', 75, 32.2) >>> Cada vez que se reasigna un nombre de variable existente como \u00e9ste, se descarta el valor anterior. Aunque la tarea anterior puede parecer que est\u00e1s modificando la tupla, en realidad est\u00e1s creando una nueva tupla y descartando la anterior. Las tuplas se utilizan a menudo para empaquetar y desempaquetar valores en variables. Pruebe lo siguiente: >>> name, shares, price = t >>> name 'AA' >>> shares 75 >>> price 32.2 >>> Tome las variables anteriores y vuelva a empaquetarlas en una tupla >>> t = (name, 2*shares, price) >>> t ('AA', 150, 32.2) >>>","title":"Ejercicio 2.1: Tuplas"},{"location":"02_Working_with_data/01_Datatypes/#ejercicio-22-diccionarios-como-estructura-de-datos","text":"Una alternativa a una tupla es crear un diccionario. >>> d = { 'name' : row[0], 'shares' : int(row[1]), 'price' : float(row[2]) } >>> d {'name': 'AA', 'shares': 100, 'price': 32.2 } >>> Calcular el costo total de esta tenencia: >>> cost = d['shares'] * d['price'] >>> cost 3220.0000000000005 >>> Compare este ejemplo con el mismo c\u00e1lculo que involucra tuplas mencionado anteriormente. Cambie el n\u00famero de acciones a 75. >>> d['shares'] = 75 >>> d {'name': 'AA', 'shares': 75, 'price': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. A\u00f1ade algunos atributos: >>> d['date'] = (6, 11, 2007) >>> d['account'] = 12345 >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345} >>>","title":"Ejercicio 2.2: Diccionarios como estructura de datos"},{"location":"02_Working_with_data/01_Datatypes/#ejercicio-23-algunas-operaciones-adicionales-del-diccionario","text":"Si conviertes un diccionario en una lista, obtendr\u00e1s todas sus claves: >>> list(d) ['name', 'shares', 'price', 'date', 'account'] >>> De manera similar, si utiliza la declaraci\u00f3n for para iterar sobre un diccionario, obtendr\u00e1 las claves: >>> for k in d: print('k =', k) k = name k = shares k = price k = date k = account >>> Pruebe esta variante que realiza una b\u00fasqueda al mismo tiempo: >>> for k in d: print(k, '=', d[k]) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) account = 12345 >>> Tambi\u00e9n puedes obtener todas las claves utilizando el m\u00e9todo keys() : >>> keys = d.keys() >>> keys dict_keys(['name', 'shares', 'price', 'date', 'account']) >>> keys() es un poco inusual ya que devuelve un objeto dict_keys especial. Esta es una superposici\u00f3n sobre el diccionario original que siempre le brinda las claves actuales, incluso si el diccionario cambia. Por ejemplo, prueba esto: >>> del d['account'] >>> keys dict_keys(['name', 'shares', 'price', 'date']) >>> Tenga en cuenta cuidadosamente que la 'account' desapareci\u00f3 de keys aunque no volvi\u00f3 a llamar a d.keys() . Una forma m\u00e1s elegante de trabajar con claves y valores juntos es utilizar el m\u00e9todo items() . Esto le proporciona tuplas (clave, valor) : >>> items = d.items() >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> for k, v in items: print(k, '=', v) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) >>> Si tiene tuplas como items , puede crear un diccionario usando la funci\u00f3n dict() . Pru\u00e9balo: >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> d = dict(items) >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)} >>> Contenido | Anterior (1.6 Archivos) | Pr\u00f3ximo (2.2 Contenedores)","title":"Ejercicio 2.3: Algunas operaciones adicionales del diccionario"},{"location":"02_Working_with_data/02_Containers/","text":"Contenido | Anterior (2.1 Tipos de datos) | Pr\u00f3ximo (2.3 Formato) 2.2 Contenedores En esta secci\u00f3n se tratan listas, diccionarios y sets (conjuntos). Descripci\u00f3n general Los programas a menudo tienen que trabajar con muchos objetos. Una cartera de acciones Una tabla de precios de acciones Hay tres opciones principales para utilizar. Listas. Datos ordenados. Diccionarios. Datos desordenados. Sets. Colecci\u00f3n desordenada de elementos \u00fanicos. Listas como contenedor Utilice una lista cuando el orden de los datos sea importante. Recuerde que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.3), ('CAT', 150, 83.44) ] portfolio[0] # ('GOOG', 100, 490.1) portfolio[2] # ('CAT', 150, 83.44) Construcci\u00f3n de listas Construyendo una lista desde cero. records = [] # Lista vac\u00eda inicial # Use .append() para adicionar m\u00e0s elementos records.append(('GOOG', 100, 490.10)) records.append(('IBM', 50, 91.3)) ... Un ejemplo al leer registros de un archivo. records = [] # Initial empty list with open('Data/portfolio.csv', 'rt') as f: next(f) # salta los encabezados for line in f: row = line.split(',') records.append((row[0], int(row[1]), float(row[2]))) Diccionarios como contenedor Los diccionarios son \u00fatiles si desea realizar b\u00fasquedas aleatorias r\u00e1pidas (por nombre de clave). Por ejemplo, un diccionario de precios de acciones: prices = { 'GOOG': 513.25, 'CAT': 87.22, 'IBM': 93.37, 'MSFT': 44.12 } A continuaci\u00f3n se muestran algunas b\u00fasquedas sencillas: >>> prices['IBM'] 93.37 >>> prices['GOOG'] 513.25 >>> Construcci\u00f3n de diccionarios Ejemplo de construcci\u00f3n de un diccionario desde cero. prices = {} # Diccionario vac\u00edo inicial # Insertar nuevos elementos prices['GOOG'] = 513.25 prices['CAT'] = 87.22 prices['IBM'] = 93.37 Un ejemplo que completa el dict a partir del contenido de un archivo. prices = {} # Diccionario vac\u00edo inicial with open('Data/prices.csv', 'rt') as f: for line in f: row = line.split(',') prices[row[0]] = float(row[1]) Nota: si prueba esto en el archivo Data/prices.csv , descubrir\u00e1 que casi funciona (hay una l\u00ednea en blanco al final que hace que se bloquee). Necesitar\u00e1s encontrar alguna forma de modificar el c\u00f3digo para tenerlo en cuenta (ver Ejercicio 2.6). B\u00fasquedas en el diccionario Puedes probar la existencia de una clave. if key in d: # YES else: # NO Puede buscar un valor que podr\u00eda no existir y proporcionar un valor predeterminado en caso de que no exista. name = d.get(key, default) Un ejemplo: >>> prices.get('IBM', 0.0) 93.37 >>> prices.get('SCOX', 0.0) 0.0 >>> Teclas compuestas Casi cualquier tipo de valor se puede utilizar como clave de diccionario en Python. Una clave de diccionario debe ser de un tipo que sea inmutable. Por ejemplo, tuplas: holidays = { (1, 1) : 'New Years', (3, 14) : 'Pi day', (9, 13) : \"Programmer's day\", } Luego para acceder: >>> holidays[3, 14] 'Pi day' >>> Ni una lista, ni un set, ni otro diccionario pueden servir como clave de diccionario, porque las listas y los diccionarios son mutables. Set (Conjunto) Los conjuntos son colecciones de elementos \u00fanicos no ordenados. tech_stocks = { 'IBM','AAPL','MSFT' } # Sintaxis alternativa tech_stocks = set(['IBM', 'AAPL', 'MSFT']) Los conjuntos son \u00fatiles para las pruebas de pertenencia. >>> tech_stocks set(['AAPL', 'IBM', 'MSFT']) >>> 'IBM' in tech_stocks True >>> 'FB' in tech_stocks False >>> Los conjuntos tambi\u00e9n son \u00fatiles para la eliminaci\u00f3n de duplicados. names = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO'] unique = set(names) # unique = set(['IBM', 'AAPL','GOOG','YHOO']) Operaciones de conjunto adicionales: unique.add('CAT') # Agregar elemento unique.remove('YHOO') # Remover un elemento s1 = { 'a', 'b', 'c'} s2 = { 'c', 'd' } s1 | s2 # Set union { 'a', 'b', 'c', 'd' } s1 & s2 # Set intersecci\u00f3n { 'c' } s1 - s2 # Set diferencia { 'a', 'b' } Ejercicios En estos ejercicios, comenzar\u00e1 a construir uno de los programas principales utilizados en el resto de este curso. Realice su trabajo en el archivo Work/report.py . Ejercicio 2.4: Una lista de tuplas El archivo Data/portfolio.csv contiene una lista de acciones en una cartera. En el Ejercicio 1.30 , escribi\u00f3 una funci\u00f3n portfolio_cost(filename) que ley\u00f3 este archivo y realiz\u00f3 un c\u00e1lculo simple. Tu c\u00f3digo deber\u00eda verse as\u00ed: # pcost.py import csv def portfolio_cost(filename): '''Calcula el costo total (shares*price) de un archivo de cartera de acciones''' total_cost = 0.0 with open(filename, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: nshares = int(row[1]) price = float(row[2]) total_cost += nshares * price return total_cost Usando este c\u00f3digo como gu\u00eda aproximada, cree un nuevo archivo report.py . En ese archivo, defina una funci\u00f3n read_portfolio(filename) que abra un archivo de cartera determinado y lo lea en una lista de tuplas. Para hacer esto, vas a realizar algunas modificaciones menores al c\u00f3digo anterior. Primero, en lugar de definir total_cost = 0 , crear\u00e1s una variable que inicialmente estar\u00e1 configurada en una lista vac\u00eda. Por ejemplo: portfolio = [] A continuaci\u00f3n, en lugar de sumar el costo, convertir\u00e1 cada fila en una tupla exactamente como lo hizo en el \u00faltimo ejercicio y la agregar\u00e1 a esta lista. Por ejemplo: for row in rows: holding = (row[0], int(row[1]), float(row[2])) portfolio.append(holding) Finalmente, devolver\u00e1 la lista portfolio resultante. Experimente con su funci\u00f3n de forma interactiva (solo un recordatorio de que para hacer esto, primero debe ejecutar el programa report.py en el int\u00e9rprete): Sugerencia: use -i al ejecutar el archivo en la terminal >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23), ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)] >>> >>> portfolio[0] ('AA', 100, 32.2) >>> portfolio[1] ('IBM', 50, 91.1) >>> portfolio[1][1] 50 >>> total = 0.0 >>> for s in portfolio: total += s[1] * s[2] >>> print(total) 44671.15 >>> Esta lista de tuplas que ha creado es muy similar a una matriz 2D. Por ejemplo, puede acceder a una columna y fila espec\u00edficas mediante una b\u00fasqueda como portfolio[fila][columna] , donde fila y columna son n\u00fameros enteros. Dicho esto, tambi\u00e9n puedes reescribir el \u00faltimo bucle for usando una declaraci\u00f3n como esta: >>> total = 0.0 >>> for name, shares, price in portfolio: total += shares*price >>> print(total) 44671.15 >>> Ejercicio 2.5: Lista de diccionarios Tome la funci\u00f3n que escribi\u00f3 en el Ejercicio 2.4 y modif\u00edquela para representar cada acci\u00f3n en la cartera con un diccionario en lugar de una tupla. En este diccionario, utilice los nombres de campo name , shares y prices para representar las diferentes columnas en el archivo de entrada. Experimente con esta nueva funci\u00f3n de la misma manera que lo hizo en el Ejercicio 2.4. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> portfolio[0] {'name': 'AA', 'shares': 100, 'price': 32.2} >>> portfolio[1] {'name': 'IBM', 'shares': 50, 'price': 91.1} >>> portfolio[1]['shares'] 50 >>> total = 0.0 >>> for s in portfolio: total += s['shares']*s['price'] >>> print(total) 44671.15 >>> Aqu\u00ed, notar\u00e1s que se accede a los diferentes campos de cada entrada mediante nombres de clave en lugar de n\u00fameros de columna num\u00e9ricos. A menudo se prefiere esto porque el c\u00f3digo resultante es m\u00e1s f\u00e1cil de leer m\u00e1s adelante. Visualizar diccionarios y listas grandes puede resultar complicado. Para limpiar la salida para la depuraci\u00f3n, considere usar la funci\u00f3n pprint . >>> from pprint import pprint >>> pprint(portfolio) [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] >>> Ejercicio 2.6: Diccionarios como contenedor Un diccionario es una forma \u00fatil de realizar un seguimiento de los elementos, en los que desea buscar elementos utilizando un \u00edndice que no sea un n\u00famero entero. En el modo interactivo de Python, intenta jugar con un diccionario: >>> prices = { } >>> prices['IBM'] = 92.45 >>> prices['MSFT'] = 45.12 >>> prices ... vea el resultado ... >>> prices['IBM'] 92.45 >>> prices['AAPL'] ... vea el resultado ... >>> 'AAPL' in prices False >>> El archivo Data/prices.csv contiene una serie de l\u00edneas con precios de acciones. El archivo se parece a esto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 \"C\",3.72 ... Escriba una funci\u00f3n read_prices(filename) que lea un conjunto de precios como este en un diccionario donde las claves del diccionario son los nombres de las acciones y los valores en el diccionario son los precios de las acciones. Para hacer esto, comience con un diccionario vac\u00edo y comience a insertar valores en \u00e9l tal como lo hizo anteriormente. Sin embargo, ahora est\u00e1s leyendo los valores de un archivo. Utilizaremos esta estructura de datos para buscar r\u00e1pidamente el precio de una acci\u00f3n determinada. Algunos peque\u00f1os consejos que necesitar\u00e1s para esta parte. Primero, aseg\u00farate de utilizar el m\u00f3dulo csv tal como lo hiciste antes; no es necesario reinventar la rueda aqu\u00ed. >>> import csv >>> f = open('Data/prices.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['AA', '9.22'] ['AXP', '24.85'] ... [] >>> La otra peque\u00f1a complicaci\u00f3n es que el archivo Data/prices.csv puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos anterior es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque que su programa muera con una excepci\u00f3n. Utilice las instrucciones try y except para detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos err\u00f3neos con una declaraci\u00f3n if ? Una vez que haya escrito su funci\u00f3n read_prices() , pru\u00e9bela de forma interactiva para asegurarse de que funciona: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>> Ejercicio 2.7: C\u00f3mo saber si puedes jubilarte Conecte todo este trabajo agregando algunas declaraciones adicionales a su programa report.py que calcula la ganancia/p\u00e9rdida. Estas afirmaciones deben tomar la lista de acciones del Ejercicio 2.5 y el diccionario de precios del Ejercicio 2.6 y calcular el valor actual de la cartera junto con la ganancia/p\u00e9rdida. Si ejecuta: bash % python3 -i report.py La salida deber\u00eda verse as\u00ed: Total cost 44671.15 Current value 28686.1 Gain/Loss -15985.050000000003 Contenido | Anterior (2.1 Tipos de datos) | Pr\u00f3ximo (2.3 Salida con formato)","title":"02_Containers"},{"location":"02_Working_with_data/02_Containers/#22-contenedores","text":"En esta secci\u00f3n se tratan listas, diccionarios y sets (conjuntos).","title":"2.2 Contenedores"},{"location":"02_Working_with_data/02_Containers/#descripcion-general","text":"Los programas a menudo tienen que trabajar con muchos objetos. Una cartera de acciones Una tabla de precios de acciones Hay tres opciones principales para utilizar. Listas. Datos ordenados. Diccionarios. Datos desordenados. Sets. Colecci\u00f3n desordenada de elementos \u00fanicos.","title":"Descripci\u00f3n general"},{"location":"02_Working_with_data/02_Containers/#listas-como-contenedor","text":"Utilice una lista cuando el orden de los datos sea importante. Recuerde que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.3), ('CAT', 150, 83.44) ] portfolio[0] # ('GOOG', 100, 490.1) portfolio[2] # ('CAT', 150, 83.44)","title":"Listas como contenedor"},{"location":"02_Working_with_data/02_Containers/#construccion-de-listas","text":"Construyendo una lista desde cero. records = [] # Lista vac\u00eda inicial # Use .append() para adicionar m\u00e0s elementos records.append(('GOOG', 100, 490.10)) records.append(('IBM', 50, 91.3)) ... Un ejemplo al leer registros de un archivo. records = [] # Initial empty list with open('Data/portfolio.csv', 'rt') as f: next(f) # salta los encabezados for line in f: row = line.split(',') records.append((row[0], int(row[1]), float(row[2])))","title":"Construcci\u00f3n de listas"},{"location":"02_Working_with_data/02_Containers/#diccionarios-como-contenedor","text":"Los diccionarios son \u00fatiles si desea realizar b\u00fasquedas aleatorias r\u00e1pidas (por nombre de clave). Por ejemplo, un diccionario de precios de acciones: prices = { 'GOOG': 513.25, 'CAT': 87.22, 'IBM': 93.37, 'MSFT': 44.12 } A continuaci\u00f3n se muestran algunas b\u00fasquedas sencillas: >>> prices['IBM'] 93.37 >>> prices['GOOG'] 513.25 >>>","title":"Diccionarios como contenedor"},{"location":"02_Working_with_data/02_Containers/#construccion-de-diccionarios","text":"Ejemplo de construcci\u00f3n de un diccionario desde cero. prices = {} # Diccionario vac\u00edo inicial # Insertar nuevos elementos prices['GOOG'] = 513.25 prices['CAT'] = 87.22 prices['IBM'] = 93.37 Un ejemplo que completa el dict a partir del contenido de un archivo. prices = {} # Diccionario vac\u00edo inicial with open('Data/prices.csv', 'rt') as f: for line in f: row = line.split(',') prices[row[0]] = float(row[1]) Nota: si prueba esto en el archivo Data/prices.csv , descubrir\u00e1 que casi funciona (hay una l\u00ednea en blanco al final que hace que se bloquee). Necesitar\u00e1s encontrar alguna forma de modificar el c\u00f3digo para tenerlo en cuenta (ver Ejercicio 2.6).","title":"Construcci\u00f3n de diccionarios"},{"location":"02_Working_with_data/02_Containers/#busquedas-en-el-diccionario","text":"Puedes probar la existencia de una clave. if key in d: # YES else: # NO Puede buscar un valor que podr\u00eda no existir y proporcionar un valor predeterminado en caso de que no exista. name = d.get(key, default) Un ejemplo: >>> prices.get('IBM', 0.0) 93.37 >>> prices.get('SCOX', 0.0) 0.0 >>>","title":"B\u00fasquedas en el diccionario"},{"location":"02_Working_with_data/02_Containers/#teclas-compuestas","text":"Casi cualquier tipo de valor se puede utilizar como clave de diccionario en Python. Una clave de diccionario debe ser de un tipo que sea inmutable. Por ejemplo, tuplas: holidays = { (1, 1) : 'New Years', (3, 14) : 'Pi day', (9, 13) : \"Programmer's day\", } Luego para acceder: >>> holidays[3, 14] 'Pi day' >>> Ni una lista, ni un set, ni otro diccionario pueden servir como clave de diccionario, porque las listas y los diccionarios son mutables.","title":"Teclas compuestas"},{"location":"02_Working_with_data/02_Containers/#set-conjunto","text":"Los conjuntos son colecciones de elementos \u00fanicos no ordenados. tech_stocks = { 'IBM','AAPL','MSFT' } # Sintaxis alternativa tech_stocks = set(['IBM', 'AAPL', 'MSFT']) Los conjuntos son \u00fatiles para las pruebas de pertenencia. >>> tech_stocks set(['AAPL', 'IBM', 'MSFT']) >>> 'IBM' in tech_stocks True >>> 'FB' in tech_stocks False >>> Los conjuntos tambi\u00e9n son \u00fatiles para la eliminaci\u00f3n de duplicados. names = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO'] unique = set(names) # unique = set(['IBM', 'AAPL','GOOG','YHOO']) Operaciones de conjunto adicionales: unique.add('CAT') # Agregar elemento unique.remove('YHOO') # Remover un elemento s1 = { 'a', 'b', 'c'} s2 = { 'c', 'd' } s1 | s2 # Set union { 'a', 'b', 'c', 'd' } s1 & s2 # Set intersecci\u00f3n { 'c' } s1 - s2 # Set diferencia { 'a', 'b' }","title":"Set (Conjunto)"},{"location":"02_Working_with_data/02_Containers/#ejercicios","text":"En estos ejercicios, comenzar\u00e1 a construir uno de los programas principales utilizados en el resto de este curso. Realice su trabajo en el archivo Work/report.py .","title":"Ejercicios"},{"location":"02_Working_with_data/02_Containers/#ejercicio-24-una-lista-de-tuplas","text":"El archivo Data/portfolio.csv contiene una lista de acciones en una cartera. En el Ejercicio 1.30 , escribi\u00f3 una funci\u00f3n portfolio_cost(filename) que ley\u00f3 este archivo y realiz\u00f3 un c\u00e1lculo simple. Tu c\u00f3digo deber\u00eda verse as\u00ed: # pcost.py import csv def portfolio_cost(filename): '''Calcula el costo total (shares*price) de un archivo de cartera de acciones''' total_cost = 0.0 with open(filename, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: nshares = int(row[1]) price = float(row[2]) total_cost += nshares * price return total_cost Usando este c\u00f3digo como gu\u00eda aproximada, cree un nuevo archivo report.py . En ese archivo, defina una funci\u00f3n read_portfolio(filename) que abra un archivo de cartera determinado y lo lea en una lista de tuplas. Para hacer esto, vas a realizar algunas modificaciones menores al c\u00f3digo anterior. Primero, en lugar de definir total_cost = 0 , crear\u00e1s una variable que inicialmente estar\u00e1 configurada en una lista vac\u00eda. Por ejemplo: portfolio = [] A continuaci\u00f3n, en lugar de sumar el costo, convertir\u00e1 cada fila en una tupla exactamente como lo hizo en el \u00faltimo ejercicio y la agregar\u00e1 a esta lista. Por ejemplo: for row in rows: holding = (row[0], int(row[1]), float(row[2])) portfolio.append(holding) Finalmente, devolver\u00e1 la lista portfolio resultante. Experimente con su funci\u00f3n de forma interactiva (solo un recordatorio de que para hacer esto, primero debe ejecutar el programa report.py en el int\u00e9rprete): Sugerencia: use -i al ejecutar el archivo en la terminal >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23), ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)] >>> >>> portfolio[0] ('AA', 100, 32.2) >>> portfolio[1] ('IBM', 50, 91.1) >>> portfolio[1][1] 50 >>> total = 0.0 >>> for s in portfolio: total += s[1] * s[2] >>> print(total) 44671.15 >>> Esta lista de tuplas que ha creado es muy similar a una matriz 2D. Por ejemplo, puede acceder a una columna y fila espec\u00edficas mediante una b\u00fasqueda como portfolio[fila][columna] , donde fila y columna son n\u00fameros enteros. Dicho esto, tambi\u00e9n puedes reescribir el \u00faltimo bucle for usando una declaraci\u00f3n como esta: >>> total = 0.0 >>> for name, shares, price in portfolio: total += shares*price >>> print(total) 44671.15 >>>","title":"Ejercicio 2.4: Una lista de tuplas"},{"location":"02_Working_with_data/02_Containers/#ejercicio-25-lista-de-diccionarios","text":"Tome la funci\u00f3n que escribi\u00f3 en el Ejercicio 2.4 y modif\u00edquela para representar cada acci\u00f3n en la cartera con un diccionario en lugar de una tupla. En este diccionario, utilice los nombres de campo name , shares y prices para representar las diferentes columnas en el archivo de entrada. Experimente con esta nueva funci\u00f3n de la misma manera que lo hizo en el Ejercicio 2.4. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> portfolio[0] {'name': 'AA', 'shares': 100, 'price': 32.2} >>> portfolio[1] {'name': 'IBM', 'shares': 50, 'price': 91.1} >>> portfolio[1]['shares'] 50 >>> total = 0.0 >>> for s in portfolio: total += s['shares']*s['price'] >>> print(total) 44671.15 >>> Aqu\u00ed, notar\u00e1s que se accede a los diferentes campos de cada entrada mediante nombres de clave en lugar de n\u00fameros de columna num\u00e9ricos. A menudo se prefiere esto porque el c\u00f3digo resultante es m\u00e1s f\u00e1cil de leer m\u00e1s adelante. Visualizar diccionarios y listas grandes puede resultar complicado. Para limpiar la salida para la depuraci\u00f3n, considere usar la funci\u00f3n pprint . >>> from pprint import pprint >>> pprint(portfolio) [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] >>>","title":"Ejercicio 2.5: Lista de diccionarios"},{"location":"02_Working_with_data/02_Containers/#ejercicio-26-diccionarios-como-contenedor","text":"Un diccionario es una forma \u00fatil de realizar un seguimiento de los elementos, en los que desea buscar elementos utilizando un \u00edndice que no sea un n\u00famero entero. En el modo interactivo de Python, intenta jugar con un diccionario: >>> prices = { } >>> prices['IBM'] = 92.45 >>> prices['MSFT'] = 45.12 >>> prices ... vea el resultado ... >>> prices['IBM'] 92.45 >>> prices['AAPL'] ... vea el resultado ... >>> 'AAPL' in prices False >>> El archivo Data/prices.csv contiene una serie de l\u00edneas con precios de acciones. El archivo se parece a esto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 \"C\",3.72 ... Escriba una funci\u00f3n read_prices(filename) que lea un conjunto de precios como este en un diccionario donde las claves del diccionario son los nombres de las acciones y los valores en el diccionario son los precios de las acciones. Para hacer esto, comience con un diccionario vac\u00edo y comience a insertar valores en \u00e9l tal como lo hizo anteriormente. Sin embargo, ahora est\u00e1s leyendo los valores de un archivo. Utilizaremos esta estructura de datos para buscar r\u00e1pidamente el precio de una acci\u00f3n determinada. Algunos peque\u00f1os consejos que necesitar\u00e1s para esta parte. Primero, aseg\u00farate de utilizar el m\u00f3dulo csv tal como lo hiciste antes; no es necesario reinventar la rueda aqu\u00ed. >>> import csv >>> f = open('Data/prices.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['AA', '9.22'] ['AXP', '24.85'] ... [] >>> La otra peque\u00f1a complicaci\u00f3n es que el archivo Data/prices.csv puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos anterior es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque que su programa muera con una excepci\u00f3n. Utilice las instrucciones try y except para detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos err\u00f3neos con una declaraci\u00f3n if ? Una vez que haya escrito su funci\u00f3n read_prices() , pru\u00e9bela de forma interactiva para asegurarse de que funciona: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>>","title":"Ejercicio 2.6: Diccionarios como contenedor"},{"location":"02_Working_with_data/02_Containers/#ejercicio-27-como-saber-si-puedes-jubilarte","text":"Conecte todo este trabajo agregando algunas declaraciones adicionales a su programa report.py que calcula la ganancia/p\u00e9rdida. Estas afirmaciones deben tomar la lista de acciones del Ejercicio 2.5 y el diccionario de precios del Ejercicio 2.6 y calcular el valor actual de la cartera junto con la ganancia/p\u00e9rdida. Si ejecuta: bash % python3 -i report.py La salida deber\u00eda verse as\u00ed: Total cost 44671.15 Current value 28686.1 Gain/Loss -15985.050000000003 Contenido | Anterior (2.1 Tipos de datos) | Pr\u00f3ximo (2.3 Salida con formato)","title":"Ejercicio 2.7: C\u00f3mo saber si puedes jubilarte"},{"location":"02_Working_with_data/03_Formatting/","text":"Contenido | Anterior (2.2 Contenedores) | Pr\u00f3ximo (2.4 Secuencias) 2.3 Salida con formato Esta secci\u00f3n es una ligera digresi\u00f3n, pero cuando se trabaja con datos, a menudo se desea producir resultados estructurados (tablas, etc.). Por ejemplo: Name Shares Price ---------- ---------- ----------- AA 100 32.20 IBM 50 91.10 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.10 IBM 100 70.44 Formato de cadena Una forma de formatear cadenas en Python 3.6+ es con f-strings . >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{name:>10s} {shares:>10d} {price:>10.2f}' ' IBM 100 91.10' >>> Se reemplaza la parte {expresi\u00f3n:formato} . Se utiliza com\u00fanmente con print . print(f'{name:>10s} {shares:>10d} {price:>10.2f}') C\u00f3digos de formato Los c\u00f3digos de formato (despu\u00e9s del : dentro de {} ) son similares a printf() de C. Los c\u00f3digos comunes incluyen: d Decimal entero b Binary entero x Hexadecimal entero f Float como [-]m.dddddd e Float como [-]m.dddddde+-xx g Float, pero selectivo uso de la notaci\u00f3n E s String c Character (desde entero) Los modificadores comunes ajustan el ancho del campo y la precisi\u00f3n decimal. Esta es una lista parcial: :>10d Entero alineado a la derecha en un campo de 10 caracteres :<10d Entero alineado a la izquierda en un campo de 10 caracteres :^10d Entero centrado en un campo de 10 caracteres :0.2f Flotante con precisi\u00f3n de 2 d\u00edgitos :0,.2f Flotante con precisi\u00f3n de 2 d\u00edgitos y coma en los miles. Formato del diccionario Puede utilizar el m\u00e9todo format_map() para aplicar formato de cadena a un diccionario de valores: >>> s = { 'name': 'IBM', 'shares': 100, 'price': 91.1 } >>> '{name:>10s} {shares:10d} {price:10.2f}'.format_map(s) ' IBM 100 91.10' >>> Utiliza los mismos c\u00f3digos que f-strings pero toma los valores del diccionario suministrado. M\u00e9todo format() Hay un m\u00e9todo format() que puede aplicar formato a argumentos o argumentos de palabras clave. >>> '{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1) ' IBM 100 91.10' >>> '{:>10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1) ' IBM 100 91.10' >>> Francamente, format() es un poco verborr\u00e1gico. Prefiero las f-strngs . Formato estilo C Tambi\u00e9n puede utilizar el operador de formato % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%5d %d %14d' % (3,4,5) # mismo resultado que al anterior ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo elemento o una tupla a la derecha. Los c\u00f3digos de formato tambi\u00e9n se modelan seg\u00fan printf() de C. Nota: Este es el \u00fanico formato disponible en cadenas de bytes. >>> b'%s tiene %d mensajes' % (b'Dave', 37) b'Dave tiene 37 mensajes >>> b'%b tiene %d mensajes' % (b'Dave', 37) # %b se puede usar en lugar de %s b'Dave tiene 37 mensajes >>> Ejercicios Ejercicio 2.8: C\u00f3mo formatear n\u00fameros Un problema com\u00fan con la impresi\u00f3n de n\u00fameros es especificar el n\u00famero de decimales. Una forma de solucionar esto es utilizar f-strings . Pruebe estos ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato utilizados en f-strings se puede encontrar aqu\u00ed . El formateo tambi\u00e9n se realiza a veces utilizando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> print('%16,.2f' % value) Traceback (most recent call last): File \"<python-input-39>\", line 1, in <module> print('%16,.2f' % value) ~~~~~~~~~~^~~~~~~ ValueError: unsupported format character ',' (0x2c) at index 3 >>> La documentaci\u00f3n sobre varios c\u00f3digos utilizados con % se puede encontrar aqu\u00ed . Aunque se usa com\u00fanmente con print , el formato de cadena no est\u00e1 vinculado a la impresi\u00f3n. Si desea guardar una cadena formateada. Simplemente as\u00edgnelo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>> Ejercicio 2.9: Recopilaci\u00f3n de datos En el ejercicio 2.7, escribi\u00f3 un programa llamado report.py que calcul\u00f3 la ganancia/p\u00e9rdida de una cartera de acciones. En este ejercicio, comenzar\u00e1s a modificarlo para producir una tabla como esta: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 En este informe, Price es el precio actual de la acci\u00f3n y Change es el cambio en el precio de la acci\u00f3n respecto del precio de compra inicial. Para generar el informe anterior, primero deber\u00e1 recopilar todos los datos que se muestran en la tabla. Escriba una funci\u00f3n make_report() que tome una lista de acciones y un diccionario de precios como entrada y devuelva una lista de tuplas que contengan las filas de la tabla anterior. Agregue esta funci\u00f3n a su archivo report.py . As\u00ed es como deber\u00eda funcionar si lo intentas de forma interactiva: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> prices = read_prices('Data/prices.csv') >>> report = make_report(portfolio, prices) >>> for r in report: print(r) ('AA', 100, 9.22, -22.980000000000004) ('IBM', 50, 106.28, 15.180000000000007) ('CAT', 150, 35.46, -47.98) ('MSFT', 200, 20.89, -30.339999999999996) ('GE', 95, 13.48, -26.889999999999997) ... >>> Ejercicio 2.10: Impresi\u00f3n de una tabla formateada Rehaga el bucle for del Ejercicio 2.9, pero cambie la declaraci\u00f3n de impresi\u00f3n para formatear las tuplas. >>> for r in report: print('%10s %10d %10.2f %10.2f' % r) AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tambi\u00e9n puedes expandir los valores y utilizar f-strings . Por ejemplo: >>> for name, shares, price, change in report: print(f'{name:>10s} {shares:>10d} {price:>10.2f} {change:>10.2f}') AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tome las declaraciones anteriores y agr\u00e9guelas a su programa report.py . Haga que su programa tome la salida de la funci\u00f3n make_report() e imprima una tabla bien formateada como se muestra. Ejercicio 2.11: Agregar algunos encabezados Supongamos que tienes una tupla de nombres de encabezado como \u00e9ste: headers = ('Name', 'Shares', 'Price', 'Change') Agregue c\u00f3digo a su programa que tome la tupla de encabezados anterior y cree una cadena donde cada nombre de encabezado est\u00e9 alineado a la derecha en un campo de 10 caracteres de ancho y cada campo est\u00e9 separado por un solo espacio. ' Name Shares Price Change' Escriba el c\u00f3digo que tome los encabezados y cree la cadena separadora entre los encabezados y los datos a seguir. Esta cadena es solo un conjunto de caracteres \"-\" debajo de cada nombre de campo. Por ejemplo: '---------- ---------- ---------- -----------' Cuando haya terminado, su programa deber\u00eda producir la tabla que se muestra en la parte superior de este ejercicio. Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Ejercicio 2.12: Desaf\u00edo de formato \u00bfC\u00f3mo modificar\u00edas tu c\u00f3digo para que el precio incluya el s\u00edmbolo de moneda ($) y el resultado se vea as\u00ed: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 $9.22 -22.98 IBM 50 $106.28 15.18 CAT 150 $35.46 -47.98 MSFT 200 $20.89 -30.34 GE 95 $13.48 -26.89 MSFT 50 $20.89 -44.21 IBM 100 $106.28 35.84 Contenido | Anterior (2.2 Contenedores) | Pr\u00f3ximo (2.4 Secuencias)","title":"03_Formatting"},{"location":"02_Working_with_data/03_Formatting/#23-salida-con-formato","text":"Esta secci\u00f3n es una ligera digresi\u00f3n, pero cuando se trabaja con datos, a menudo se desea producir resultados estructurados (tablas, etc.). Por ejemplo: Name Shares Price ---------- ---------- ----------- AA 100 32.20 IBM 50 91.10 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.10 IBM 100 70.44","title":"2.3 Salida con formato"},{"location":"02_Working_with_data/03_Formatting/#formato-de-cadena","text":"Una forma de formatear cadenas en Python 3.6+ es con f-strings . >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{name:>10s} {shares:>10d} {price:>10.2f}' ' IBM 100 91.10' >>> Se reemplaza la parte {expresi\u00f3n:formato} . Se utiliza com\u00fanmente con print . print(f'{name:>10s} {shares:>10d} {price:>10.2f}')","title":"Formato de cadena"},{"location":"02_Working_with_data/03_Formatting/#codigos-de-formato","text":"Los c\u00f3digos de formato (despu\u00e9s del : dentro de {} ) son similares a printf() de C. Los c\u00f3digos comunes incluyen: d Decimal entero b Binary entero x Hexadecimal entero f Float como [-]m.dddddd e Float como [-]m.dddddde+-xx g Float, pero selectivo uso de la notaci\u00f3n E s String c Character (desde entero) Los modificadores comunes ajustan el ancho del campo y la precisi\u00f3n decimal. Esta es una lista parcial: :>10d Entero alineado a la derecha en un campo de 10 caracteres :<10d Entero alineado a la izquierda en un campo de 10 caracteres :^10d Entero centrado en un campo de 10 caracteres :0.2f Flotante con precisi\u00f3n de 2 d\u00edgitos :0,.2f Flotante con precisi\u00f3n de 2 d\u00edgitos y coma en los miles.","title":"C\u00f3digos de formato"},{"location":"02_Working_with_data/03_Formatting/#formato-del-diccionario","text":"Puede utilizar el m\u00e9todo format_map() para aplicar formato de cadena a un diccionario de valores: >>> s = { 'name': 'IBM', 'shares': 100, 'price': 91.1 } >>> '{name:>10s} {shares:10d} {price:10.2f}'.format_map(s) ' IBM 100 91.10' >>> Utiliza los mismos c\u00f3digos que f-strings pero toma los valores del diccionario suministrado.","title":"Formato del diccionario"},{"location":"02_Working_with_data/03_Formatting/#metodo-format","text":"Hay un m\u00e9todo format() que puede aplicar formato a argumentos o argumentos de palabras clave. >>> '{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1) ' IBM 100 91.10' >>> '{:>10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1) ' IBM 100 91.10' >>> Francamente, format() es un poco verborr\u00e1gico. Prefiero las f-strngs .","title":"M\u00e9todo format()"},{"location":"02_Working_with_data/03_Formatting/#formato-estilo-c","text":"Tambi\u00e9n puede utilizar el operador de formato % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%5d %d %14d' % (3,4,5) # mismo resultado que al anterior ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo elemento o una tupla a la derecha. Los c\u00f3digos de formato tambi\u00e9n se modelan seg\u00fan printf() de C. Nota: Este es el \u00fanico formato disponible en cadenas de bytes. >>> b'%s tiene %d mensajes' % (b'Dave', 37) b'Dave tiene 37 mensajes >>> b'%b tiene %d mensajes' % (b'Dave', 37) # %b se puede usar en lugar de %s b'Dave tiene 37 mensajes >>>","title":"Formato estilo C"},{"location":"02_Working_with_data/03_Formatting/#ejercicios","text":"","title":"Ejercicios"},{"location":"02_Working_with_data/03_Formatting/#ejercicio-28-como-formatear-numeros","text":"Un problema com\u00fan con la impresi\u00f3n de n\u00fameros es especificar el n\u00famero de decimales. Una forma de solucionar esto es utilizar f-strings . Pruebe estos ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato utilizados en f-strings se puede encontrar aqu\u00ed . El formateo tambi\u00e9n se realiza a veces utilizando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> print('%16,.2f' % value) Traceback (most recent call last): File \"<python-input-39>\", line 1, in <module> print('%16,.2f' % value) ~~~~~~~~~~^~~~~~~ ValueError: unsupported format character ',' (0x2c) at index 3 >>> La documentaci\u00f3n sobre varios c\u00f3digos utilizados con % se puede encontrar aqu\u00ed . Aunque se usa com\u00fanmente con print , el formato de cadena no est\u00e1 vinculado a la impresi\u00f3n. Si desea guardar una cadena formateada. Simplemente as\u00edgnelo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>>","title":"Ejercicio 2.8: C\u00f3mo formatear n\u00fameros"},{"location":"02_Working_with_data/03_Formatting/#ejercicio-29-recopilacion-de-datos","text":"En el ejercicio 2.7, escribi\u00f3 un programa llamado report.py que calcul\u00f3 la ganancia/p\u00e9rdida de una cartera de acciones. En este ejercicio, comenzar\u00e1s a modificarlo para producir una tabla como esta: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 En este informe, Price es el precio actual de la acci\u00f3n y Change es el cambio en el precio de la acci\u00f3n respecto del precio de compra inicial. Para generar el informe anterior, primero deber\u00e1 recopilar todos los datos que se muestran en la tabla. Escriba una funci\u00f3n make_report() que tome una lista de acciones y un diccionario de precios como entrada y devuelva una lista de tuplas que contengan las filas de la tabla anterior. Agregue esta funci\u00f3n a su archivo report.py . As\u00ed es como deber\u00eda funcionar si lo intentas de forma interactiva: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> prices = read_prices('Data/prices.csv') >>> report = make_report(portfolio, prices) >>> for r in report: print(r) ('AA', 100, 9.22, -22.980000000000004) ('IBM', 50, 106.28, 15.180000000000007) ('CAT', 150, 35.46, -47.98) ('MSFT', 200, 20.89, -30.339999999999996) ('GE', 95, 13.48, -26.889999999999997) ... >>>","title":"Ejercicio 2.9: Recopilaci\u00f3n de datos"},{"location":"02_Working_with_data/03_Formatting/#ejercicio-210-impresion-de-una-tabla-formateada","text":"Rehaga el bucle for del Ejercicio 2.9, pero cambie la declaraci\u00f3n de impresi\u00f3n para formatear las tuplas. >>> for r in report: print('%10s %10d %10.2f %10.2f' % r) AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tambi\u00e9n puedes expandir los valores y utilizar f-strings . Por ejemplo: >>> for name, shares, price, change in report: print(f'{name:>10s} {shares:>10d} {price:>10.2f} {change:>10.2f}') AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tome las declaraciones anteriores y agr\u00e9guelas a su programa report.py . Haga que su programa tome la salida de la funci\u00f3n make_report() e imprima una tabla bien formateada como se muestra.","title":"Ejercicio 2.10: Impresi\u00f3n de una tabla formateada"},{"location":"02_Working_with_data/03_Formatting/#ejercicio-211-agregar-algunos-encabezados","text":"Supongamos que tienes una tupla de nombres de encabezado como \u00e9ste: headers = ('Name', 'Shares', 'Price', 'Change') Agregue c\u00f3digo a su programa que tome la tupla de encabezados anterior y cree una cadena donde cada nombre de encabezado est\u00e9 alineado a la derecha en un campo de 10 caracteres de ancho y cada campo est\u00e9 separado por un solo espacio. ' Name Shares Price Change' Escriba el c\u00f3digo que tome los encabezados y cree la cadena separadora entre los encabezados y los datos a seguir. Esta cadena es solo un conjunto de caracteres \"-\" debajo de cada nombre de campo. Por ejemplo: '---------- ---------- ---------- -----------' Cuando haya terminado, su programa deber\u00eda producir la tabla que se muestra en la parte superior de este ejercicio. Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84","title":"Ejercicio 2.11: Agregar algunos encabezados"},{"location":"02_Working_with_data/03_Formatting/#ejercicio-212-desafio-de-formato","text":"\u00bfC\u00f3mo modificar\u00edas tu c\u00f3digo para que el precio incluya el s\u00edmbolo de moneda ($) y el resultado se vea as\u00ed: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 $9.22 -22.98 IBM 50 $106.28 15.18 CAT 150 $35.46 -47.98 MSFT 200 $20.89 -30.34 GE 95 $13.48 -26.89 MSFT 50 $20.89 -44.21 IBM 100 $106.28 35.84 Contenido | Anterior (2.2 Contenedores) | Pr\u00f3ximo (2.4 Secuencias)","title":"Ejercicio 2.12: Desaf\u00edo de formato"},{"location":"02_Working_with_data/04_Sequences/","text":"Contenido | Anterior (2.3 Salida con formato) | Pr\u00f3ximo (2.5 M\u00f3dulo Collections) 2.4 Secuencias Tipos de datos de secuencia Python tiene tres tipos de datos de secuencia . Cadena: 'Hola' . Una cadena es una secuencia de caracteres. str Lista: [1, 4, 5] . list Tupla: ('GOOG', 100, 490.1) . tuple Todas las secuencias est\u00e1n ordenadas, indexadas por n\u00fameros enteros y tienen una longitud. a = 'Hello' # String b = [1, 4, 5] # Lista c = ('GOOG', 100, 490.1) # Tupla # Orden Indexado a[0] # 'H' b[-1] # 5 c[1] # 100 # Longitud de la secuencia len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias se pueden replicar: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Las secuencias del mismo tipo se pueden concatenar: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple Rebanar Rebanar significa tomar una subsecuencia de una secuencia. La sintaxis es s[inicio:fin] . Donde inicio y fin son los \u00edndices de la subsecuencia que desea. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] Los \u00edndices inicio y fin deben ser n\u00fameros enteros. Las porciones no incluyen el valor final. Es como un intervalo medio abierto de matem\u00e1ticas. Si se omiten los \u00edndices, el valor predeterminado es el principio o el final de la lista. Reasignaci\u00f3n de sectores En las listas, las porciones se pueden reasignar y eliminar. # Reasignaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Nota: La porci\u00f3n reasignada no necesita tener la misma longitud. # Eliminaci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8] Reducciones de secuencia Hay algunas funciones comunes para reducir una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hola', 'Mundo'] >>> max(t) 'Mundo' >>> ## Iteraci\u00f3n sobre una secuencia El bucle for itera sobre los elementos de una secuencia. ```python >>> s = [1, 4, 9, 16] >>> for i in s: print(i) 1 4 9 16 >>> En cada iteraci\u00f3n del bucle, obtienes un nuevo elemento con el que trabajar. Este nuevo valor se coloca en la variable de iteraci\u00f3n. En este ejemplo, la variable de iteraci\u00f3n es x : for x in s: # `x` es una variable de iteraci\u00f3n ...declaraciones En cada iteraci\u00f3n, se sobrescribe el valor anterior de la variable de iteraci\u00f3n (si lo hay). Una vez finalizado el bucle, la variable conserva el \u00faltimo valor. Declaraci\u00f3n break Puede utilizar la declaraci\u00f3n break para salir de un bucle antes de tiempo. for name in namelist: if name == 'Jake': break ... ... declaraciones Cuando se ejecuta la declaraci\u00f3n break , sale del bucle y pasa a las siguientes declaraciones . La declaraci\u00f3n break s\u00f3lo se aplica al bucle m\u00e1s interno. Si este bucle est\u00e1 dentro de otro bucle, no romper\u00e1 el bucle externo. Declaraci\u00f3n continue Para omitir un elemento y pasar al siguiente, utilice la instrucci\u00f3n continue . for line in lines: if line == '\\n': # Omite l\u00edneas en blanco continue # M\u00e1s declaraciones ... Esto es \u00fatil cuando el elemento actual no es de inter\u00e9s o no necesita ser revisado, ignoradolo en el procesamiento. Recorriendo n\u00fameros enteros Si necesita contar, utilice range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([inicio,] fin [,escal\u00f3n]) for i in range(100): # i = 0,1,...,99 for j in range(10,20): # j = 10,11,..., 19 for k in range(10,50,2): # k = 10,12,...,48 # Observe que se cuenta en escalones de 2, no de 1. El valor final nunca se incluye. Espeja el comportamiento de las rebanadas. start es opcional. Valor predeterminado 0 . step es opcional. Valor predeterminado 1 . range() calcula valores seg\u00fan sea necesario. En realidad no almacena un rango amplio de n\u00fameros. Funci\u00f3n enumerate() La funci\u00f3n enumerate agrega un valor de contador adicional a la iteraci\u00f3n. names = ['Elwood', 'Jake', 'Curtis'] for i, name in enumerate(names): # Bucle con i = 0, name = 'Elwood' # i = 1, name = 'Jake' # i = 2, name = 'Curtis' La forma general es enumerate(secuencia [, inicio = 0]) . start es opcional. Un buen ejemplo del uso de enumerate() es el seguimiento de los n\u00fameros de l\u00ednea mientras se lee un archivo: with open(filename) as f: for lineno, line in enumerate(f, start=1): ... Al final, enumerate es simplemente un buen atajo para: i = 0 for x in s: declaraciones i += 1 El uso de enumerate implica escribir menos y se ejecuta un poco m\u00e1s r\u00e1pido. for y tuplas Puedes iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # Bucle con x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando se utilizan m\u00faltiples variables, cada tupla se desempaqueta en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con el n\u00famero de elementos en cada tupla. Funci\u00f3n zip() La funci\u00f3n zip toma m\u00faltiples secuencias y crea un iterador que las combina. columns = ['name', 'shares', 'price'] values = ['GOOG', 100, 490.1 ] pairs = zip(columns, values) # ('name','GOOG'), ('shares',100), ('price',490.1) Para obtener el resultado debes iterar. Puedes usar m\u00faltiples variables para desempaquetar las tuplas como se mostr\u00f3 anteriormente. for column, value in pairs: ... Un uso com\u00fan de zip es crear pares clave/valor para construir diccionarios. d = dict(zip(columns, values)) Ejercicios Ejercicio 2.13: Contar Pruebe algunos ejemplos b\u00e1sicos de conteo: >>> for n in range(10): # Count 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Count 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Count 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>> Ejercicio 2.14: M\u00e1s operaciones de secuencia Experimente interactivamente con algunas de las operaciones de reducci\u00f3n de secuencia. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Intente recorrer los datos en un bucle. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >>> A veces, los novatos utilizan la declaraci\u00f3n for , len() y range() en alg\u00fan tipo de fragmento de c\u00f3digo horrible que parece surgido de las profundidades de un programa C oxidado. >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> \u00a1No hagas eso! No s\u00f3lo leerlo hace sangrar los ojos a todos, sino que adem\u00e1s es ineficiente con la memoria y funciona mucho m\u00e1s lento. Simplemente use un bucle for normal si desea iterar sobre los datos. Utilice enumerate() si necesita el \u00edndice por alg\u00fan motivo. Ejercicio 2.15: Un ejemplo pr\u00e1ctico de enumerate() Recuerde que el archivo Data/missing.csv contiene datos de una cartera de acciones, pero tiene algunas filas con datos faltantes. Usando enumerate() , modifique su programa pcost.py para que imprima un n\u00famero de l\u00ednea con el mensaje de advertencia cuando encuentre una entrada incorrecta. >>> cost = portfolio_cost('Data/missing.csv') Row 4: Couldn't convert: ['MSFT', '', '51.23'] # Fila 4: No se puede convertir Row 7: Couldn't convert: ['IBM', '', '70.44'] # Fila 7: No se puede convertir >>> Para hacer esto, necesitar\u00e1s cambiar algunas partes de tu c\u00f3digo. ... for rowno, row in enumerate(rows, start=1): try: ... except ValueError: print(f'Row {rowno}: Bad row: {row}') Ejercicio 2.16: Uso de la funci\u00f3n zip() En el archivo Data/portfolio.csv , la primera l\u00ednea contiene encabezados de columna. En todo el c\u00f3digo anterior, los hemos estado descartando. >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> Pero \u00bfqu\u00e9 pasar\u00eda si pudieses usar los encabezados para algo \u00fatil? Aqu\u00ed es donde entra en escena la funci\u00f3n zip() . Primero intente esto para emparejar los encabezados de archivo con una fila de datos: >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> list(zip(headers, row)) [ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ] >>> Observe c\u00f3mo zip() emparej\u00f3 los encabezados de columna con los valores de columna. Aqu\u00ed usamos list() para convertir el resultado en una lista para que puedas verlo. Normalmente, zip() crea un iterador que debe ser consumido por un bucle for. Este emparejamiento es un paso intermedio para construir un diccionario. Ahora prueba esto: >>> record = dict(zip(headers, row)) >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Esta transformaci\u00f3n es uno de los trucos m\u00e1s \u00fatiles que debemos conocer al procesar muchos archivos de datos. Por ejemplo, supongamos que desea hacer que el programa pcost.py funcione con varios archivos de entrada, pero sin tener en cuenta el n\u00famero de columna real donde aparecen el nombre, las acciones y el precio. Modifique la funci\u00f3n portfolio_cost() en pcost.py para que se vea as\u00ed: # pcost.py def portfolio_cost(filename): ... for rowno, row in enumerate(rows, start=1): record = dict(zip(headers, row)) try: nshares = int(record['shares']) price = float(record['price']) total_cost += nshares * price # Esto detecta errores en las conversiones int() y float() anteriores except ValueError: print(f'Row {rowno}: Bad row: {row}') ... Ahora, prueba tu funci\u00f3n en un archivo de datos completamente diferente Data/portfoliodate.csv que se ve as\u00ed: name,date,time,shares,price \"AA\",\"6/11/2007\",\"9:50am\",100,32.20 \"IBM\",\"5/13/2007\",\"4:20pm\",50,91.10 \"CAT\",\"9/23/2006\",\"1:30pm\",150,83.44 \"MSFT\",\"5/17/2007\",\"10:30am\",200,51.23 \"GE\",\"2/1/2006\",\"10:45am\",95,40.37 \"MSFT\",\"10/31/2006\",\"12:05pm\",50,65.10 \"IBM\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> portfolio_cost('Data/portfoliodate.csv') 44671.15 >>> Si lo hiciste bien, descubrir\u00e1s que tu programa a\u00fan funciona. aunque el archivo de datos tiene un formato de columna completamente diferente al anterior. \u00a1Eso es genial! El cambio realizado aqu\u00ed es sutil, pero significativo. En lugar de que portfolio_cost() est\u00e9 codificado para leer un \u00fanico formato de archivo fijo, la nueva versi\u00f3n lee cualquier archivo CSV y selecciona los valores de inter\u00e9s. Siempre que el archivo tenga las columnas requeridas, el c\u00f3digo funcionar\u00e1. Modifique el programa report.py que escribi\u00f3 en la Secci\u00f3n 2.3 para que utilice la misma t\u00e9cnica para seleccionar los encabezados de columna. Intente ejecutar el programa report.py en el archivo Data/portfoliodate.csv y ver\u00e1 que produce la misma respuesta que antes. Ejercicio 2.17: Invertir un diccionario Un diccionario asigna claves a valores. Por ejemplo, un diccionario de precios de acciones. >>> prices = { 'GOOG' : 490.1, 'AA' : 23.45, 'IBM' : 91.1, 'MSFT' : 34.23 } >>> Si utiliza el m\u00e9todo items() , puede obtener pares (clave, valor) : >>> prices.items() dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)]) >>> Sin embargo, \u00bfqu\u00e9 sucede si desea obtener una lista de pares '(valor, clave)'? Sugerencia: use zip() . >>> pricelist = list(zip(prices.values(),prices.keys())) >>> pricelist [(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')] >>> \u00bfPor qu\u00e9 har\u00edas esto? En primer lugar, permite realizar cierto tipo de procesamiento con los datos del diccionario. >>> min(pricelist) (23.45, 'AA') >>> max(pricelist) (490.1, 'GOOG') >>> sorted(pricelist) [(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')] >>> Esto tambi\u00e9n ilustra una caracter\u00edstica importante de las tuplas. Cuando se utilizan en comparaciones, las tuplas se comparan elemento por elemento comenzando con el primer elemento. Similar a c\u00f3mo se comparan cadenas, car\u00e1cter por car\u00e1cter. zip() se usa a menudo en situaciones como \u00e9sta, donde es necesario emparejar datos de diferentes lugares. Por ejemplo, emparejar los nombres de las columnas con los valores de las columnas para crear un diccionario de valores con nombre. Tenga en cuenta que zip() no est\u00e1 limitado a pares. Por ejemplo, puedes usarlo con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Adem\u00e1s, tenga en cuenta que zip() se detiene una vez que se agota la secuencia de entrada m\u00e1s corta. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>> Contenido | Anterior (2.3 Salida con formato) | Pr\u00f3ximo (2.5 M\u00f3dulo Collections)","title":"04_Sequences"},{"location":"02_Working_with_data/04_Sequences/#24-secuencias","text":"","title":"2.4 Secuencias"},{"location":"02_Working_with_data/04_Sequences/#tipos-de-datos-de-secuencia","text":"Python tiene tres tipos de datos de secuencia . Cadena: 'Hola' . Una cadena es una secuencia de caracteres. str Lista: [1, 4, 5] . list Tupla: ('GOOG', 100, 490.1) . tuple Todas las secuencias est\u00e1n ordenadas, indexadas por n\u00fameros enteros y tienen una longitud. a = 'Hello' # String b = [1, 4, 5] # Lista c = ('GOOG', 100, 490.1) # Tupla # Orden Indexado a[0] # 'H' b[-1] # 5 c[1] # 100 # Longitud de la secuencia len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias se pueden replicar: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Las secuencias del mismo tipo se pueden concatenar: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple","title":"Tipos de datos de secuencia"},{"location":"02_Working_with_data/04_Sequences/#rebanar","text":"Rebanar significa tomar una subsecuencia de una secuencia. La sintaxis es s[inicio:fin] . Donde inicio y fin son los \u00edndices de la subsecuencia que desea. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] Los \u00edndices inicio y fin deben ser n\u00fameros enteros. Las porciones no incluyen el valor final. Es como un intervalo medio abierto de matem\u00e1ticas. Si se omiten los \u00edndices, el valor predeterminado es el principio o el final de la lista.","title":"Rebanar"},{"location":"02_Working_with_data/04_Sequences/#reasignacion-de-sectores","text":"En las listas, las porciones se pueden reasignar y eliminar. # Reasignaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Nota: La porci\u00f3n reasignada no necesita tener la misma longitud. # Eliminaci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8]","title":"Reasignaci\u00f3n de sectores"},{"location":"02_Working_with_data/04_Sequences/#reducciones-de-secuencia","text":"Hay algunas funciones comunes para reducir una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hola', 'Mundo'] >>> max(t) 'Mundo' >>> ## Iteraci\u00f3n sobre una secuencia El bucle for itera sobre los elementos de una secuencia. ```python >>> s = [1, 4, 9, 16] >>> for i in s: print(i) 1 4 9 16 >>> En cada iteraci\u00f3n del bucle, obtienes un nuevo elemento con el que trabajar. Este nuevo valor se coloca en la variable de iteraci\u00f3n. En este ejemplo, la variable de iteraci\u00f3n es x : for x in s: # `x` es una variable de iteraci\u00f3n ...declaraciones En cada iteraci\u00f3n, se sobrescribe el valor anterior de la variable de iteraci\u00f3n (si lo hay). Una vez finalizado el bucle, la variable conserva el \u00faltimo valor.","title":"Reducciones de secuencia"},{"location":"02_Working_with_data/04_Sequences/#declaracion-break","text":"Puede utilizar la declaraci\u00f3n break para salir de un bucle antes de tiempo. for name in namelist: if name == 'Jake': break ... ... declaraciones Cuando se ejecuta la declaraci\u00f3n break , sale del bucle y pasa a las siguientes declaraciones . La declaraci\u00f3n break s\u00f3lo se aplica al bucle m\u00e1s interno. Si este bucle est\u00e1 dentro de otro bucle, no romper\u00e1 el bucle externo.","title":"Declaraci\u00f3n break"},{"location":"02_Working_with_data/04_Sequences/#declaracion-continue","text":"Para omitir un elemento y pasar al siguiente, utilice la instrucci\u00f3n continue . for line in lines: if line == '\\n': # Omite l\u00edneas en blanco continue # M\u00e1s declaraciones ... Esto es \u00fatil cuando el elemento actual no es de inter\u00e9s o no necesita ser revisado, ignoradolo en el procesamiento.","title":"Declaraci\u00f3n continue"},{"location":"02_Working_with_data/04_Sequences/#recorriendo-numeros-enteros","text":"Si necesita contar, utilice range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([inicio,] fin [,escal\u00f3n]) for i in range(100): # i = 0,1,...,99 for j in range(10,20): # j = 10,11,..., 19 for k in range(10,50,2): # k = 10,12,...,48 # Observe que se cuenta en escalones de 2, no de 1. El valor final nunca se incluye. Espeja el comportamiento de las rebanadas. start es opcional. Valor predeterminado 0 . step es opcional. Valor predeterminado 1 . range() calcula valores seg\u00fan sea necesario. En realidad no almacena un rango amplio de n\u00fameros.","title":"Recorriendo n\u00fameros enteros"},{"location":"02_Working_with_data/04_Sequences/#funcion-enumerate","text":"La funci\u00f3n enumerate agrega un valor de contador adicional a la iteraci\u00f3n. names = ['Elwood', 'Jake', 'Curtis'] for i, name in enumerate(names): # Bucle con i = 0, name = 'Elwood' # i = 1, name = 'Jake' # i = 2, name = 'Curtis' La forma general es enumerate(secuencia [, inicio = 0]) . start es opcional. Un buen ejemplo del uso de enumerate() es el seguimiento de los n\u00fameros de l\u00ednea mientras se lee un archivo: with open(filename) as f: for lineno, line in enumerate(f, start=1): ... Al final, enumerate es simplemente un buen atajo para: i = 0 for x in s: declaraciones i += 1 El uso de enumerate implica escribir menos y se ejecuta un poco m\u00e1s r\u00e1pido.","title":"Funci\u00f3n enumerate()"},{"location":"02_Working_with_data/04_Sequences/#for-y-tuplas","text":"Puedes iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # Bucle con x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando se utilizan m\u00faltiples variables, cada tupla se desempaqueta en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con el n\u00famero de elementos en cada tupla.","title":"for y tuplas"},{"location":"02_Working_with_data/04_Sequences/#funcion-zip","text":"La funci\u00f3n zip toma m\u00faltiples secuencias y crea un iterador que las combina. columns = ['name', 'shares', 'price'] values = ['GOOG', 100, 490.1 ] pairs = zip(columns, values) # ('name','GOOG'), ('shares',100), ('price',490.1) Para obtener el resultado debes iterar. Puedes usar m\u00faltiples variables para desempaquetar las tuplas como se mostr\u00f3 anteriormente. for column, value in pairs: ... Un uso com\u00fan de zip es crear pares clave/valor para construir diccionarios. d = dict(zip(columns, values))","title":"Funci\u00f3n zip()"},{"location":"02_Working_with_data/04_Sequences/#ejercicios","text":"","title":"Ejercicios"},{"location":"02_Working_with_data/04_Sequences/#ejercicio-213-contar","text":"Pruebe algunos ejemplos b\u00e1sicos de conteo: >>> for n in range(10): # Count 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Count 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Count 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>>","title":"Ejercicio 2.13: Contar"},{"location":"02_Working_with_data/04_Sequences/#ejercicio-214-mas-operaciones-de-secuencia","text":"Experimente interactivamente con algunas de las operaciones de reducci\u00f3n de secuencia. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Intente recorrer los datos en un bucle. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >>> A veces, los novatos utilizan la declaraci\u00f3n for , len() y range() en alg\u00fan tipo de fragmento de c\u00f3digo horrible que parece surgido de las profundidades de un programa C oxidado. >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> \u00a1No hagas eso! No s\u00f3lo leerlo hace sangrar los ojos a todos, sino que adem\u00e1s es ineficiente con la memoria y funciona mucho m\u00e1s lento. Simplemente use un bucle for normal si desea iterar sobre los datos. Utilice enumerate() si necesita el \u00edndice por alg\u00fan motivo.","title":"Ejercicio 2.14: M\u00e1s operaciones de secuencia"},{"location":"02_Working_with_data/04_Sequences/#ejercicio-215-un-ejemplo-practico-de-enumerate","text":"Recuerde que el archivo Data/missing.csv contiene datos de una cartera de acciones, pero tiene algunas filas con datos faltantes. Usando enumerate() , modifique su programa pcost.py para que imprima un n\u00famero de l\u00ednea con el mensaje de advertencia cuando encuentre una entrada incorrecta. >>> cost = portfolio_cost('Data/missing.csv') Row 4: Couldn't convert: ['MSFT', '', '51.23'] # Fila 4: No se puede convertir Row 7: Couldn't convert: ['IBM', '', '70.44'] # Fila 7: No se puede convertir >>> Para hacer esto, necesitar\u00e1s cambiar algunas partes de tu c\u00f3digo. ... for rowno, row in enumerate(rows, start=1): try: ... except ValueError: print(f'Row {rowno}: Bad row: {row}')","title":"Ejercicio 2.15: Un ejemplo pr\u00e1ctico de enumerate()"},{"location":"02_Working_with_data/04_Sequences/#ejercicio-216-uso-de-la-funcion-zip","text":"En el archivo Data/portfolio.csv , la primera l\u00ednea contiene encabezados de columna. En todo el c\u00f3digo anterior, los hemos estado descartando. >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> Pero \u00bfqu\u00e9 pasar\u00eda si pudieses usar los encabezados para algo \u00fatil? Aqu\u00ed es donde entra en escena la funci\u00f3n zip() . Primero intente esto para emparejar los encabezados de archivo con una fila de datos: >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> list(zip(headers, row)) [ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ] >>> Observe c\u00f3mo zip() emparej\u00f3 los encabezados de columna con los valores de columna. Aqu\u00ed usamos list() para convertir el resultado en una lista para que puedas verlo. Normalmente, zip() crea un iterador que debe ser consumido por un bucle for. Este emparejamiento es un paso intermedio para construir un diccionario. Ahora prueba esto: >>> record = dict(zip(headers, row)) >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Esta transformaci\u00f3n es uno de los trucos m\u00e1s \u00fatiles que debemos conocer al procesar muchos archivos de datos. Por ejemplo, supongamos que desea hacer que el programa pcost.py funcione con varios archivos de entrada, pero sin tener en cuenta el n\u00famero de columna real donde aparecen el nombre, las acciones y el precio. Modifique la funci\u00f3n portfolio_cost() en pcost.py para que se vea as\u00ed: # pcost.py def portfolio_cost(filename): ... for rowno, row in enumerate(rows, start=1): record = dict(zip(headers, row)) try: nshares = int(record['shares']) price = float(record['price']) total_cost += nshares * price # Esto detecta errores en las conversiones int() y float() anteriores except ValueError: print(f'Row {rowno}: Bad row: {row}') ... Ahora, prueba tu funci\u00f3n en un archivo de datos completamente diferente Data/portfoliodate.csv que se ve as\u00ed: name,date,time,shares,price \"AA\",\"6/11/2007\",\"9:50am\",100,32.20 \"IBM\",\"5/13/2007\",\"4:20pm\",50,91.10 \"CAT\",\"9/23/2006\",\"1:30pm\",150,83.44 \"MSFT\",\"5/17/2007\",\"10:30am\",200,51.23 \"GE\",\"2/1/2006\",\"10:45am\",95,40.37 \"MSFT\",\"10/31/2006\",\"12:05pm\",50,65.10 \"IBM\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> portfolio_cost('Data/portfoliodate.csv') 44671.15 >>> Si lo hiciste bien, descubrir\u00e1s que tu programa a\u00fan funciona. aunque el archivo de datos tiene un formato de columna completamente diferente al anterior. \u00a1Eso es genial! El cambio realizado aqu\u00ed es sutil, pero significativo. En lugar de que portfolio_cost() est\u00e9 codificado para leer un \u00fanico formato de archivo fijo, la nueva versi\u00f3n lee cualquier archivo CSV y selecciona los valores de inter\u00e9s. Siempre que el archivo tenga las columnas requeridas, el c\u00f3digo funcionar\u00e1. Modifique el programa report.py que escribi\u00f3 en la Secci\u00f3n 2.3 para que utilice la misma t\u00e9cnica para seleccionar los encabezados de columna. Intente ejecutar el programa report.py en el archivo Data/portfoliodate.csv y ver\u00e1 que produce la misma respuesta que antes.","title":"Ejercicio 2.16: Uso de la funci\u00f3n zip()"},{"location":"02_Working_with_data/04_Sequences/#ejercicio-217-invertir-un-diccionario","text":"Un diccionario asigna claves a valores. Por ejemplo, un diccionario de precios de acciones. >>> prices = { 'GOOG' : 490.1, 'AA' : 23.45, 'IBM' : 91.1, 'MSFT' : 34.23 } >>> Si utiliza el m\u00e9todo items() , puede obtener pares (clave, valor) : >>> prices.items() dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)]) >>> Sin embargo, \u00bfqu\u00e9 sucede si desea obtener una lista de pares '(valor, clave)'? Sugerencia: use zip() . >>> pricelist = list(zip(prices.values(),prices.keys())) >>> pricelist [(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')] >>> \u00bfPor qu\u00e9 har\u00edas esto? En primer lugar, permite realizar cierto tipo de procesamiento con los datos del diccionario. >>> min(pricelist) (23.45, 'AA') >>> max(pricelist) (490.1, 'GOOG') >>> sorted(pricelist) [(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')] >>> Esto tambi\u00e9n ilustra una caracter\u00edstica importante de las tuplas. Cuando se utilizan en comparaciones, las tuplas se comparan elemento por elemento comenzando con el primer elemento. Similar a c\u00f3mo se comparan cadenas, car\u00e1cter por car\u00e1cter. zip() se usa a menudo en situaciones como \u00e9sta, donde es necesario emparejar datos de diferentes lugares. Por ejemplo, emparejar los nombres de las columnas con los valores de las columnas para crear un diccionario de valores con nombre. Tenga en cuenta que zip() no est\u00e1 limitado a pares. Por ejemplo, puedes usarlo con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Adem\u00e1s, tenga en cuenta que zip() se detiene una vez que se agota la secuencia de entrada m\u00e1s corta. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>> Contenido | Anterior (2.3 Salida con formato) | Pr\u00f3ximo (2.5 M\u00f3dulo Collections)","title":"Ejercicio 2.17: Invertir un diccionario"},{"location":"02_Working_with_data/05_Collections/","text":"Contenido | Anterior (2.4 Secuencias) | Pr\u00f3ximo (2.6 Listas por comprensi\u00f3n) 2.5 M\u00f3dulo collections El m\u00f3dulo collections proporciona una serie de objetos \u00fatiles para el manejo de datos. En esta parte se presentan brevemente algunas de estas caracter\u00edsticas. Ejemplo: Contar cosas Digamos que desea tabular el total de acciones de cada acci\u00f3n. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Hay dos entradas 'IBM' y dos entradas 'GOOG' en esta lista. Las acciones deben combinarse de alguna manera. Contadores Soluci\u00f3n: Utilice un Counter . from collections import Counter total_shares = Counter() for name, shares, price in portfolio: total_shares[name] += shares total_shares['IBM'] # 150 Ejemplo: Asignaciones de uno a muchos Problema: desea asignar una clave a m\u00faltiples valores. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Al igual que en el ejemplo anterior, la clave 'IBM' deber\u00eda tener dos tuplas diferentes. Soluci\u00f3n: utilice un defaultdict . from collections import defaultdict holdings = defaultdict(list) for name, shares, price in portfolio: holdings[name].append((shares, price)) holdings['IBM'] # [ (50, 91.1), (100, 45.23) ] defaultdict garantiza que cada vez que accedas a una clave obtendr\u00e1s un valor predeterminado. Ejemplo: Mantener un historial Problema: Queremos un historial de las \u00faltimas N cosas. Soluci\u00f3n: utilice deque . from collections import deque history = deque(maxlen=N) with open(filename) as f: for line in f: history.append(line) ... Abre un archivo cuyo nombre est\u00e1 en la variable filename para lectura. Lee el archivo l\u00ednea por l\u00ednea. A\u00f1ade cada l\u00ednea al deque llamado history . De esta manera, al finalizar, el deque history contendr\u00e1 las \u00faltimas N l\u00edneas del archivo. Si el archivo tiene menos de N l\u00edneas, contendr\u00e1 todas las l\u00edneas del archivo. Si tiene m\u00e1s de N l\u00edneas, solo contendr\u00e1 las \u00faltimas N l\u00edneas debido al l\u00edmite m\u00e1ximo establecido. Ejercicios El m\u00f3dulo collections podr\u00eda ser uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles para tratar problemas de manejo de datos de prop\u00f3sitos especiales, tales como tabulaci\u00f3n e indexaci\u00f3n. En este ejercicio, veremos algunos ejemplos sencillos. Comience ejecutando su programa report.py para que tenga la cartera de acciones cargada en modo interactivo. bash % python3 -i report.py Ejercicio 2.18: Tabulaci\u00f3n con contadores Supongamos que desea tabular la tenencia total de cada acci\u00f3n. Esto es f\u00e1cil usando objetos 'Counter'. Pru\u00e9balo: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> from collections import Counter >>> holdings = Counter() >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> Observe atentamente c\u00f3mo las entradas m\u00faltiples para 'MSFT' e 'IBM' en portafolio se combinan en una sola entrada aqu\u00ed. Puedes utilizar un contador como si fuera un diccionario para recuperar valores individuales: >>> holdings['IBM'] 150 >>> holdings['MSFT'] 250 >>> Si desea clasificar los valores, haga lo siguiente: >>> # Obtenga las tres acciones m\u00e1s importantes >>> holdings.most_common(3) [('MSFT', 250), ('IBM', 150), ('CAT', 150)] >>> Tomemos otra cartera de acciones y construyamos un nuevo contador: >>> portfolio2 = read_portfolio('Data/portfolio2.csv') >>> holdings2 = Counter() >>> for s in portfolio2: holdings2[s['name']] += s['shares'] >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> Por \u00faltimo, combinemos todos los activos realizando una sencilla operaci\u00f3n: >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> combined = holdings + holdings2 >>> combined Counter({'MSFT': 275, 'HPQ': 250, 'GE': 220, 'AA': 150, 'IBM': 150, 'CAT': 150}) >>> Esto es s\u00f3lo una peque\u00f1a muestra de lo que los contadores ofrecen. Sin embargo, si alguna vez necesitas tabular valores, deber\u00edas considerar usar uno. Comentario: m\u00f3dulo Collections El m\u00f3dulo collections es uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles de todo Python. De hecho, podr\u00edamos hacer un tutorial extenso s\u00f3lo sobre eso. Sin embargo, hacerlo ahora tambi\u00e9n ser\u00eda una distracci\u00f3n. Por ahora, pon collections en tu lista de lectura para antes de dormir, para m\u00e1s tarde. Contenido | Anterior (2.4 Secuencias) | Pr\u00f3ximo (2.6 Listas por comprensi\u00f3n)","title":"05_Collections"},{"location":"02_Working_with_data/05_Collections/#25-modulo-collections","text":"El m\u00f3dulo collections proporciona una serie de objetos \u00fatiles para el manejo de datos. En esta parte se presentan brevemente algunas de estas caracter\u00edsticas.","title":"2.5 M\u00f3dulo collections"},{"location":"02_Working_with_data/05_Collections/#ejemplo-contar-cosas","text":"Digamos que desea tabular el total de acciones de cada acci\u00f3n. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Hay dos entradas 'IBM' y dos entradas 'GOOG' en esta lista. Las acciones deben combinarse de alguna manera.","title":"Ejemplo: Contar cosas"},{"location":"02_Working_with_data/05_Collections/#contadores","text":"Soluci\u00f3n: Utilice un Counter . from collections import Counter total_shares = Counter() for name, shares, price in portfolio: total_shares[name] += shares total_shares['IBM'] # 150","title":"Contadores"},{"location":"02_Working_with_data/05_Collections/#ejemplo-asignaciones-de-uno-a-muchos","text":"Problema: desea asignar una clave a m\u00faltiples valores. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Al igual que en el ejemplo anterior, la clave 'IBM' deber\u00eda tener dos tuplas diferentes. Soluci\u00f3n: utilice un defaultdict . from collections import defaultdict holdings = defaultdict(list) for name, shares, price in portfolio: holdings[name].append((shares, price)) holdings['IBM'] # [ (50, 91.1), (100, 45.23) ] defaultdict garantiza que cada vez que accedas a una clave obtendr\u00e1s un valor predeterminado.","title":"Ejemplo: Asignaciones de uno a muchos"},{"location":"02_Working_with_data/05_Collections/#ejemplo-mantener-un-historial","text":"Problema: Queremos un historial de las \u00faltimas N cosas. Soluci\u00f3n: utilice deque . from collections import deque history = deque(maxlen=N) with open(filename) as f: for line in f: history.append(line) ... Abre un archivo cuyo nombre est\u00e1 en la variable filename para lectura. Lee el archivo l\u00ednea por l\u00ednea. A\u00f1ade cada l\u00ednea al deque llamado history . De esta manera, al finalizar, el deque history contendr\u00e1 las \u00faltimas N l\u00edneas del archivo. Si el archivo tiene menos de N l\u00edneas, contendr\u00e1 todas las l\u00edneas del archivo. Si tiene m\u00e1s de N l\u00edneas, solo contendr\u00e1 las \u00faltimas N l\u00edneas debido al l\u00edmite m\u00e1ximo establecido.","title":"Ejemplo: Mantener un historial"},{"location":"02_Working_with_data/05_Collections/#ejercicios","text":"El m\u00f3dulo collections podr\u00eda ser uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles para tratar problemas de manejo de datos de prop\u00f3sitos especiales, tales como tabulaci\u00f3n e indexaci\u00f3n. En este ejercicio, veremos algunos ejemplos sencillos. Comience ejecutando su programa report.py para que tenga la cartera de acciones cargada en modo interactivo. bash % python3 -i report.py","title":"Ejercicios"},{"location":"02_Working_with_data/05_Collections/#ejercicio-218-tabulacion-con-contadores","text":"Supongamos que desea tabular la tenencia total de cada acci\u00f3n. Esto es f\u00e1cil usando objetos 'Counter'. Pru\u00e9balo: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> from collections import Counter >>> holdings = Counter() >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> Observe atentamente c\u00f3mo las entradas m\u00faltiples para 'MSFT' e 'IBM' en portafolio se combinan en una sola entrada aqu\u00ed. Puedes utilizar un contador como si fuera un diccionario para recuperar valores individuales: >>> holdings['IBM'] 150 >>> holdings['MSFT'] 250 >>> Si desea clasificar los valores, haga lo siguiente: >>> # Obtenga las tres acciones m\u00e1s importantes >>> holdings.most_common(3) [('MSFT', 250), ('IBM', 150), ('CAT', 150)] >>> Tomemos otra cartera de acciones y construyamos un nuevo contador: >>> portfolio2 = read_portfolio('Data/portfolio2.csv') >>> holdings2 = Counter() >>> for s in portfolio2: holdings2[s['name']] += s['shares'] >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> Por \u00faltimo, combinemos todos los activos realizando una sencilla operaci\u00f3n: >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> combined = holdings + holdings2 >>> combined Counter({'MSFT': 275, 'HPQ': 250, 'GE': 220, 'AA': 150, 'IBM': 150, 'CAT': 150}) >>> Esto es s\u00f3lo una peque\u00f1a muestra de lo que los contadores ofrecen. Sin embargo, si alguna vez necesitas tabular valores, deber\u00edas considerar usar uno.","title":"Ejercicio 2.18: Tabulaci\u00f3n con contadores"},{"location":"02_Working_with_data/05_Collections/#comentario-modulo-collections","text":"El m\u00f3dulo collections es uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles de todo Python. De hecho, podr\u00edamos hacer un tutorial extenso s\u00f3lo sobre eso. Sin embargo, hacerlo ahora tambi\u00e9n ser\u00eda una distracci\u00f3n. Por ahora, pon collections en tu lista de lectura para antes de dormir, para m\u00e1s tarde. Contenido | Anterior (2.4 Secuencias) | Pr\u00f3ximo (2.6 Listas por comprensi\u00f3n)","title":"Comentario: m\u00f3dulo Collections"},{"location":"02_Working_with_data/06_List_comprehension/","text":"Contenido | Anterior (2.5 Collections) | Pr\u00f3ximo (2.7 Objetos) 2.6 Listas por comprensi\u00f3n Una tarea com\u00fan es procesar elementos de una lista. Esta secci\u00f3n presenta las listas por comprensi\u00f3n, una herramienta poderosa para hacer precisamente eso. Creando nuevas listas Una lista por comprensi\u00f3n crea una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a ] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> names = ['Elwood', 'Jake'] >>> a = [name.lower() for name in names] >>> a ['elwood', 'jake'] >>> La sintaxis general es: [ <expresi\u00f3n> for <nombre_de_variable> in <secuencia> ] . Filtrado Tambi\u00e9n puedes filtrar durante la listas por comprensi\u00f3n. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0 ] >>> b [2, 8, 4, 20] >>> Casos de uso Las listas por comprensi\u00f3n son muy \u00fatiles. Por ejemplo, puede recopilar valores de un diccionario espec\u00edfico: stocknames = [s['name'] for s in stocks] Puede realizar consultas similares a bases de datos en secuencias. a = [s for s in stocks if s['price'] > 100 and s['shares'] > 50 ] Tambi\u00e9n puedes combinar una lista por comprensi\u00f3n con una reducci\u00f3n de secuencia: cost = sum([s['shares']*s['price'] for s in stocks]) Sintaxis general [ <expresi\u00f3n> for <nombre_de_variable> in <secuencia> if <condici\u00f3n>] lo que significa: result = [] for nombre_de_variable in secuencia: if condici\u00f3n: result.append(expresi\u00f3n) Digresi\u00f3n hist\u00f3rica Las listas por comprensi\u00f3n provienen de las matem\u00e1ticas (notaci\u00f3n de construcci\u00f3n de conjuntos). a = [ x * x for x in s if x > 0 ] # Python a = { x^2 | x \u2208 s, x > 0 } # Matem\u00e1tica Tambi\u00e9n est\u00e1 implementado en varios otros lenguajes. Aunque la mayor\u00eda de los programadores probablemente no est\u00e9n pensando en sus clases de matem\u00e1ticas. No obstante, est\u00e1 bien verlo como un interesante atajo para crear listas. Ejercicios Comience ejecutando su programa report.py para que tenga la Cartera de acciones cargadas en el modo interactivo. bash % python3 -i report.py Ahora, en modo interactivo de Python, escriba instrucciones para realizar la operaciones que se describen a continuaci\u00f3n. Estas operaciones realizan varios tipos de reducciones de datos, transformaciones y consultas sobre los datos de la cartera. Ejercicio 2.19: Listas por Comprensi\u00f3n Pruebe algunas listas por comprensi\u00f3n simples solo para familiarizarse con la sintaxis. >>> nums = [1,2,3,4] >>> squares = [ x * x for x in nums ] >>> squares [1, 4, 9, 16] >>> twice = [ 2 * x for x in nums if x > 2 ] >>> twice [6, 8] >>> Observe c\u00f3mo las listas por comprensi\u00f3n crean una nueva lista con los datos adecuadamente transformados o filtrados. Ejercicio 2.20: Reducciones de secuencias Calcule el costo total de la cartera utilizando una \u00fanica declaraci\u00f3n de Python. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> cost = sum([ s['shares'] * s['price'] for s in portfolio ]) >>> cost 44671.15 >>> Despu\u00e9s de haber hecho esto, muestra c\u00f3mo puedes calcular el valor actual. de la cartera mediante un \u00fanico enunciado. >>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ]) >>> value 28686.1 >>> Ambas operaciones anteriores son un ejemplo de reducci\u00f3n de mapa. Las listas por comprensi\u00f3n consisten en mapear una operaci\u00f3n a lo largo de la lista. >>> [ s['shares'] * s['price'] for s in portfolio ] [3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La funci\u00f3n sum() realiza entonces una reducci\u00f3n en el resultado: >>> sum(_) 44671.15 >>> Con este conocimiento, ahora est\u00e1s listo para lanzar una empresa emergente de big data. Ejercicio 2.21: Consultas de datos Pruebe los siguientes ejemplos de varias consultas de datos. En primer lugar, una lista de todas las tenencias de cartera con m\u00e1s de 100 acciones. >>> more100 = [ s for s in portfolio if s['shares'] > 100 ] >>> more100 [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Todas las tenencias de cartera de acciones de MSFT e IBM. >>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ] >>> msftibm [{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> Una lista de todas las tenencias de acciones que cuestan m\u00e1s de $10000. >>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ] >>> cost10k [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Ejercicio 2.22: Extracci\u00f3n de datos Muestra c\u00f3mo podr\u00edas construir una lista de tuplas (name, shares) donde name y shares se toman de portfolio . >>> name_shares =[ (s['name'], s['shares']) for s in portfolio ] >>> name_shares [('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)] >>> Si cambias los corchetes ( [ , ] ) por llaves ( { , } ), obtienes algo conocido como comprensi\u00f3n de conjunto. Esto le proporciona valores \u00fanicos o distintos. Por ejemplo, esto determina el conjunto de nombres de acciones \u00fanicos que aparecen en portafolio : >>> names = { s['name'] for s in portfolio } >>> names { 'AA', 'GE', 'IBM', 'MSFT', 'CAT' } >>> Si especifica pares clave:valor , puede crear un diccionario. Por ejemplo, crear un diccionario que asigne el nombre de una acci\u00f3n al n\u00famero total de acciones que posee. >>> holdings = { name: 0 for name in names } >>> holdings {'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0} >>> Esta \u00faltima caracter\u00edstica se conoce como diccionario por comprensi\u00f3n . Vamos a tabular: >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings { 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 } >>> Pruebe este ejemplo que filtra el diccionario de prices solo a aquellos nombres que aparecen en la cartera: >>> names >>> portfolio_prices = { name: prices[name] for name in names } >>> portfolio_prices {'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46} >>> Ejercicio 2.23: Extracci\u00f3n de datos de archivos CSV Saber c\u00f3mo utilizar diversas combinaciones de listas, conjuntos y diccionarios puede ser \u00fatil en diversas formas de procesamiento de datos. A continuaci\u00f3n se muestra un ejemplo que muestra c\u00f3mo extraer columnas seleccionadas de un archivo CSV. Primero, lea una fila de informaci\u00f3n de encabezado de un archivo CSV: >>> import csv >>> f = open('Data/portfoliodate.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'date', 'time', 'shares', 'price'] >>> A continuaci\u00f3n, defina una variable que enumere las columnas que realmente le interesan: >>> select = ['name', 'shares', 'price'] >>> Ahora, ubique los \u00edndices de las columnas anteriores en el archivo CSV de origen: >>> indices = [ headers.index(colname) for colname in select ] >>> indices [0, 3, 4] >>> Por \u00faltimo, lea una fila de datos y convi\u00e9rtala en un diccionario utilizando un diccionario por comprensi\u00f3n: >>> row = next(rows) >>> record = { colname: row[index] for colname, index in zip(select, indices) } # dict-comprehension >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Si te sientes c\u00f3modo con lo que acaba de pasar, lee el resto del archivo: >>> portfolio = [ { colname: row[index] for colname, index in zip(select, indices) } for row in rows ] >>> portfolio [{'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Vaya, acabas de reducir gran parte de la funci\u00f3n read_portfolio() a una sola declaraci\u00f3n. Comentario Las listas por comprensi\u00f3n se utilizan com\u00fanmente en Python como un medio eficiente para transformar, filtrar o recopilar datos. Debido a la sintaxis, no conviene exagerar: intenta que cada lista por comprensi\u00f3n sea lo m\u00e1s simple posible. Est\u00e1 bien dividir las cosas en varios pasos. Por ejemplo, no est\u00e1 claro que usted quiera soltar ese \u00faltimo ejemplo ante sus desprevenidos compa\u00f1eros de trabajo. Dicho esto, saber c\u00f3mo manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Existen numerosas situaciones en las que podr\u00eda ser necesario resolver alg\u00fan tipo de problema puntual relacionado con la importaci\u00f3n, exportaci\u00f3n, extracci\u00f3n de datos, etc. Convertirse en un maestro de las listas por comprensi\u00f3n puede reducir sustancialmente el tiempo empleado en idear una soluci\u00f3n. Adem\u00e1s, no te olvides del m\u00f3dulo collections . Contenido | Anterior (2.5 M\u00f3dulo collections) | Pr\u00f3ximo (2.7 Modelo de objetos)","title":"06_List_comprehension"},{"location":"02_Working_with_data/06_List_comprehension/#26-listas-por-comprension","text":"Una tarea com\u00fan es procesar elementos de una lista. Esta secci\u00f3n presenta las listas por comprensi\u00f3n, una herramienta poderosa para hacer precisamente eso.","title":"2.6 Listas por comprensi\u00f3n"},{"location":"02_Working_with_data/06_List_comprehension/#creando-nuevas-listas","text":"Una lista por comprensi\u00f3n crea una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a ] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> names = ['Elwood', 'Jake'] >>> a = [name.lower() for name in names] >>> a ['elwood', 'jake'] >>> La sintaxis general es: [ <expresi\u00f3n> for <nombre_de_variable> in <secuencia> ] .","title":"Creando nuevas listas"},{"location":"02_Working_with_data/06_List_comprehension/#filtrado","text":"Tambi\u00e9n puedes filtrar durante la listas por comprensi\u00f3n. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0 ] >>> b [2, 8, 4, 20] >>>","title":"Filtrado"},{"location":"02_Working_with_data/06_List_comprehension/#casos-de-uso","text":"Las listas por comprensi\u00f3n son muy \u00fatiles. Por ejemplo, puede recopilar valores de un diccionario espec\u00edfico: stocknames = [s['name'] for s in stocks] Puede realizar consultas similares a bases de datos en secuencias. a = [s for s in stocks if s['price'] > 100 and s['shares'] > 50 ] Tambi\u00e9n puedes combinar una lista por comprensi\u00f3n con una reducci\u00f3n de secuencia: cost = sum([s['shares']*s['price'] for s in stocks])","title":"Casos de uso"},{"location":"02_Working_with_data/06_List_comprehension/#sintaxis-general","text":"[ <expresi\u00f3n> for <nombre_de_variable> in <secuencia> if <condici\u00f3n>] lo que significa: result = [] for nombre_de_variable in secuencia: if condici\u00f3n: result.append(expresi\u00f3n)","title":"Sintaxis general"},{"location":"02_Working_with_data/06_List_comprehension/#digresion-historica","text":"Las listas por comprensi\u00f3n provienen de las matem\u00e1ticas (notaci\u00f3n de construcci\u00f3n de conjuntos). a = [ x * x for x in s if x > 0 ] # Python a = { x^2 | x \u2208 s, x > 0 } # Matem\u00e1tica Tambi\u00e9n est\u00e1 implementado en varios otros lenguajes. Aunque la mayor\u00eda de los programadores probablemente no est\u00e9n pensando en sus clases de matem\u00e1ticas. No obstante, est\u00e1 bien verlo como un interesante atajo para crear listas.","title":"Digresi\u00f3n hist\u00f3rica"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicios","text":"Comience ejecutando su programa report.py para que tenga la Cartera de acciones cargadas en el modo interactivo. bash % python3 -i report.py Ahora, en modo interactivo de Python, escriba instrucciones para realizar la operaciones que se describen a continuaci\u00f3n. Estas operaciones realizan varios tipos de reducciones de datos, transformaciones y consultas sobre los datos de la cartera.","title":"Ejercicios"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicio-219-listas-por-comprension","text":"Pruebe algunas listas por comprensi\u00f3n simples solo para familiarizarse con la sintaxis. >>> nums = [1,2,3,4] >>> squares = [ x * x for x in nums ] >>> squares [1, 4, 9, 16] >>> twice = [ 2 * x for x in nums if x > 2 ] >>> twice [6, 8] >>> Observe c\u00f3mo las listas por comprensi\u00f3n crean una nueva lista con los datos adecuadamente transformados o filtrados.","title":"Ejercicio 2.19: Listas por Comprensi\u00f3n"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicio-220-reducciones-de-secuencias","text":"Calcule el costo total de la cartera utilizando una \u00fanica declaraci\u00f3n de Python. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> cost = sum([ s['shares'] * s['price'] for s in portfolio ]) >>> cost 44671.15 >>> Despu\u00e9s de haber hecho esto, muestra c\u00f3mo puedes calcular el valor actual. de la cartera mediante un \u00fanico enunciado. >>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ]) >>> value 28686.1 >>> Ambas operaciones anteriores son un ejemplo de reducci\u00f3n de mapa. Las listas por comprensi\u00f3n consisten en mapear una operaci\u00f3n a lo largo de la lista. >>> [ s['shares'] * s['price'] for s in portfolio ] [3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La funci\u00f3n sum() realiza entonces una reducci\u00f3n en el resultado: >>> sum(_) 44671.15 >>> Con este conocimiento, ahora est\u00e1s listo para lanzar una empresa emergente de big data.","title":"Ejercicio 2.20: Reducciones de secuencias"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicio-221-consultas-de-datos","text":"Pruebe los siguientes ejemplos de varias consultas de datos. En primer lugar, una lista de todas las tenencias de cartera con m\u00e1s de 100 acciones. >>> more100 = [ s for s in portfolio if s['shares'] > 100 ] >>> more100 [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Todas las tenencias de cartera de acciones de MSFT e IBM. >>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ] >>> msftibm [{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> Una lista de todas las tenencias de acciones que cuestan m\u00e1s de $10000. >>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ] >>> cost10k [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>>","title":"Ejercicio 2.21: Consultas de datos"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicio-222-extraccion-de-datos","text":"Muestra c\u00f3mo podr\u00edas construir una lista de tuplas (name, shares) donde name y shares se toman de portfolio . >>> name_shares =[ (s['name'], s['shares']) for s in portfolio ] >>> name_shares [('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)] >>> Si cambias los corchetes ( [ , ] ) por llaves ( { , } ), obtienes algo conocido como comprensi\u00f3n de conjunto. Esto le proporciona valores \u00fanicos o distintos. Por ejemplo, esto determina el conjunto de nombres de acciones \u00fanicos que aparecen en portafolio : >>> names = { s['name'] for s in portfolio } >>> names { 'AA', 'GE', 'IBM', 'MSFT', 'CAT' } >>> Si especifica pares clave:valor , puede crear un diccionario. Por ejemplo, crear un diccionario que asigne el nombre de una acci\u00f3n al n\u00famero total de acciones que posee. >>> holdings = { name: 0 for name in names } >>> holdings {'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0} >>> Esta \u00faltima caracter\u00edstica se conoce como diccionario por comprensi\u00f3n . Vamos a tabular: >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings { 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 } >>> Pruebe este ejemplo que filtra el diccionario de prices solo a aquellos nombres que aparecen en la cartera: >>> names >>> portfolio_prices = { name: prices[name] for name in names } >>> portfolio_prices {'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46} >>>","title":"Ejercicio 2.22: Extracci\u00f3n de datos"},{"location":"02_Working_with_data/06_List_comprehension/#ejercicio-223-extraccion-de-datos-de-archivos-csv","text":"Saber c\u00f3mo utilizar diversas combinaciones de listas, conjuntos y diccionarios puede ser \u00fatil en diversas formas de procesamiento de datos. A continuaci\u00f3n se muestra un ejemplo que muestra c\u00f3mo extraer columnas seleccionadas de un archivo CSV. Primero, lea una fila de informaci\u00f3n de encabezado de un archivo CSV: >>> import csv >>> f = open('Data/portfoliodate.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'date', 'time', 'shares', 'price'] >>> A continuaci\u00f3n, defina una variable que enumere las columnas que realmente le interesan: >>> select = ['name', 'shares', 'price'] >>> Ahora, ubique los \u00edndices de las columnas anteriores en el archivo CSV de origen: >>> indices = [ headers.index(colname) for colname in select ] >>> indices [0, 3, 4] >>> Por \u00faltimo, lea una fila de datos y convi\u00e9rtala en un diccionario utilizando un diccionario por comprensi\u00f3n: >>> row = next(rows) >>> record = { colname: row[index] for colname, index in zip(select, indices) } # dict-comprehension >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Si te sientes c\u00f3modo con lo que acaba de pasar, lee el resto del archivo: >>> portfolio = [ { colname: row[index] for colname, index in zip(select, indices) } for row in rows ] >>> portfolio [{'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Vaya, acabas de reducir gran parte de la funci\u00f3n read_portfolio() a una sola declaraci\u00f3n.","title":"Ejercicio 2.23: Extracci\u00f3n de datos de archivos CSV"},{"location":"02_Working_with_data/06_List_comprehension/#comentario","text":"Las listas por comprensi\u00f3n se utilizan com\u00fanmente en Python como un medio eficiente para transformar, filtrar o recopilar datos. Debido a la sintaxis, no conviene exagerar: intenta que cada lista por comprensi\u00f3n sea lo m\u00e1s simple posible. Est\u00e1 bien dividir las cosas en varios pasos. Por ejemplo, no est\u00e1 claro que usted quiera soltar ese \u00faltimo ejemplo ante sus desprevenidos compa\u00f1eros de trabajo. Dicho esto, saber c\u00f3mo manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Existen numerosas situaciones en las que podr\u00eda ser necesario resolver alg\u00fan tipo de problema puntual relacionado con la importaci\u00f3n, exportaci\u00f3n, extracci\u00f3n de datos, etc. Convertirse en un maestro de las listas por comprensi\u00f3n puede reducir sustancialmente el tiempo empleado en idear una soluci\u00f3n. Adem\u00e1s, no te olvides del m\u00f3dulo collections . Contenido | Anterior (2.5 M\u00f3dulo collections) | Pr\u00f3ximo (2.7 Modelo de objetos)","title":"Comentario"},{"location":"02_Working_with_data/07_Objects/","text":"Contenido | Anterior (2.6 Listas por comprensi\u00f3n) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa) 2.7 Objetos Esta secci\u00f3n presenta m\u00e1s detalles sobre el modelo de objetos internos de Python y analiza algunos asuntos relacionados con la administraci\u00f3n de memoria, la copia y la verificaci\u00f3n de tipos. Asignaci\u00f3n Muchas operaciones en Python est\u00e1n relacionadas con la asignaci\u00f3n o almacenamiento de valores. a = value # Asignar a una variable s[n] = value # Asignar a una lista s.append(value) # Anexar a una lista d['key'] = value # Agregar a un diccionario Precauci\u00f3n: las operaciones de asignaci\u00f3n nunca hacen una copia del valor que se est\u00e1 asignando. Todas las asignaciones son simplemente copias de referencia (o copias de puntero si lo prefiere). Ejemplo de asignaci\u00f3n Considere este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] Una imagen de las operaciones de memoria subyacentes. En este ejemplo, solo hay un objeto de lista [1,2,3] , pero hay cuatro referencias diferentes a \u00e9l. Esto significa que modificar un valor afecta a todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observe c\u00f3mo un cambio en la lista original aparece en todos lados (\u00a1vaya!). Esto se debe a que nunca se hicieron copias. Todo apunta a lo mismo. Reasignaci\u00f3n de valores Reasignar un valor nunca sobrescribe la memoria utilizada por el valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Contiene el valor original Recuerde: Las variables son nombres, no ubicaciones de memoria. Algunos peligros Si no sabe sobre este intercambio, en alg\u00fan momento se disparar\u00e1 en el pie. Escenario t\u00edpico. Modifica algunos datos pensando que son su propia copia privada y accidentalmente corrompe algunos datos en alguna otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son inmutables (solo lectura). Identidad y referencias Use el operador is para verificar si dos valores son exactamente el mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (un entero). La identidad se puede obtener usando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Nota: Casi siempre es mejor usar == para verificar objetos. El comportamiento de is suele ser inesperado: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c True >>> Copias superficiales Las listas y los diccionarios tienen m\u00e9todos para copiar. >>> a = [2,3,[100,101],4] >>> b = list(a) # Hacer una copia >>> a is b False Es una lista nueva, pero los elementos de la lista se comparten. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> Por ejemplo, se est\u00e1 compartiendo la lista interna [100, 101, 102] . Esto se conoce como copia superficial. Aqu\u00ed hay una imagen. Copias profundas A veces es necesario hacer una copia de un objeto y de todos los objetos que contiene. Puede utilizar el m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>> Nombres, valores, tipos Los nombres de las variables no tienen un tipo . Son solo un nombre. Sin embargo, los valores s\u00ed tienen un tipo subyacente. >>> a = 42 >>> b = 'Hola Mundo' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() le dir\u00e1 cu\u00e1l es. El nombre del tipo se utiliza generalmente como una funci\u00f3n que crea o convierte un valor a ese tipo. Comprobaci\u00f3n de tipos C\u00f3mo saber si un objeto es de un tipo espec\u00edfico. if isinstance(a, list): print('a es a lista') Comprobaci\u00f3n de uno de los muchos tipos posibles. if isinstance(a, (list,tuple)): print('a es a lista o tupla') Precauci\u00f3n: No se exceda con la comprobaci\u00f3n de tipos. Puede generar una complejidad excesiva en el c\u00f3digo. Por lo general, solo lo har\u00eda si al hacerlo evitara errores comunes que cometen otras personas al usar su c\u00f3digo. Todo es un objeto N\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Esto significa que todos los objetos que se pueden nombrar se pueden pasar como datos, colocar en contenedores, etc., sin ninguna restricci\u00f3n. No hay tipos especiales de objetos. A veces se dice que todos los objetos son \"de primera clase\". Un ejemplo simple: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Fall\u00f3!') Fall\u00f3! >>> Aqu\u00ed, items es una lista que contiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. Puedes usar directamente los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Un gran poder conlleva una responsabilidad. El hecho de que puedas hacer eso no significa que debas hacerlo. Ejercicios En este conjunto de ejercicios, observamos parte del poder que proviene de los objetos de primera clase. Ejercicio 2.24: Datos de primera clase En el archivo Data/portfolio.csv , leemos datos organizados en columnas que se ven as\u00ed: name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... En el c\u00f3digo anterior, usamos el m\u00f3dulo csv para leer el archivo, pero a\u00fan as\u00ed tuvimos que realizar conversiones de tipo manuales. Por ejemplo: ```python for row in rows: name = row[0] shares = int(row[1]) price = float(row[2]) ``` Este tipo de conversi\u00f3n tambi\u00e9n se puede realizar de una manera m\u00e1s inteligente utilizando algunas operaciones b\u00e1sicas de lista. Haz una lista de Python que contenga los nombres de las funciones de conversi\u00f3n que usar\u00edas para convertir cada columna al tipo apropiado: >>> types = [str, int, float] >>> La raz\u00f3n por la que puedes crear esta lista es que todo en Python es de primera clase . Por lo tanto, si quieres tener una lista de funciones, est\u00e1 bien. Los elementos de la lista que creaste son funciones para convertir un valor x en un tipo determinado (por ejemplo, str(x) , int(x) , float(x) ). Ahora, lee una fila de datos del archivo anterior: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Como se se\u00f1al\u00f3, esta fila no es suficiente para realizar los c\u00e1lculos porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiplicar sequence by non-int of type 'str' >>> Sin embargo, tal vez los datos se puedan emparejar con los tipos que especificaste en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Intenta convertir uno de los valores: >>> types[1](row[1]) # Igual que int(row[1]) 100 >>> Intenta convertir un valor diferente: >>> types[2](row[2]) # Igual que float(row[2]) 32.2 >>> Intenta el c\u00e1lculo con valores convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Comprime los tipos de columna con los campos y mira el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Notar\u00e1s que esto ha emparejado una conversi\u00f3n de tipo con un valor. Por ejemplo, int est\u00e1 emparejado con el valor '100' . La lista por compresi\u00f3n es \u00fatil si quieres realizar conversiones en todos los valores, uno despu\u00e9s del otro. Prueba esto: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['AA', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Aseg\u00farate de entender lo que est\u00e1 sucediendo en el c\u00f3digo anterior. En el bucle, la variable func es una de las funciones de conversi\u00f3n de tipo (p. ej., str , int , etc.) y la variable val es uno de los valores como 'AA' , '100' . La expresi\u00f3n func(val) convierte un valor (algo as\u00ed como una conversi\u00f3n de tipo). El c\u00f3digo anterior se puede comprimir en una \u00fanica lista por comprensi\u00f3n. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['AA', 100, 32.2] >>> Ejercicio 2.25: Creaci\u00f3n de diccionarios \u00bfRecuerdas c\u00f3mo la funci\u00f3n dict() puede crear f\u00e1cilmente un diccionario si tienes una secuencia de nombres y valores de claves? Hagamos un diccionario a partir de los encabezados de las columnas: >>> headers ['name', 'shares', 'price'] >>> converted ['AA', 100, 32.2] >>> dict(zip(headers, converted)) {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Por supuesto, si ya tienes experiencia con las listas por comprensi\u00f3n, puedes hacer toda la conversi\u00f3n en un solo paso usando una comprensi\u00f3n de diccionarios: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Ejercicio 2.26: El panorama general Si utiliza las t\u00e9cnicas de este ejercicio, podr\u00e1 escribir instrucciones que conviertan f\u00e1cilmente los campos de casi cualquier archivo de datos orientado a columnas en un diccionario de Python. Solo para ilustrar, supongamos que lees datos de un archivo de datos diferente como este: >>> f = open('Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos los campos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Bonificaci\u00f3n: \u00bfC\u00f3mo modificar\u00edas este ejemplo para que sea adicional? \u00bfC\u00f3mo analizar la entrada date en una tupla como (6, 11, 2007) ? Dedica un tiempo a reflexionar sobre lo que has hecho en este ejercicio. Volveremos a tratar estas ideas un poco m\u00e1s adelante. Contenido | Anterior (2.6 Listas por comprensi\u00f3n) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa)","title":"07_Objects"},{"location":"02_Working_with_data/07_Objects/#27-objetos","text":"Esta secci\u00f3n presenta m\u00e1s detalles sobre el modelo de objetos internos de Python y analiza algunos asuntos relacionados con la administraci\u00f3n de memoria, la copia y la verificaci\u00f3n de tipos.","title":"2.7 Objetos"},{"location":"02_Working_with_data/07_Objects/#asignacion","text":"Muchas operaciones en Python est\u00e1n relacionadas con la asignaci\u00f3n o almacenamiento de valores. a = value # Asignar a una variable s[n] = value # Asignar a una lista s.append(value) # Anexar a una lista d['key'] = value # Agregar a un diccionario Precauci\u00f3n: las operaciones de asignaci\u00f3n nunca hacen una copia del valor que se est\u00e1 asignando. Todas las asignaciones son simplemente copias de referencia (o copias de puntero si lo prefiere).","title":"Asignaci\u00f3n"},{"location":"02_Working_with_data/07_Objects/#ejemplo-de-asignacion","text":"Considere este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] Una imagen de las operaciones de memoria subyacentes. En este ejemplo, solo hay un objeto de lista [1,2,3] , pero hay cuatro referencias diferentes a \u00e9l. Esto significa que modificar un valor afecta a todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observe c\u00f3mo un cambio en la lista original aparece en todos lados (\u00a1vaya!). Esto se debe a que nunca se hicieron copias. Todo apunta a lo mismo.","title":"Ejemplo de asignaci\u00f3n"},{"location":"02_Working_with_data/07_Objects/#reasignacion-de-valores","text":"Reasignar un valor nunca sobrescribe la memoria utilizada por el valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Contiene el valor original Recuerde: Las variables son nombres, no ubicaciones de memoria.","title":"Reasignaci\u00f3n de valores"},{"location":"02_Working_with_data/07_Objects/#algunos-peligros","text":"Si no sabe sobre este intercambio, en alg\u00fan momento se disparar\u00e1 en el pie. Escenario t\u00edpico. Modifica algunos datos pensando que son su propia copia privada y accidentalmente corrompe algunos datos en alguna otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son inmutables (solo lectura).","title":"Algunos peligros"},{"location":"02_Working_with_data/07_Objects/#identidad-y-referencias","text":"Use el operador is para verificar si dos valores son exactamente el mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (un entero). La identidad se puede obtener usando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Nota: Casi siempre es mejor usar == para verificar objetos. El comportamiento de is suele ser inesperado: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c True >>>","title":"Identidad y referencias"},{"location":"02_Working_with_data/07_Objects/#copias-superficiales","text":"Las listas y los diccionarios tienen m\u00e9todos para copiar. >>> a = [2,3,[100,101],4] >>> b = list(a) # Hacer una copia >>> a is b False Es una lista nueva, pero los elementos de la lista se comparten. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> Por ejemplo, se est\u00e1 compartiendo la lista interna [100, 101, 102] . Esto se conoce como copia superficial. Aqu\u00ed hay una imagen.","title":"Copias superficiales"},{"location":"02_Working_with_data/07_Objects/#copias-profundas","text":"A veces es necesario hacer una copia de un objeto y de todos los objetos que contiene. Puede utilizar el m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>>","title":"Copias profundas"},{"location":"02_Working_with_data/07_Objects/#nombres-valores-tipos","text":"Los nombres de las variables no tienen un tipo . Son solo un nombre. Sin embargo, los valores s\u00ed tienen un tipo subyacente. >>> a = 42 >>> b = 'Hola Mundo' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() le dir\u00e1 cu\u00e1l es. El nombre del tipo se utiliza generalmente como una funci\u00f3n que crea o convierte un valor a ese tipo.","title":"Nombres, valores, tipos"},{"location":"02_Working_with_data/07_Objects/#comprobacion-de-tipos","text":"C\u00f3mo saber si un objeto es de un tipo espec\u00edfico. if isinstance(a, list): print('a es a lista') Comprobaci\u00f3n de uno de los muchos tipos posibles. if isinstance(a, (list,tuple)): print('a es a lista o tupla') Precauci\u00f3n: No se exceda con la comprobaci\u00f3n de tipos. Puede generar una complejidad excesiva en el c\u00f3digo. Por lo general, solo lo har\u00eda si al hacerlo evitara errores comunes que cometen otras personas al usar su c\u00f3digo.","title":"Comprobaci\u00f3n de tipos"},{"location":"02_Working_with_data/07_Objects/#todo-es-un-objeto","text":"N\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Esto significa que todos los objetos que se pueden nombrar se pueden pasar como datos, colocar en contenedores, etc., sin ninguna restricci\u00f3n. No hay tipos especiales de objetos. A veces se dice que todos los objetos son \"de primera clase\". Un ejemplo simple: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Fall\u00f3!') Fall\u00f3! >>> Aqu\u00ed, items es una lista que contiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. Puedes usar directamente los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Un gran poder conlleva una responsabilidad. El hecho de que puedas hacer eso no significa que debas hacerlo.","title":"Todo es un objeto"},{"location":"02_Working_with_data/07_Objects/#ejercicios","text":"En este conjunto de ejercicios, observamos parte del poder que proviene de los objetos de primera clase.","title":"Ejercicios"},{"location":"02_Working_with_data/07_Objects/#ejercicio-224-datos-de-primera-clase","text":"En el archivo Data/portfolio.csv , leemos datos organizados en columnas que se ven as\u00ed: name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... En el c\u00f3digo anterior, usamos el m\u00f3dulo csv para leer el archivo, pero a\u00fan as\u00ed tuvimos que realizar conversiones de tipo manuales. Por ejemplo: ```python for row in rows: name = row[0] shares = int(row[1]) price = float(row[2]) ``` Este tipo de conversi\u00f3n tambi\u00e9n se puede realizar de una manera m\u00e1s inteligente utilizando algunas operaciones b\u00e1sicas de lista. Haz una lista de Python que contenga los nombres de las funciones de conversi\u00f3n que usar\u00edas para convertir cada columna al tipo apropiado: >>> types = [str, int, float] >>> La raz\u00f3n por la que puedes crear esta lista es que todo en Python es de primera clase . Por lo tanto, si quieres tener una lista de funciones, est\u00e1 bien. Los elementos de la lista que creaste son funciones para convertir un valor x en un tipo determinado (por ejemplo, str(x) , int(x) , float(x) ). Ahora, lee una fila de datos del archivo anterior: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Como se se\u00f1al\u00f3, esta fila no es suficiente para realizar los c\u00e1lculos porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiplicar sequence by non-int of type 'str' >>> Sin embargo, tal vez los datos se puedan emparejar con los tipos que especificaste en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Intenta convertir uno de los valores: >>> types[1](row[1]) # Igual que int(row[1]) 100 >>> Intenta convertir un valor diferente: >>> types[2](row[2]) # Igual que float(row[2]) 32.2 >>> Intenta el c\u00e1lculo con valores convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Comprime los tipos de columna con los campos y mira el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Notar\u00e1s que esto ha emparejado una conversi\u00f3n de tipo con un valor. Por ejemplo, int est\u00e1 emparejado con el valor '100' . La lista por compresi\u00f3n es \u00fatil si quieres realizar conversiones en todos los valores, uno despu\u00e9s del otro. Prueba esto: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['AA', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Aseg\u00farate de entender lo que est\u00e1 sucediendo en el c\u00f3digo anterior. En el bucle, la variable func es una de las funciones de conversi\u00f3n de tipo (p. ej., str , int , etc.) y la variable val es uno de los valores como 'AA' , '100' . La expresi\u00f3n func(val) convierte un valor (algo as\u00ed como una conversi\u00f3n de tipo). El c\u00f3digo anterior se puede comprimir en una \u00fanica lista por comprensi\u00f3n. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['AA', 100, 32.2] >>>","title":"Ejercicio 2.24: Datos de primera clase"},{"location":"02_Working_with_data/07_Objects/#ejercicio-225-creacion-de-diccionarios","text":"\u00bfRecuerdas c\u00f3mo la funci\u00f3n dict() puede crear f\u00e1cilmente un diccionario si tienes una secuencia de nombres y valores de claves? Hagamos un diccionario a partir de los encabezados de las columnas: >>> headers ['name', 'shares', 'price'] >>> converted ['AA', 100, 32.2] >>> dict(zip(headers, converted)) {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Por supuesto, si ya tienes experiencia con las listas por comprensi\u00f3n, puedes hacer toda la conversi\u00f3n en un solo paso usando una comprensi\u00f3n de diccionarios: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'price': 32.2, 'name': 'AA', 'shares': 100} >>>","title":"Ejercicio 2.25: Creaci\u00f3n de diccionarios"},{"location":"02_Working_with_data/07_Objects/#ejercicio-226-el-panorama-general","text":"Si utiliza las t\u00e9cnicas de este ejercicio, podr\u00e1 escribir instrucciones que conviertan f\u00e1cilmente los campos de casi cualquier archivo de datos orientado a columnas en un diccionario de Python. Solo para ilustrar, supongamos que lees datos de un archivo de datos diferente como este: >>> f = open('Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos los campos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Bonificaci\u00f3n: \u00bfC\u00f3mo modificar\u00edas este ejemplo para que sea adicional? \u00bfC\u00f3mo analizar la entrada date en una tupla como (6, 11, 2007) ? Dedica un tiempo a reflexionar sobre lo que has hecho en este ejercicio. Volveremos a tratar estas ideas un poco m\u00e1s adelante. Contenido | Anterior (2.6 Listas por comprensi\u00f3n) | Pr\u00f3ximo (3. Organizaci\u00f3n del programa)","title":"Ejercicio 2.26: El panorama general"},{"location":"03_Program_organization/00_Overview/","text":"Contenido | Anterior (2. Trabajar con datos) | Pr\u00f3ximo (4. Classes y Objetos) 3. Organizaci\u00f3n del programa Hasta ahora, hemos aprendido algunos conceptos b\u00e1sicos de Python y hemos escrito algunos scripts cortos. Sin embargo, a medida que comiences a escribir programas m\u00e1s grandes, querr\u00e1s organizarte. Esta secci\u00f3n profundiza en mayor detalle sobre la escritura de funciones, el manejo de errores y presenta m\u00f3dulos. Al final deber\u00edas poder escribir programas que se subdividan en funciones en varios archivos. Tambi\u00e9n proporcionaremos algunas plantillas de c\u00f3digo \u00fatiles para escribir scripts m\u00e1s pr\u00e1cticos. 3.1 Funciones y escritura de scripts 3.2 M\u00e1s detalles sobre las funciones 3.3 Comprobaci\u00f3n de errores 3.4 M\u00f3dulos 3.5 M\u00f3dulo principal 3.6 Discusi\u00f3n sobre el dise\u00f1o Contenido | Anterior (2. Trabajar con datos) | Pr\u00f3ximo (4. Clases y objetos)","title":"00_Overview"},{"location":"03_Program_organization/00_Overview/#3-organizacion-del-programa","text":"Hasta ahora, hemos aprendido algunos conceptos b\u00e1sicos de Python y hemos escrito algunos scripts cortos. Sin embargo, a medida que comiences a escribir programas m\u00e1s grandes, querr\u00e1s organizarte. Esta secci\u00f3n profundiza en mayor detalle sobre la escritura de funciones, el manejo de errores y presenta m\u00f3dulos. Al final deber\u00edas poder escribir programas que se subdividan en funciones en varios archivos. Tambi\u00e9n proporcionaremos algunas plantillas de c\u00f3digo \u00fatiles para escribir scripts m\u00e1s pr\u00e1cticos. 3.1 Funciones y escritura de scripts 3.2 M\u00e1s detalles sobre las funciones 3.3 Comprobaci\u00f3n de errores 3.4 M\u00f3dulos 3.5 M\u00f3dulo principal 3.6 Discusi\u00f3n sobre el dise\u00f1o Contenido | Anterior (2. Trabajar con datos) | Pr\u00f3ximo (4. Clases y objetos)","title":"3. Organizaci\u00f3n del programa"},{"location":"03_Program_organization/01_Script/","text":"Contenido | Anterior (2.7 Objetos) | Pr\u00f3ximo (3.2 M\u00e1s detalles sobre las funciones) 3.1 Creaci\u00f3n de scripts En esta parte, analizamos m\u00e1s de cerca la pr\u00e1ctica de escribir scripts de Python. \u00bfQu\u00e9 es un script? Un script es un programa que ejecuta una serie de instrucciones y se detiene. # program.py declaraci\u00f3n1 declaraci\u00f3n2 declaraci\u00f3n3 ... Hasta este punto, hemos estado escribiendo principalmente scripts. Un problema Si escribe un script \u00fatil, crecer\u00e1 en caracter\u00edsticas y funcionalidades. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podr\u00eda convertirse en una aplicaci\u00f3n cr\u00edtica. Y si no tienes cuidado, puede convertirse en un gran l\u00edo. As\u00ed que, organic\u00e9monos. Definici\u00f3n de cosas Los nombres siempre deben definirse antes de que se utilicen m\u00e1s adelante. def square(x): return x*x a = 42 b = a + 2 # Requiere que `a` est\u00e9 definido z = square(b) # Requiere que `square` y `b` est\u00e9n definidos El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior. Definici\u00f3n de funciones Es una buena idea poner todo el c\u00f3digo relacionado con una sola tarea en un solo lugar. Usa una funci\u00f3n. def read_prices(filename): prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una funci\u00f3n tambi\u00e9n simplifica las operaciones repetidas. oldprices = read_prices('oldprices.csv') newprices = read_prices('newprices.csv') \u00bfQu\u00e9 es una funci\u00f3n? Una funci\u00f3n es una secuencia de instrucciones con nombre. def funcname(args): statement statement ... return result Cualquier instrucci\u00f3n de Python se puede utilizar dentro de ella. def foo(): import math print(math.sqrt(2)) help(math) No hay instrucciones especiales en Python (lo que hace que sea f\u00e1cil de recordar). Definici\u00f3n de funci\u00f3n Las funciones se pueden definir en cualquier orden. def foo(x): bar(x) def bar(x): statements # O def bar(x): statements def foo(x): bar(x) Las funciones solo se deben definir antes de utilizarse (o llamarse) durante la ejecuci\u00f3n del programa. foo(3) # foo ya debe estar definido Por estilo, es probablemente m\u00e1s com\u00fan ver funciones definidas de manera de abajo hacia arriba . Estilo de abajo hacia arriba Las funciones se tratan como bloques de construcci\u00f3n. Los bloques m\u00e1s peque\u00f1os/simples van primero. # myprogram.py def foo(x): ... def bar(x): ... foo(x) # Definido arriba ... def spam(x): ... bar(x) # Definido arriba ... spam(42) # El c\u00f3digo que usa las funciones aparece al final Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuesti\u00f3n de estilo. Lo \u00fanico que importa en el programa anterior es que la llamada a spam(42) va al final. Dise\u00f1o de funciones Idealmente, las funciones deber\u00edan ser una caja negra . Solo deber\u00edan operar en entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: Modularidad y Predictibilidad . Cadenas de documentaci\u00f3n Es una buena pr\u00e1ctica incluir la documentaci\u00f3n en forma de cadena de documentaci\u00f3n. Las cadenas de documentaci\u00f3n son cadenas que se escriben inmediatamente despu\u00e9s del nombre de la funci\u00f3n. Alimentan help() , IDEs y otras herramientas. def read_prices(filename): ''' Leer precios de un archivo CSV de nombre y datos de precios ''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una buena pr\u00e1ctica para las cadenas de documentaci\u00f3n es escribir un resumen breve de una oraci\u00f3n de lo que hace la funci\u00f3n. Si se necesita m\u00e1s informaci\u00f3n, incluya un breve ejemplo de uso junto con una descripci\u00f3n m\u00e1s detallada de los argumentos. Anotaciones de tipo Tambi\u00e9n puede agregar sugerencias de tipo opcionales a las definiciones de funciones. def read_prices(filename: str) -> dict: ''' Leer precios de un archivo CSV de nombre y datos de precios ''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Las sugerencias no hacen nada operativamente. Son puramente informativas. Sin embargo, pueden ser utilizadas por IDE, verificadores de c\u00f3digo y otras herramientas para hacer m\u00e1s. Ejercicios En la secci\u00f3n 2, escribi\u00f3 un programa llamado report.py que imprim\u00eda un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo: # report.py import csv def read_portfolio(filename): ''' Leer un archivo de cartera de acciones en una lista de diccionarios con claves nombre, acciones y precio. ''' portfolio = [] with open(filename) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) stock = { 'name' : record['name'], 'shares' : int(record['shares']), 'price' : float(record['price']) } portfolio.append(stock) return portfolio ... Sin embargo, tambi\u00e9n hab\u00eda partes del programa que solo realizaban una serie de c\u00e1lculos programados. Este c\u00f3digo apareci\u00f3 cerca del final del programa. Por ejemplo: ... # Generar el informe headers = ('Name', 'Shares', 'Price', 'Change') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in report: print('%10s %10d %10.2f %10.2f' % row) ... En este ejercicio, tomaremos este programa y lo organizaremos un poco m\u00e1s en torno al uso de funciones. Ejercicio 3.1: Estructurar un programa como una colecci\u00f3n de funciones Modifique su programa report.py para que todas las operaciones principales, incluidos los c\u00e1lculos y la salida, se realicen mediante una colecci\u00f3n de funciones. Espec\u00edficamente: Cree una funci\u00f3n print_report(report) que imprima el informe. Cambie la \u00faltima parte del programa para que no sea m\u00e1s que una serie de llamadas de funci\u00f3n y ning\u00fan otro c\u00e1lculo. Ejercicio 3.2: Creaci\u00f3n de una funci\u00f3n de nivel superior para la ejecuci\u00f3n del programa Tome la \u00faltima parte de su programa y empaquetela en una sola funci\u00f3n portfolio_report(portfolio_filename, prices_filename) . Haga que la funci\u00f3n funcione de modo que la siguiente llamada de funci\u00f3n cree el informe como antes: portfolio_report('Data/portfolio.csv', 'Data/prices.csv') En esta versi\u00f3n final, su programa no ser\u00e1 m\u00e1s que una serie de definiciones de funciones seguidas de una \u00fanica llamada de funci\u00f3n a portfolio_report() al final (que ejecuta todos los pasos involucrados en el programa). Al convertir su programa en una \u00fanica funci\u00f3n, se vuelve f\u00e1cil ejecutarlo en diferentes entradas. Por ejemplo, prueba estas declaraciones de forma interactiva despu\u00e9s de ejecutar tu programa: >>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv') ... Observa la salida ... >>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv'] >>> for name in files: print(f'{name:-^43s}') portfolio_report(name, 'Data/prices.csv') print() ... Observa la salida ... >>> Comentario Python hace que sea muy f\u00e1cil escribir c\u00f3digo de script relativamente desestructurado, en el que solo tienes un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones siempre que puedas. En alg\u00fan momento, ese script crecer\u00e1 y desear\u00e1s tener un poco m\u00e1s de organizaci\u00f3n. Adem\u00e1s, un hecho poco conocido es que Python se ejecuta un poco m\u00e1s r\u00e1pido si se utilizan funciones. Contenido | Anterior (2.7 Objetos) | Pr\u00f3ximo (3.2 M\u00e1s detalles sobre las funciones)","title":"00_Script"},{"location":"03_Program_organization/01_Script/#31-creacion-de-scripts","text":"En esta parte, analizamos m\u00e1s de cerca la pr\u00e1ctica de escribir scripts de Python.","title":"3.1 Creaci\u00f3n de scripts"},{"location":"03_Program_organization/01_Script/#que-es-un-script","text":"Un script es un programa que ejecuta una serie de instrucciones y se detiene. # program.py declaraci\u00f3n1 declaraci\u00f3n2 declaraci\u00f3n3 ... Hasta este punto, hemos estado escribiendo principalmente scripts.","title":"\u00bfQu\u00e9 es un script?"},{"location":"03_Program_organization/01_Script/#un-problema","text":"Si escribe un script \u00fatil, crecer\u00e1 en caracter\u00edsticas y funcionalidades. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podr\u00eda convertirse en una aplicaci\u00f3n cr\u00edtica. Y si no tienes cuidado, puede convertirse en un gran l\u00edo. As\u00ed que, organic\u00e9monos.","title":"Un problema"},{"location":"03_Program_organization/01_Script/#definicion-de-cosas","text":"Los nombres siempre deben definirse antes de que se utilicen m\u00e1s adelante. def square(x): return x*x a = 42 b = a + 2 # Requiere que `a` est\u00e9 definido z = square(b) # Requiere que `square` y `b` est\u00e9n definidos El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior.","title":"Definici\u00f3n de cosas"},{"location":"03_Program_organization/01_Script/#definicion-de-funciones","text":"Es una buena idea poner todo el c\u00f3digo relacionado con una sola tarea en un solo lugar. Usa una funci\u00f3n. def read_prices(filename): prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una funci\u00f3n tambi\u00e9n simplifica las operaciones repetidas. oldprices = read_prices('oldprices.csv') newprices = read_prices('newprices.csv')","title":"Definici\u00f3n de funciones"},{"location":"03_Program_organization/01_Script/#que-es-una-funcion","text":"Una funci\u00f3n es una secuencia de instrucciones con nombre. def funcname(args): statement statement ... return result Cualquier instrucci\u00f3n de Python se puede utilizar dentro de ella. def foo(): import math print(math.sqrt(2)) help(math) No hay instrucciones especiales en Python (lo que hace que sea f\u00e1cil de recordar).","title":"\u00bfQu\u00e9 es una funci\u00f3n?"},{"location":"03_Program_organization/01_Script/#definicion-de-funcion","text":"Las funciones se pueden definir en cualquier orden. def foo(x): bar(x) def bar(x): statements # O def bar(x): statements def foo(x): bar(x) Las funciones solo se deben definir antes de utilizarse (o llamarse) durante la ejecuci\u00f3n del programa. foo(3) # foo ya debe estar definido Por estilo, es probablemente m\u00e1s com\u00fan ver funciones definidas de manera de abajo hacia arriba .","title":"Definici\u00f3n de funci\u00f3n"},{"location":"03_Program_organization/01_Script/#estilo-de-abajo-hacia-arriba","text":"Las funciones se tratan como bloques de construcci\u00f3n. Los bloques m\u00e1s peque\u00f1os/simples van primero. # myprogram.py def foo(x): ... def bar(x): ... foo(x) # Definido arriba ... def spam(x): ... bar(x) # Definido arriba ... spam(42) # El c\u00f3digo que usa las funciones aparece al final Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuesti\u00f3n de estilo. Lo \u00fanico que importa en el programa anterior es que la llamada a spam(42) va al final.","title":"Estilo de abajo hacia arriba"},{"location":"03_Program_organization/01_Script/#diseno-de-funciones","text":"Idealmente, las funciones deber\u00edan ser una caja negra . Solo deber\u00edan operar en entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: Modularidad y Predictibilidad .","title":"Dise\u00f1o de funciones"},{"location":"03_Program_organization/01_Script/#cadenas-de-documentacion","text":"Es una buena pr\u00e1ctica incluir la documentaci\u00f3n en forma de cadena de documentaci\u00f3n. Las cadenas de documentaci\u00f3n son cadenas que se escriben inmediatamente despu\u00e9s del nombre de la funci\u00f3n. Alimentan help() , IDEs y otras herramientas. def read_prices(filename): ''' Leer precios de un archivo CSV de nombre y datos de precios ''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una buena pr\u00e1ctica para las cadenas de documentaci\u00f3n es escribir un resumen breve de una oraci\u00f3n de lo que hace la funci\u00f3n. Si se necesita m\u00e1s informaci\u00f3n, incluya un breve ejemplo de uso junto con una descripci\u00f3n m\u00e1s detallada de los argumentos.","title":"Cadenas de documentaci\u00f3n"},{"location":"03_Program_organization/01_Script/#anotaciones-de-tipo","text":"Tambi\u00e9n puede agregar sugerencias de tipo opcionales a las definiciones de funciones. def read_prices(filename: str) -> dict: ''' Leer precios de un archivo CSV de nombre y datos de precios ''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Las sugerencias no hacen nada operativamente. Son puramente informativas. Sin embargo, pueden ser utilizadas por IDE, verificadores de c\u00f3digo y otras herramientas para hacer m\u00e1s.","title":"Anotaciones de tipo"},{"location":"03_Program_organization/01_Script/#ejercicios","text":"En la secci\u00f3n 2, escribi\u00f3 un programa llamado report.py que imprim\u00eda un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo: # report.py import csv def read_portfolio(filename): ''' Leer un archivo de cartera de acciones en una lista de diccionarios con claves nombre, acciones y precio. ''' portfolio = [] with open(filename) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) stock = { 'name' : record['name'], 'shares' : int(record['shares']), 'price' : float(record['price']) } portfolio.append(stock) return portfolio ... Sin embargo, tambi\u00e9n hab\u00eda partes del programa que solo realizaban una serie de c\u00e1lculos programados. Este c\u00f3digo apareci\u00f3 cerca del final del programa. Por ejemplo: ... # Generar el informe headers = ('Name', 'Shares', 'Price', 'Change') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in report: print('%10s %10d %10.2f %10.2f' % row) ... En este ejercicio, tomaremos este programa y lo organizaremos un poco m\u00e1s en torno al uso de funciones.","title":"Ejercicios"},{"location":"03_Program_organization/01_Script/#ejercicio-31-estructurar-un-programa-como-una-coleccion-de-funciones","text":"Modifique su programa report.py para que todas las operaciones principales, incluidos los c\u00e1lculos y la salida, se realicen mediante una colecci\u00f3n de funciones. Espec\u00edficamente: Cree una funci\u00f3n print_report(report) que imprima el informe. Cambie la \u00faltima parte del programa para que no sea m\u00e1s que una serie de llamadas de funci\u00f3n y ning\u00fan otro c\u00e1lculo.","title":"Ejercicio 3.1: Estructurar un programa como una colecci\u00f3n de funciones"},{"location":"03_Program_organization/01_Script/#ejercicio-32-creacion-de-una-funcion-de-nivel-superior-para-la-ejecucion-del-programa","text":"Tome la \u00faltima parte de su programa y empaquetela en una sola funci\u00f3n portfolio_report(portfolio_filename, prices_filename) . Haga que la funci\u00f3n funcione de modo que la siguiente llamada de funci\u00f3n cree el informe como antes: portfolio_report('Data/portfolio.csv', 'Data/prices.csv') En esta versi\u00f3n final, su programa no ser\u00e1 m\u00e1s que una serie de definiciones de funciones seguidas de una \u00fanica llamada de funci\u00f3n a portfolio_report() al final (que ejecuta todos los pasos involucrados en el programa). Al convertir su programa en una \u00fanica funci\u00f3n, se vuelve f\u00e1cil ejecutarlo en diferentes entradas. Por ejemplo, prueba estas declaraciones de forma interactiva despu\u00e9s de ejecutar tu programa: >>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv') ... Observa la salida ... >>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv'] >>> for name in files: print(f'{name:-^43s}') portfolio_report(name, 'Data/prices.csv') print() ... Observa la salida ... >>>","title":"Ejercicio 3.2: Creaci\u00f3n de una funci\u00f3n de nivel superior para la ejecuci\u00f3n del programa"},{"location":"03_Program_organization/01_Script/#comentario","text":"Python hace que sea muy f\u00e1cil escribir c\u00f3digo de script relativamente desestructurado, en el que solo tienes un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones siempre que puedas. En alg\u00fan momento, ese script crecer\u00e1 y desear\u00e1s tener un poco m\u00e1s de organizaci\u00f3n. Adem\u00e1s, un hecho poco conocido es que Python se ejecuta un poco m\u00e1s r\u00e1pido si se utilizan funciones. Contenido | Anterior (2.7 Objetos) | Pr\u00f3ximo (3.2 M\u00e1s detalles sobre las funciones)","title":"Comentario"},{"location":"03_Program_organization/02_More_functions/","text":"Contenido | Anterior (3.1 Funciones y escritura de scripts) | Pr\u00f3ximo (3.3 Comprobaci\u00f3n de errores) 3.2 M\u00e1s detalles sobre las funciones Aunque las funciones se introdujeron anteriormente, se proporcionaron muy pocos detalles sobre c\u00f3mo funcionan realmente en un nivel m\u00e1s profundo. Esta secci\u00f3n tiene como objetivo llenar algunos vac\u00edos y analizar cuestiones como las convenciones de llamadas, las reglas de alcance y m\u00e1s. Llamada a una funci\u00f3n Considere esta funci\u00f3n: def read_prices(filename, debug): ... Puede llamar a la funci\u00f3n con argumentos posicionales: prices = read_prices('prices.csv', True) O puede llamar a la funci\u00f3n con argumentos de palabras clave: prices = read_prices(filename='prices.csv', debug=True) Argumentos predeterminados A veces desea que un argumento sea opcional. Si es as\u00ed, asigne un valor predeterminado en la definici\u00f3n de la funci\u00f3n. def read_prices(filename, debug=False): ... Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a la funci\u00f3n. d = read_prices('prices.csv') e = read_prices('prices.dat', True) Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero). Prefiera argumentos de palabras clave para argumentos opcionales Compare y contraste estos dos estilos de llamada diferentes: parse_data(data, False, True) # ????? parse_data(data, ignore_errors=True) parse_data(data, debug=True) parse_data(data, debug=True, ignore_errors=True) En la mayor\u00eda de los casos, los argumentos de palabras clave mejoran la claridad del c\u00f3digo, especialmente para los argumentos que sirven como indicadores o que est\u00e1n relacionados con caracter\u00edsticas opcionales. Mejores pr\u00e1cticas de dise\u00f1o Siempre de nombres breves, pero significativos, a los argumentos de las funciones. Alguien que use una funci\u00f3n puede querer usar el estilo de llamada de palabras clave. d = read_prices('prices.csv', debug=True) Las herramientas de desarrollo de Python mostrar\u00e1n los nombres en las funciones de ayuda y la documentaci\u00f3n. Valores de retorno La declaraci\u00f3n return devuelve un valor def square(x): return x * x Si no se proporciona ning\u00fan valor de retorno o falta return , se devuelve None . def bar(x): declaraciones return a = bar(4) # a = None # de otro modo def foo(x): declaraciones # Sin `return` b = foo(4) # b = None Valores de retorno m\u00faltiples Las funciones solo pueden devolver un valor. Sin embargo, una funci\u00f3n puede devolver m\u00faltiples valores al devolverlos en una tupla. def divide(a,b): q = a // b # Cociente entero r = a % b # Resto return q, r # Devuelve una tupla Ejemplo de uso: x, y = divide(37,5) # x = 7, y = 2 x = divide(37, 5) # x = (7, 2) \u00c1mbito de la variable Los programas asignan valores a las variables. x = valor # Variable global def foo(): y = valor # Variable local Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas fuera son \"globales\". Las variables dentro de una funci\u00f3n son \"locales\". Variables locales Las variables asignadas dentro de las funciones son privadas. def read_portfolio(filename): portfolio = [] with open(filename) as file: headers = next(file) for line in file: fields = line.split(',') s = (fields[0], int(fields[1]), float(fields[2])) portfolio.append(s) return portfolio En este ejemplo, filename , \u00b4file\u00b4, portfolio , line , fields y s son variables locales. Esas variables no se conservan ni se puede acceder a ellas despu\u00e9s de la llamada a la funci\u00f3n. >>> stocks = read_portfolio('Data/portfolio.csv') >>> fields Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'fields' is not defined >>> Las variables locales tampoco pueden entrar en conflicto con las variables que se encuentran en otro lugar. Variables globales Las funciones pueden acceder libremente a los valores de las variables globales definidas en el mismo archivo. name = 'Dave' def greeting(): print('Hola', name) # Uso de la variable global `name` Sin embargo, las funciones no pueden modificar las variables globales: name = 'Dave' def spam(): name = 'Guido' spam() print(name) # imprime 'Dave' Recuerde: todas las asignaciones en funciones son locales. Modificaci\u00f3n de variables globales Si debe modificar una variable global, debe declararla como tal. name = 'Dave' def spam(): global name name = 'Guido' # Cambia el nombre global anterior La declaraci\u00f3n global debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la funci\u00f3n. Habiendo visto esto, debes saber que se considera una mala forma de hacerlo. De hecho, intenta evitar el uso de \"global\" por completo si puedes. Si necesitas una funci\u00f3n para modificar alg\u00fan tipo de estado fuera de la funci\u00f3n, es mejor usar una clase en su lugar (m\u00e1s sobre esto m\u00e1s adelante). Pase de argumentos Cuando llamas a una funci\u00f3n, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (ver secci\u00f3n 2.7 ). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar in situ . def foo(items): items.append(42) # Modifies the input object a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Punto clave: Las funciones no reciben una copia de los argumentos de entrada. Reasignaci\u00f3n vs. Modificaci\u00f3n Aseg\u00farese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # en lugar de def bar(items): items = [4,5,6] # Reasigna la variable `items` local para que apunte a un objeto diferente b = [1, 2, 3] bar(b) print(b) # [1, 2, 3] Recordatorio: la asignaci\u00f3n de variables nunca sobrescribe la memoria. El nombre simplemente est\u00e1 ligado a un nuevo valor. Ejercicios Este conjunto de ejercicios te permite implementar lo que es, quiz\u00e1s, la parte m\u00e1s poderosa y dif\u00edcil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores se combinan a la vez. La soluci\u00f3n final consta de tan solo unas 25 l\u00edneas de c\u00f3digo, pero t\u00f3mate tu tiempo y aseg\u00farate de comprender cada parte. Una parte central de tu programa report.py se centra en la lectura de archivos CSV. Por ejemplo, la funci\u00f3n read_portfolio() lee un archivo que contiene filas de datos de cartera y la funci\u00f3n read_prices() lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchos fragmentos \"complicados\" de bajo nivel y caracter\u00edsticas similares. Por ejemplo, ambas abren un archivo y lo envuelven con el m\u00f3dulo csv y ambas convierten varios campos en nuevos tipos. Si estuvieras haciendo mucho an\u00e1lisis de archivos de verdad, probablemente querr\u00edas limpiar algo de esto y hacerlo m\u00e1s general. Ese es nuestro objetivo. Comienza este ejercicio abriendo el archivo llamado Work/fileparse.py . Aqu\u00ed es donde haremos nuestro trabajo. Ejercicio 3.3: Lectura de archivos CSV Para comenzar, centr\u00e9monos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo fileparse.py , defina una funci\u00f3n que se parezca a esto: # fileparse.py import csv def parse_csv(filename): ''' Analiza un archivo CSV en una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Read the file headers headers = next(rows) records = [] for row in rows: if not row: # Omite filas sin datos continue record = dict(zip(headers, row)) records.append(record) return records Esta funci\u00f3n lee un archivo CSV y crea una lista de diccionarios mientras oculta los detalles de apertura del archivo, lo envuelve con el m\u00f3dulo csv , ignora las l\u00edneas en blanco, etc. Pru\u00e9belo: Sugerencia: python -i fileparse.py . >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': '100', 'price': '32.20'}, {'name': 'IBM', 'shares': '50', 'price': '91.10'}, {'name': 'CAT', 'shares': '150', 'price': '83.44'}, {'name': 'MSFT', 'shares': '200', 'price': '51.23'}, {'name': 'GE', 'shares': '95', 'price': '40.37'}, {'name': 'MSFT', 'shares': '50', 'price': '65.10'}, {'name': 'IBM', 'shares': '100', 'price': '70.44'}] >>> Esto es bueno, excepto que no se puede hacer ning\u00fan tipo de c\u00e1lculo \u00fatil con los datos porque todo se representa como una cadena. Arreglaremos esto en breve, pero sigamos trabajando en ello. Ejercicio 3.4: Creaci\u00f3n de un selector de columnas En muchos casos, solo interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la funci\u00f3n parse_csv() para que permita opcionalmente seleccionar columnas especificadas por el usuario de la siguiente manera: >>> # Leer todos los datos >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': '100', 'price': '32.20'}, {'name': 'IBM', 'shares': '50', 'price': '91.10'}, {'name': 'CAT', 'shares': '150', 'price': '83.44'}, {'name': 'MSFT', 'shares': '200', 'price': '51.23'}, {'name': 'GE', 'shares': '95', 'price': '40.37'}, {'name': 'MSFT', 'shares': '50', 'price': '65.10'}, {'name': 'IBM', 'shares': '100', 'price': '70.44'}] >>> # Leer solo algunos de los datos >>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares']) >>> shares_held [{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}] >>> En el Ejercicio 2.23 se proporcion\u00f3 un ejemplo de selector de columnas. Sin embargo, aqu\u00ed se muestra una forma de hacerlo: # fileparse.py import csv def parse_csv(filename, select=None): ''' Analizar un archivo CSV con una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Leer los encabezados del archivo headers = next(rows) # Si se proporcion\u00f3 un selector de columnas, buscar los \u00edndices de las columnas especificadas # Tambi\u00e9n se limita el conjunto de encabezados utilizados para los diccionarios resultantes if select: indices = [headers.index(colname) for colname in select] headers = select else: indices = [] records = [] for row in rows: if not row: # Omite filas sin datos continue # Filtrar la fila si se seleccionaron columnas espec\u00edficas if indices: row = [ row[index] for index in indices ] # Crear un dicciona record = dict(zip(headers, row)) records.append(record) return records Esta parte tiene varios puntos complicados. Probablemente, el m\u00e1s importante sea la asignaci\u00f3n de las selecciones de columnas a los \u00edndices de filas. Por ejemplo, supongamos que el archivo de entrada tiene los siguientes encabezados: >>> headers = ['name', 'date', 'time', 'shares', 'price'] >>> Ahora, supongamos que las columnas seleccionadas fueran las siguientes: >>> select = ['name', 'shares'] >>> Para realizar la selecci\u00f3n adecuada, debe asignar los nombres de las columnas seleccionadas a los \u00edndices de las columnas en el archivo. Esto es lo que hace este paso: >>> indices = [headers.index(colname) for colname in select ] >>> indices [0, 3] >>> En otras palabras, \u00b4name\u00b4 es la columna 0 y \u00b4shares` es la columna 3. Cuando se lee una fila de datos del archivo, se utilizan los \u00edndices para filtrarla: >>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ] >>> row = [ row[index] for index in indices ] >>> row ['AA', '100'] >>> Ejercicio 3.5: Realizar conversi\u00f3n de tipos Modifique la funci\u00f3n parse_csv() para que permita opcionalmente conversiones de tipo que se aplicar\u00e1n a los datos devueltos. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float]) >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int]) >>> shares_held [{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}] >>> Ya exploraste esto en Ejercicio 2.24 . Necesitar\u00e1 insertar el siguiente fragmento de c\u00f3digo en su soluci\u00f3n: ... if types: row = [func(val) for func, val in zip(types, row) ] ... Ejercicio 3.6: Trabajar sin encabezados Algunos archivos CSV no incluyen ninguna informaci\u00f3n de encabezado. Por ejemplo, el archivo prices.csv tiene este aspecto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 ... Modifique la funci\u00f3n parse_csv() para que pueda trabajar con dichos archivos creando una lista de tuplas en su lugar. Por ejemplo: >>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> prices [('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)] >>> Para realizar este cambio, deber\u00e1 modificar el c\u00f3digo de modo que la primera l\u00ednea de datos No se interprete como una l\u00ednea de encabezado. Adem\u00e1s, deber\u00e1 asegurarse de no crear diccionarios, ya que ya no hay nombres de columnas para usar como claves. Ejercicio 3.7: Elegir un delimitador de columna diferente Aunque los archivos CSV son bastante comunes, tambi\u00e9n es posible encontrar un archivo que utilice un separador de columnas diferente, como una tabulaci\u00f3n o un espacio. Por ejemplo, el archivo Data/portfolio.dat tiene este aspecto: name shares price \"AA\" 100 32.20 \"IBM\" 50 91.10 \"CAT\" 150 83.44 \"MSFT\" 200 51.23 \"GE\" 95 40.37 \"MSFT\" 50 65.10 \"IBM\" 100 70.44 La funci\u00f3n csv.reader() permite indicar un delimitador de columna diferente de la siguiente manera: rows = csv.reader(f, delimiter=' ') `` ` Modifique su funci\u00f3n `parse_csv()` para que tambi\u00e9n permita cambiar el delimitador. Por ejemplo: ```python >>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> Comentario Si has llegado hasta aqu\u00ed, has creado una bonita funci\u00f3n de biblioteca que es realmente \u00fatil. Puedes usarla para analizar archivos CSV arbitrarios, seleccionar columnas de inter\u00e9s, realizar conversiones de tipos, sin tener que preocuparte demasiado por el funcionamiento interno de los archivos o el m\u00f3dulo csv . Contenido | Anterior (3.1 Funciones y escritura de scripts) | Pr\u00f3ximo (3.3 Comprobaci\u00f3n de errores)","title":"02_More_functions"},{"location":"03_Program_organization/02_More_functions/#32-mas-detalles-sobre-las-funciones","text":"Aunque las funciones se introdujeron anteriormente, se proporcionaron muy pocos detalles sobre c\u00f3mo funcionan realmente en un nivel m\u00e1s profundo. Esta secci\u00f3n tiene como objetivo llenar algunos vac\u00edos y analizar cuestiones como las convenciones de llamadas, las reglas de alcance y m\u00e1s.","title":"3.2 M\u00e1s detalles sobre las funciones"},{"location":"03_Program_organization/02_More_functions/#llamada-a-una-funcion","text":"Considere esta funci\u00f3n: def read_prices(filename, debug): ... Puede llamar a la funci\u00f3n con argumentos posicionales: prices = read_prices('prices.csv', True) O puede llamar a la funci\u00f3n con argumentos de palabras clave: prices = read_prices(filename='prices.csv', debug=True)","title":"Llamada a una funci\u00f3n"},{"location":"03_Program_organization/02_More_functions/#argumentos-predeterminados","text":"A veces desea que un argumento sea opcional. Si es as\u00ed, asigne un valor predeterminado en la definici\u00f3n de la funci\u00f3n. def read_prices(filename, debug=False): ... Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a la funci\u00f3n. d = read_prices('prices.csv') e = read_prices('prices.dat', True) Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero).","title":"Argumentos predeterminados"},{"location":"03_Program_organization/02_More_functions/#prefiera-argumentos-de-palabras-clave-para-argumentos-opcionales","text":"Compare y contraste estos dos estilos de llamada diferentes: parse_data(data, False, True) # ????? parse_data(data, ignore_errors=True) parse_data(data, debug=True) parse_data(data, debug=True, ignore_errors=True) En la mayor\u00eda de los casos, los argumentos de palabras clave mejoran la claridad del c\u00f3digo, especialmente para los argumentos que sirven como indicadores o que est\u00e1n relacionados con caracter\u00edsticas opcionales.","title":"Prefiera argumentos de palabras clave para argumentos opcionales"},{"location":"03_Program_organization/02_More_functions/#mejores-practicas-de-diseno","text":"Siempre de nombres breves, pero significativos, a los argumentos de las funciones. Alguien que use una funci\u00f3n puede querer usar el estilo de llamada de palabras clave. d = read_prices('prices.csv', debug=True) Las herramientas de desarrollo de Python mostrar\u00e1n los nombres en las funciones de ayuda y la documentaci\u00f3n.","title":"Mejores pr\u00e1cticas de dise\u00f1o"},{"location":"03_Program_organization/02_More_functions/#valores-de-retorno","text":"La declaraci\u00f3n return devuelve un valor def square(x): return x * x Si no se proporciona ning\u00fan valor de retorno o falta return , se devuelve None . def bar(x): declaraciones return a = bar(4) # a = None # de otro modo def foo(x): declaraciones # Sin `return` b = foo(4) # b = None","title":"Valores de retorno"},{"location":"03_Program_organization/02_More_functions/#valores-de-retorno-multiples","text":"Las funciones solo pueden devolver un valor. Sin embargo, una funci\u00f3n puede devolver m\u00faltiples valores al devolverlos en una tupla. def divide(a,b): q = a // b # Cociente entero r = a % b # Resto return q, r # Devuelve una tupla Ejemplo de uso: x, y = divide(37,5) # x = 7, y = 2 x = divide(37, 5) # x = (7, 2)","title":"Valores de retorno m\u00faltiples"},{"location":"03_Program_organization/02_More_functions/#ambito-de-la-variable","text":"Los programas asignan valores a las variables. x = valor # Variable global def foo(): y = valor # Variable local Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas fuera son \"globales\". Las variables dentro de una funci\u00f3n son \"locales\".","title":"\u00c1mbito de la variable"},{"location":"03_Program_organization/02_More_functions/#variables-locales","text":"Las variables asignadas dentro de las funciones son privadas. def read_portfolio(filename): portfolio = [] with open(filename) as file: headers = next(file) for line in file: fields = line.split(',') s = (fields[0], int(fields[1]), float(fields[2])) portfolio.append(s) return portfolio En este ejemplo, filename , \u00b4file\u00b4, portfolio , line , fields y s son variables locales. Esas variables no se conservan ni se puede acceder a ellas despu\u00e9s de la llamada a la funci\u00f3n. >>> stocks = read_portfolio('Data/portfolio.csv') >>> fields Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'fields' is not defined >>> Las variables locales tampoco pueden entrar en conflicto con las variables que se encuentran en otro lugar.","title":"Variables locales"},{"location":"03_Program_organization/02_More_functions/#variables-globales","text":"Las funciones pueden acceder libremente a los valores de las variables globales definidas en el mismo archivo. name = 'Dave' def greeting(): print('Hola', name) # Uso de la variable global `name` Sin embargo, las funciones no pueden modificar las variables globales: name = 'Dave' def spam(): name = 'Guido' spam() print(name) # imprime 'Dave' Recuerde: todas las asignaciones en funciones son locales.","title":"Variables globales"},{"location":"03_Program_organization/02_More_functions/#modificacion-de-variables-globales","text":"Si debe modificar una variable global, debe declararla como tal. name = 'Dave' def spam(): global name name = 'Guido' # Cambia el nombre global anterior La declaraci\u00f3n global debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la funci\u00f3n. Habiendo visto esto, debes saber que se considera una mala forma de hacerlo. De hecho, intenta evitar el uso de \"global\" por completo si puedes. Si necesitas una funci\u00f3n para modificar alg\u00fan tipo de estado fuera de la funci\u00f3n, es mejor usar una clase en su lugar (m\u00e1s sobre esto m\u00e1s adelante).","title":"Modificaci\u00f3n de variables globales"},{"location":"03_Program_organization/02_More_functions/#pase-de-argumentos","text":"Cuando llamas a una funci\u00f3n, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (ver secci\u00f3n 2.7 ). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar in situ . def foo(items): items.append(42) # Modifies the input object a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Punto clave: Las funciones no reciben una copia de los argumentos de entrada.","title":"Pase de argumentos"},{"location":"03_Program_organization/02_More_functions/#reasignacion-vs-modificacion","text":"Aseg\u00farese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # en lugar de def bar(items): items = [4,5,6] # Reasigna la variable `items` local para que apunte a un objeto diferente b = [1, 2, 3] bar(b) print(b) # [1, 2, 3] Recordatorio: la asignaci\u00f3n de variables nunca sobrescribe la memoria. El nombre simplemente est\u00e1 ligado a un nuevo valor.","title":"Reasignaci\u00f3n vs. Modificaci\u00f3n"},{"location":"03_Program_organization/02_More_functions/#ejercicios","text":"Este conjunto de ejercicios te permite implementar lo que es, quiz\u00e1s, la parte m\u00e1s poderosa y dif\u00edcil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores se combinan a la vez. La soluci\u00f3n final consta de tan solo unas 25 l\u00edneas de c\u00f3digo, pero t\u00f3mate tu tiempo y aseg\u00farate de comprender cada parte. Una parte central de tu programa report.py se centra en la lectura de archivos CSV. Por ejemplo, la funci\u00f3n read_portfolio() lee un archivo que contiene filas de datos de cartera y la funci\u00f3n read_prices() lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchos fragmentos \"complicados\" de bajo nivel y caracter\u00edsticas similares. Por ejemplo, ambas abren un archivo y lo envuelven con el m\u00f3dulo csv y ambas convierten varios campos en nuevos tipos. Si estuvieras haciendo mucho an\u00e1lisis de archivos de verdad, probablemente querr\u00edas limpiar algo de esto y hacerlo m\u00e1s general. Ese es nuestro objetivo. Comienza este ejercicio abriendo el archivo llamado Work/fileparse.py . Aqu\u00ed es donde haremos nuestro trabajo.","title":"Ejercicios"},{"location":"03_Program_organization/02_More_functions/#ejercicio-33-lectura-de-archivos-csv","text":"Para comenzar, centr\u00e9monos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo fileparse.py , defina una funci\u00f3n que se parezca a esto: # fileparse.py import csv def parse_csv(filename): ''' Analiza un archivo CSV en una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Read the file headers headers = next(rows) records = [] for row in rows: if not row: # Omite filas sin datos continue record = dict(zip(headers, row)) records.append(record) return records Esta funci\u00f3n lee un archivo CSV y crea una lista de diccionarios mientras oculta los detalles de apertura del archivo, lo envuelve con el m\u00f3dulo csv , ignora las l\u00edneas en blanco, etc. Pru\u00e9belo: Sugerencia: python -i fileparse.py . >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': '100', 'price': '32.20'}, {'name': 'IBM', 'shares': '50', 'price': '91.10'}, {'name': 'CAT', 'shares': '150', 'price': '83.44'}, {'name': 'MSFT', 'shares': '200', 'price': '51.23'}, {'name': 'GE', 'shares': '95', 'price': '40.37'}, {'name': 'MSFT', 'shares': '50', 'price': '65.10'}, {'name': 'IBM', 'shares': '100', 'price': '70.44'}] >>> Esto es bueno, excepto que no se puede hacer ning\u00fan tipo de c\u00e1lculo \u00fatil con los datos porque todo se representa como una cadena. Arreglaremos esto en breve, pero sigamos trabajando en ello.","title":"Ejercicio 3.3: Lectura de archivos CSV"},{"location":"03_Program_organization/02_More_functions/#ejercicio-34-creacion-de-un-selector-de-columnas","text":"En muchos casos, solo interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la funci\u00f3n parse_csv() para que permita opcionalmente seleccionar columnas especificadas por el usuario de la siguiente manera: >>> # Leer todos los datos >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': '100', 'price': '32.20'}, {'name': 'IBM', 'shares': '50', 'price': '91.10'}, {'name': 'CAT', 'shares': '150', 'price': '83.44'}, {'name': 'MSFT', 'shares': '200', 'price': '51.23'}, {'name': 'GE', 'shares': '95', 'price': '40.37'}, {'name': 'MSFT', 'shares': '50', 'price': '65.10'}, {'name': 'IBM', 'shares': '100', 'price': '70.44'}] >>> # Leer solo algunos de los datos >>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares']) >>> shares_held [{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}] >>> En el Ejercicio 2.23 se proporcion\u00f3 un ejemplo de selector de columnas. Sin embargo, aqu\u00ed se muestra una forma de hacerlo: # fileparse.py import csv def parse_csv(filename, select=None): ''' Analizar un archivo CSV con una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Leer los encabezados del archivo headers = next(rows) # Si se proporcion\u00f3 un selector de columnas, buscar los \u00edndices de las columnas especificadas # Tambi\u00e9n se limita el conjunto de encabezados utilizados para los diccionarios resultantes if select: indices = [headers.index(colname) for colname in select] headers = select else: indices = [] records = [] for row in rows: if not row: # Omite filas sin datos continue # Filtrar la fila si se seleccionaron columnas espec\u00edficas if indices: row = [ row[index] for index in indices ] # Crear un dicciona record = dict(zip(headers, row)) records.append(record) return records Esta parte tiene varios puntos complicados. Probablemente, el m\u00e1s importante sea la asignaci\u00f3n de las selecciones de columnas a los \u00edndices de filas. Por ejemplo, supongamos que el archivo de entrada tiene los siguientes encabezados: >>> headers = ['name', 'date', 'time', 'shares', 'price'] >>> Ahora, supongamos que las columnas seleccionadas fueran las siguientes: >>> select = ['name', 'shares'] >>> Para realizar la selecci\u00f3n adecuada, debe asignar los nombres de las columnas seleccionadas a los \u00edndices de las columnas en el archivo. Esto es lo que hace este paso: >>> indices = [headers.index(colname) for colname in select ] >>> indices [0, 3] >>> En otras palabras, \u00b4name\u00b4 es la columna 0 y \u00b4shares` es la columna 3. Cuando se lee una fila de datos del archivo, se utilizan los \u00edndices para filtrarla: >>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ] >>> row = [ row[index] for index in indices ] >>> row ['AA', '100'] >>>","title":"Ejercicio 3.4: Creaci\u00f3n de un selector de columnas"},{"location":"03_Program_organization/02_More_functions/#ejercicio-35-realizar-conversion-de-tipos","text":"Modifique la funci\u00f3n parse_csv() para que permita opcionalmente conversiones de tipo que se aplicar\u00e1n a los datos devueltos. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float]) >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int]) >>> shares_held [{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}] >>> Ya exploraste esto en Ejercicio 2.24 . Necesitar\u00e1 insertar el siguiente fragmento de c\u00f3digo en su soluci\u00f3n: ... if types: row = [func(val) for func, val in zip(types, row) ] ...","title":"Ejercicio 3.5: Realizar conversi\u00f3n de tipos"},{"location":"03_Program_organization/02_More_functions/#ejercicio-36-trabajar-sin-encabezados","text":"Algunos archivos CSV no incluyen ninguna informaci\u00f3n de encabezado. Por ejemplo, el archivo prices.csv tiene este aspecto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 ... Modifique la funci\u00f3n parse_csv() para que pueda trabajar con dichos archivos creando una lista de tuplas en su lugar. Por ejemplo: >>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> prices [('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)] >>> Para realizar este cambio, deber\u00e1 modificar el c\u00f3digo de modo que la primera l\u00ednea de datos No se interprete como una l\u00ednea de encabezado. Adem\u00e1s, deber\u00e1 asegurarse de no crear diccionarios, ya que ya no hay nombres de columnas para usar como claves.","title":"Ejercicio 3.6: Trabajar sin encabezados"},{"location":"03_Program_organization/02_More_functions/#ejercicio-37-elegir-un-delimitador-de-columna-diferente","text":"Aunque los archivos CSV son bastante comunes, tambi\u00e9n es posible encontrar un archivo que utilice un separador de columnas diferente, como una tabulaci\u00f3n o un espacio. Por ejemplo, el archivo Data/portfolio.dat tiene este aspecto: name shares price \"AA\" 100 32.20 \"IBM\" 50 91.10 \"CAT\" 150 83.44 \"MSFT\" 200 51.23 \"GE\" 95 40.37 \"MSFT\" 50 65.10 \"IBM\" 100 70.44 La funci\u00f3n csv.reader() permite indicar un delimitador de columna diferente de la siguiente manera: rows = csv.reader(f, delimiter=' ') `` ` Modifique su funci\u00f3n `parse_csv()` para que tambi\u00e9n permita cambiar el delimitador. Por ejemplo: ```python >>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>>","title":"Ejercicio 3.7: Elegir un delimitador de columna diferente"},{"location":"03_Program_organization/02_More_functions/#comentario","text":"Si has llegado hasta aqu\u00ed, has creado una bonita funci\u00f3n de biblioteca que es realmente \u00fatil. Puedes usarla para analizar archivos CSV arbitrarios, seleccionar columnas de inter\u00e9s, realizar conversiones de tipos, sin tener que preocuparte demasiado por el funcionamiento interno de los archivos o el m\u00f3dulo csv . Contenido | Anterior (3.1 Funciones y escritura de scripts) | Pr\u00f3ximo (3.3 Comprobaci\u00f3n de errores)","title":"Comentario"},{"location":"03_Program_organization/03_Error_checking/","text":"Contenido | Anterior (3.2 M\u00e1s detalles sobre las funciones) | Pr\u00f3ximo (3.4 M\u00f3dulos) 3.3 Comprobaci\u00f3n de errores Aunque las excepciones se introdujeron anteriormente, esta secci\u00f3n completa algunos detalles adicionales sobre la comprobaci\u00f3n de errores y el manejo de excepciones. C\u00f3mo fallan los programas Python no realiza ninguna comprobaci\u00f3n o validaci\u00f3n de los tipos o valores de los argumentos de la funci\u00f3n. Una funci\u00f3n funcionar\u00e1 con cualquier dato que sea compatible con las declaraciones de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hello', 'World') # 'HelloWorld' add('3', '4') # '34' Si hay errores en una funci\u00f3n, aparecen en tiempo de ejecuci\u00f3n (como una excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'int' and 'str' >>> Para verificar el c\u00f3digo, se hace mucho hincapi\u00e9 en las pruebas (que se tratan m\u00e1s adelante). Excepciones Las excepciones se utilizan para se\u00f1alar errores. Para generar una excepci\u00f3n usted mismo, utilice la declaraci\u00f3n raise . if name not in authorized: raise RuntimeError(f'{name} not authorized') Para capturar una excepci\u00f3n, utilice try-except . try: authenticate(username) except RuntimeError as e: print(e) Manejo de excepciones Las excepciones se propagan al primer except coincidente. def grok(): ... raise RuntimeError('\u00a1Vaya!') # Excepci\u00f3n generada aqu\u00ed def spam(): grok() # Llamada que generar\u00e1 la excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed ... def foo(): try: bar() except RuntimeError as e: # La excepci\u00f3n NO llega aqu\u00ed ... foo() Para manejar la excepci\u00f3n, coloque declaraciones en el bloque except . Puede agregar cualquier declaraci\u00f3n que desee para manejar el error. def grok():... raise RuntimeError('\u00a1Vaya!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed declaraciones # Usa esta declaraci\u00f3n declaraciones ... bar() Despu\u00e9s de la manipulaci\u00f3n, la ejecuci\u00f3n se reanuda con la primera declaraci\u00f3n despu\u00e9s de try-except . def grok(): ... raise RuntimeError('\u00a1Vaya!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed declaraciones declaraciones ... declaraciones # Reanuda la ejecuci\u00f3n aqu\u00ed declaraciones # Y contin\u00faa aqu\u00ed ... bar() Excepciones integradas Hay alrededor de dos docenas de excepciones integradas. Generalmente el nombre de la excepci\u00f3n es indicativo de lo que est\u00e1 mal (por ejemplo, se genera un ValueError porque usted proporcion\u00f3 un valor incorrecto). Esta no es una lista exhaustiva. Consulte la documentaci\u00f3n para obtener m\u00e1s informaci\u00f3n. ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError Valores de excepci\u00f3n Las excepciones tienen un valor asociado. Contiene informaci\u00f3n m\u00e1s espec\u00edfica sobre lo que est\u00e1 mal. raise RuntimeError('Nombre de usuario no v\u00e1lido') Este valor es parte de la instancia de excepci\u00f3n que se coloca en la variable suministrada a except . try: ... except RuntimeError as e: # `e` contiene la excepci\u00f3n generada ... e es una instancia del tipo de excepci\u00f3n. Sin embargo, a menudo parece una cadena cuando se imprime. except RuntimeError as e: print('Fall\u00f3 : Raz\u00f3n', e) Captura de m\u00faltiples errores Puedes capturar diferentes tipos de excepciones usando m\u00faltiples bloques except . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Alternativamente, si las instrucciones para manejarlas son las mismas, puede agruparlas: try: ... except (IOError,LookupError,RuntimeError) as e: ... Capturar todos los errores Para capturar cualquier excepci\u00f3n, use Exception de esta manera: try: ... except Exception: # DANGER. Vea a continuaci\u00f3n print('Un error ha ocurrido') En general, escribir c\u00f3digo como ese es una mala idea porque no tendr\u00e1 idea de por qu\u00e9 fall\u00f3. Forma incorrecta de capturar errores Esta es la forma incorrecta de usar excepciones. try: go_do_something() except Exception: print('La computadora dice no') Esto captura todos los errores posibles y puede hacer que sea imposible depurar cuando el c\u00f3digo falla por alguna raz\u00f3n que no esperabas en absoluto (por ejemplo, m\u00f3dulo Python desinstalado, etc.). Un enfoque un poco mejor Si vas a capturar todos los errores, este es un enfoque m\u00e1s sensato. try: go_do_something() except Exception as e: print('La computadora dice no. Raz\u00f3n :', e) Informa de una raz\u00f3n espec\u00edfica de la falla. Casi siempre es una buena idea tener alg\u00fan mecanismo para ver o informar errores cuando escribe c\u00f3digo que captura todas las excepciones posibles. En general, sin embargo, es mejor capturar el error de la forma m\u00e1s espec\u00edfica posible. Solo capture los errores que realmente puede manejar. Deje pasar otros errores, tal vez alg\u00fan otro c\u00f3digo pueda manejarlos. Volver a generar una excepci\u00f3n Use raise para propagar un error capturado. try: go_do_something() except Exception as e: print('La computadora dice no. Raz\u00f3n :', e) raise Esto le permite tomar medidas (por ejemplo, registrar) y pasar el error al autor de la llamada. Mejores pr\u00e1cticas para excepciones No capture excepciones. Falle r\u00e1pido y en voz alta. Si es importante, alguien m\u00e1s se ocupar\u00e1 del problema. Solo capture una excepci\u00f3n si usted es esa persona. Es decir, solo captura errores de los que puedas recuperarte y seguir adelante de forma sensata. Instrucci\u00f3n finally Especifica el c\u00f3digo que debe ejecutarse independientemente de si se produce o no una excepci\u00f3n. lock = Lock() ... lock.acquire() try: ... finally: lock.release() # esto SIEMPRE se ejecutar\u00e1. Con y sin excepci\u00f3n. Se utiliza habitualmente para gestionar recursos de forma segura (especialmente bloqueos, archivos, etc.). Instrucci\u00f3n with En el c\u00f3digo moderno, try-finally suele sustituirse por la instrucci\u00f3n with . lock = Lock() with lock: # bloqueo adquirido ... # bloqueo liberado Un ejemplo m\u00e1s familiar: with open(filename) as f: # Use el archivo ... # Cierre el archivo with define un contexto de uso para un recurso. Cuando la ejecuci\u00f3n abandona ese contexto, se liberan los recursos. with s\u00f3lo funciona con ciertos objetos que han sido programados espec\u00edficamente para soportarlo. Ejercicios Ejercicio 3.8: Generar excepciones La funci\u00f3n parse_csv() que escribi\u00f3 en la \u00faltima secci\u00f3n permite seleccionar columnas especificadas por el usuario, pero eso s\u00f3lo funciona si el archivo de datos de entrada tiene encabezados de columna. Modifique el c\u00f3digo para que se genere una excepci\u00f3n si se pasan los argumentos select y has_headers=False . Por ejemplo: >>> parse_csv('Data/prices.csv', select=['name','price'], has_headers=False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"select argument require column headers\") RuntimeError: select argument require column headers >>> Despu\u00e9s de agregar esta verificaci\u00f3n, puede preguntarse si deber\u00eda realizar otros tipos de verificaciones de integridad en la funci\u00f3n. Por ejemplo, \u00bfdeber\u00eda verificar que el nombre del archivo sea una cadena, que los tipos sean una lista o algo de esa naturaleza? Como regla general, generalmente es mejor omitir dichas pruebas y simplemente dejar que el programa falle en las entradas incorrectas. El mensaje de traceback se\u00f1alar\u00e1 la fuente del problema y puede ayudar en la depuraci\u00f3n. La raz\u00f3n principal para agregar la comprobaci\u00f3n anterior es evitar ejecutar el c\u00f3digo en un modo sin sentido (por ejemplo, usar una funci\u00f3n que requiere encabezados de columna, pero especificar simult\u00e1neamente que no hay encabezados). Esto indica un error de programaci\u00f3n por parte del c\u00f3digo que realiza la llamada. Comprobar los casos que \"no deber\u00edan ocurrir\" suele ser una buena idea. Ejercicio 3.9: Captura de excepciones La funci\u00f3n parse_csv() que escribiste se usa para procesar todo el contenido de un archivo. Sin embargo, en el mundo real, es posible que los archivos de entrada tengan datos corruptos, faltantes o sucios. Pruebe este experimento: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> Modifique la funci\u00f3n parse_csv() para capturar todas las excepciones ValueError generadas durante la creaci\u00f3n de registros e imprimir un mensaje de advertencia para las filas que no se pueden convertir. El mensaje debe incluir el n\u00famero de fila e informaci\u00f3n sobre el motivo por el que fall\u00f3. Para probar su funci\u00f3n, intente leer el archivo Data/missing.csv anterior. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Fila 4: No se pudo convertir ['MSFT', '', '51.23'] Fila 4: Motivo por el que el literal no es v\u00e1lido para int() con base 10: '' Fila 7: No se pudo convertir ['IBM', '', '70.44'] Fila 7: Motivo por el que el literal no es v\u00e1lido para int() con base 10: '' >>> >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40,37, 'name': 'GE', 'shares': 95}, {'price': 65,1, 'name': 'MSFT', 'shares': 50}] >>> Ejercicio 3.10: Silenciamiento de errores Modifique la funci\u00f3n parse_csv() para que los mensajes de error de an\u00e1lisis puedan silenciarse si el usuario lo desea expl\u00edcitamente. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'pricename': 'MSFT', 'shares': 50}] >>> El manejo de errores es una de las cosas m\u00e1s dif\u00edciles de hacer bien en la mayor\u00eda de los programas. Como regla general, no deber\u00eda ignorar los errores en silencio. En cambio, es mejor informar los problemas y darle al usuario una opci\u00f3n para silenciar el mensaje de error si as\u00ed lo desea. Contenido | Anterior (3.2 M\u00e1s detalles sobre las funciones) | Pr\u00f3ximo (3.4 M\u00f3dulos)","title":"03_Error_checking"},{"location":"03_Program_organization/03_Error_checking/#33-comprobacion-de-errores","text":"Aunque las excepciones se introdujeron anteriormente, esta secci\u00f3n completa algunos detalles adicionales sobre la comprobaci\u00f3n de errores y el manejo de excepciones.","title":"3.3 Comprobaci\u00f3n de errores"},{"location":"03_Program_organization/03_Error_checking/#como-fallan-los-programas","text":"Python no realiza ninguna comprobaci\u00f3n o validaci\u00f3n de los tipos o valores de los argumentos de la funci\u00f3n. Una funci\u00f3n funcionar\u00e1 con cualquier dato que sea compatible con las declaraciones de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hello', 'World') # 'HelloWorld' add('3', '4') # '34' Si hay errores en una funci\u00f3n, aparecen en tiempo de ejecuci\u00f3n (como una excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'int' and 'str' >>> Para verificar el c\u00f3digo, se hace mucho hincapi\u00e9 en las pruebas (que se tratan m\u00e1s adelante).","title":"C\u00f3mo fallan los programas"},{"location":"03_Program_organization/03_Error_checking/#excepciones","text":"Las excepciones se utilizan para se\u00f1alar errores. Para generar una excepci\u00f3n usted mismo, utilice la declaraci\u00f3n raise . if name not in authorized: raise RuntimeError(f'{name} not authorized') Para capturar una excepci\u00f3n, utilice try-except . try: authenticate(username) except RuntimeError as e: print(e)","title":"Excepciones"},{"location":"03_Program_organization/03_Error_checking/#manejo-de-excepciones","text":"Las excepciones se propagan al primer except coincidente. def grok(): ... raise RuntimeError('\u00a1Vaya!') # Excepci\u00f3n generada aqu\u00ed def spam(): grok() # Llamada que generar\u00e1 la excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed ... def foo(): try: bar() except RuntimeError as e: # La excepci\u00f3n NO llega aqu\u00ed ... foo() Para manejar la excepci\u00f3n, coloque declaraciones en el bloque except . Puede agregar cualquier declaraci\u00f3n que desee para manejar el error. def grok():... raise RuntimeError('\u00a1Vaya!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed declaraciones # Usa esta declaraci\u00f3n declaraciones ... bar() Despu\u00e9s de la manipulaci\u00f3n, la ejecuci\u00f3n se reanuda con la primera declaraci\u00f3n despu\u00e9s de try-except . def grok(): ... raise RuntimeError('\u00a1Vaya!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n detectada aqu\u00ed declaraciones declaraciones ... declaraciones # Reanuda la ejecuci\u00f3n aqu\u00ed declaraciones # Y contin\u00faa aqu\u00ed ... bar()","title":"Manejo de excepciones"},{"location":"03_Program_organization/03_Error_checking/#excepciones-integradas","text":"Hay alrededor de dos docenas de excepciones integradas. Generalmente el nombre de la excepci\u00f3n es indicativo de lo que est\u00e1 mal (por ejemplo, se genera un ValueError porque usted proporcion\u00f3 un valor incorrecto). Esta no es una lista exhaustiva. Consulte la documentaci\u00f3n para obtener m\u00e1s informaci\u00f3n. ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError","title":"Excepciones integradas"},{"location":"03_Program_organization/03_Error_checking/#valores-de-excepcion","text":"Las excepciones tienen un valor asociado. Contiene informaci\u00f3n m\u00e1s espec\u00edfica sobre lo que est\u00e1 mal. raise RuntimeError('Nombre de usuario no v\u00e1lido') Este valor es parte de la instancia de excepci\u00f3n que se coloca en la variable suministrada a except . try: ... except RuntimeError as e: # `e` contiene la excepci\u00f3n generada ... e es una instancia del tipo de excepci\u00f3n. Sin embargo, a menudo parece una cadena cuando se imprime. except RuntimeError as e: print('Fall\u00f3 : Raz\u00f3n', e)","title":"Valores de excepci\u00f3n"},{"location":"03_Program_organization/03_Error_checking/#captura-de-multiples-errores","text":"Puedes capturar diferentes tipos de excepciones usando m\u00faltiples bloques except . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Alternativamente, si las instrucciones para manejarlas son las mismas, puede agruparlas: try: ... except (IOError,LookupError,RuntimeError) as e: ...","title":"Captura de m\u00faltiples errores"},{"location":"03_Program_organization/03_Error_checking/#capturar-todos-los-errores","text":"Para capturar cualquier excepci\u00f3n, use Exception de esta manera: try: ... except Exception: # DANGER. Vea a continuaci\u00f3n print('Un error ha ocurrido') En general, escribir c\u00f3digo como ese es una mala idea porque no tendr\u00e1 idea de por qu\u00e9 fall\u00f3.","title":"Capturar todos los errores"},{"location":"03_Program_organization/03_Error_checking/#forma-incorrecta-de-capturar-errores","text":"Esta es la forma incorrecta de usar excepciones. try: go_do_something() except Exception: print('La computadora dice no') Esto captura todos los errores posibles y puede hacer que sea imposible depurar cuando el c\u00f3digo falla por alguna raz\u00f3n que no esperabas en absoluto (por ejemplo, m\u00f3dulo Python desinstalado, etc.).","title":"Forma incorrecta de capturar errores"},{"location":"03_Program_organization/03_Error_checking/#un-enfoque-un-poco-mejor","text":"Si vas a capturar todos los errores, este es un enfoque m\u00e1s sensato. try: go_do_something() except Exception as e: print('La computadora dice no. Raz\u00f3n :', e) Informa de una raz\u00f3n espec\u00edfica de la falla. Casi siempre es una buena idea tener alg\u00fan mecanismo para ver o informar errores cuando escribe c\u00f3digo que captura todas las excepciones posibles. En general, sin embargo, es mejor capturar el error de la forma m\u00e1s espec\u00edfica posible. Solo capture los errores que realmente puede manejar. Deje pasar otros errores, tal vez alg\u00fan otro c\u00f3digo pueda manejarlos.","title":"Un enfoque un poco mejor"},{"location":"03_Program_organization/03_Error_checking/#volver-a-generar-una-excepcion","text":"Use raise para propagar un error capturado. try: go_do_something() except Exception as e: print('La computadora dice no. Raz\u00f3n :', e) raise Esto le permite tomar medidas (por ejemplo, registrar) y pasar el error al autor de la llamada.","title":"Volver a generar una excepci\u00f3n"},{"location":"03_Program_organization/03_Error_checking/#mejores-practicas-para-excepciones","text":"No capture excepciones. Falle r\u00e1pido y en voz alta. Si es importante, alguien m\u00e1s se ocupar\u00e1 del problema. Solo capture una excepci\u00f3n si usted es esa persona. Es decir, solo captura errores de los que puedas recuperarte y seguir adelante de forma sensata.","title":"Mejores pr\u00e1cticas para excepciones"},{"location":"03_Program_organization/03_Error_checking/#instruccion-finally","text":"Especifica el c\u00f3digo que debe ejecutarse independientemente de si se produce o no una excepci\u00f3n. lock = Lock() ... lock.acquire() try: ... finally: lock.release() # esto SIEMPRE se ejecutar\u00e1. Con y sin excepci\u00f3n. Se utiliza habitualmente para gestionar recursos de forma segura (especialmente bloqueos, archivos, etc.).","title":"Instrucci\u00f3n finally"},{"location":"03_Program_organization/03_Error_checking/#instruccion-with","text":"En el c\u00f3digo moderno, try-finally suele sustituirse por la instrucci\u00f3n with . lock = Lock() with lock: # bloqueo adquirido ... # bloqueo liberado Un ejemplo m\u00e1s familiar: with open(filename) as f: # Use el archivo ... # Cierre el archivo with define un contexto de uso para un recurso. Cuando la ejecuci\u00f3n abandona ese contexto, se liberan los recursos. with s\u00f3lo funciona con ciertos objetos que han sido programados espec\u00edficamente para soportarlo.","title":"Instrucci\u00f3n with"},{"location":"03_Program_organization/03_Error_checking/#ejercicios","text":"","title":"Ejercicios"},{"location":"03_Program_organization/03_Error_checking/#ejercicio-38-generar-excepciones","text":"La funci\u00f3n parse_csv() que escribi\u00f3 en la \u00faltima secci\u00f3n permite seleccionar columnas especificadas por el usuario, pero eso s\u00f3lo funciona si el archivo de datos de entrada tiene encabezados de columna. Modifique el c\u00f3digo para que se genere una excepci\u00f3n si se pasan los argumentos select y has_headers=False . Por ejemplo: >>> parse_csv('Data/prices.csv', select=['name','price'], has_headers=False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"select argument require column headers\") RuntimeError: select argument require column headers >>> Despu\u00e9s de agregar esta verificaci\u00f3n, puede preguntarse si deber\u00eda realizar otros tipos de verificaciones de integridad en la funci\u00f3n. Por ejemplo, \u00bfdeber\u00eda verificar que el nombre del archivo sea una cadena, que los tipos sean una lista o algo de esa naturaleza? Como regla general, generalmente es mejor omitir dichas pruebas y simplemente dejar que el programa falle en las entradas incorrectas. El mensaje de traceback se\u00f1alar\u00e1 la fuente del problema y puede ayudar en la depuraci\u00f3n. La raz\u00f3n principal para agregar la comprobaci\u00f3n anterior es evitar ejecutar el c\u00f3digo en un modo sin sentido (por ejemplo, usar una funci\u00f3n que requiere encabezados de columna, pero especificar simult\u00e1neamente que no hay encabezados). Esto indica un error de programaci\u00f3n por parte del c\u00f3digo que realiza la llamada. Comprobar los casos que \"no deber\u00edan ocurrir\" suele ser una buena idea.","title":"Ejercicio 3.8: Generar excepciones"},{"location":"03_Program_organization/03_Error_checking/#ejercicio-39-captura-de-excepciones","text":"La funci\u00f3n parse_csv() que escribiste se usa para procesar todo el contenido de un archivo. Sin embargo, en el mundo real, es posible que los archivos de entrada tengan datos corruptos, faltantes o sucios. Pruebe este experimento: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> Modifique la funci\u00f3n parse_csv() para capturar todas las excepciones ValueError generadas durante la creaci\u00f3n de registros e imprimir un mensaje de advertencia para las filas que no se pueden convertir. El mensaje debe incluir el n\u00famero de fila e informaci\u00f3n sobre el motivo por el que fall\u00f3. Para probar su funci\u00f3n, intente leer el archivo Data/missing.csv anterior. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Fila 4: No se pudo convertir ['MSFT', '', '51.23'] Fila 4: Motivo por el que el literal no es v\u00e1lido para int() con base 10: '' Fila 7: No se pudo convertir ['IBM', '', '70.44'] Fila 7: Motivo por el que el literal no es v\u00e1lido para int() con base 10: '' >>> >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40,37, 'name': 'GE', 'shares': 95}, {'price': 65,1, 'name': 'MSFT', 'shares': 50}] >>>","title":"Ejercicio 3.9: Captura de excepciones"},{"location":"03_Program_organization/03_Error_checking/#ejercicio-310-silenciamiento-de-errores","text":"Modifique la funci\u00f3n parse_csv() para que los mensajes de error de an\u00e1lisis puedan silenciarse si el usuario lo desea expl\u00edcitamente. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'pricename': 'MSFT', 'shares': 50}] >>> El manejo de errores es una de las cosas m\u00e1s dif\u00edciles de hacer bien en la mayor\u00eda de los programas. Como regla general, no deber\u00eda ignorar los errores en silencio. En cambio, es mejor informar los problemas y darle al usuario una opci\u00f3n para silenciar el mensaje de error si as\u00ed lo desea. Contenido | Anterior (3.2 M\u00e1s detalles sobre las funciones) | Pr\u00f3ximo (3.4 M\u00f3dulos)","title":"Ejercicio 3.10: Silenciamiento de errores"},{"location":"03_Program_organization/04_Modules/","text":"Contenido | Anterior (3.3 Comprobaci\u00f3n de errores) | Pr\u00f3ximo (3.5 M\u00f3dulo principal) 3.4 M\u00f3dulos Esta secci\u00f3n presenta el concepto de m\u00f3dulos y el trabajo con funciones que abarcan varios archivos. M\u00f3dulos e importaci\u00f3n Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... La declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hola') ... Espacio de nombres Un m\u00f3dulo es una colecci\u00f3n de valores nombrados y a veces se dice que es un espacio de nombres o namespace . Los nombres son todas las variables y funciones globales definidas en el archivo fuente. Despu\u00e9s de la importaci\u00f3n, el nombre del m\u00f3dulo se utiliza como prefijo. De ah\u00ed el espacio de nombres . import foo a = foo.grok(2) b = foo.spam('Hola') ... El nombre del m\u00f3dulo est\u00e1 directamente vinculado al nombre del archivo (foo -> foo.py). Definiciones globales Todo lo definido en el \u00e1mbito global es lo que llena el espacio de nombres del m\u00f3dulo. Considere dos m\u00f3dulos que definen la misma variable x . # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... En este caso, las definiciones de x se refieren a diferentes variables. Una es foo.x y la otra es bar.x . Diferentes m\u00f3dulos pueden usar los mismos nombres y esos nombres no entrar\u00e1n en conflicto entre s\u00ed. Los m\u00f3dulos est\u00e1n aislados. M\u00f3dulos como entornos Los m\u00f3dulos forman un entorno envolvente para todo el c\u00f3digo definido en su interior. # foo.py x = 42 def grok(a): print(x) Las variables globales siempre est\u00e1n vinculadas al m\u00f3dulo envolvente (mismo archivo). Cada archivo fuente es su propio peque\u00f1o universo. Ejecuci\u00f3n de m\u00f3dulo Cuando se importa un m\u00f3dulo, todas las instrucciones del m\u00f3dulo se ejecutan una tras otra hasta llegar al final del archivo. El contenido del espacio de nombres del m\u00f3dulo son todos los nombres globales que todav\u00eda est\u00e1n definidos al final del proceso de ejecuci\u00f3n. Si hay instrucciones de script que realizan tareas en el \u00e1mbito global (imprimir, crear archivos, etc.), ver\u00e1 que se ejecutan durante la importaci\u00f3n. Instrucci\u00f3n import as Puede cambiar el nombre de un m\u00f3dulo mientras lo importa: import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona igual que una importaci\u00f3n normal. Simplemente cambia el nombre del m\u00f3dulo en ese archivo. Importaci\u00f3n de m\u00f3dulo from Esto selecciona s\u00edmbolos seleccionados de un m\u00f3dulo y los pone a disposici\u00f3n localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esto permite que se utilicen partes de un m\u00f3dulo sin tener que escribir el prefijo del m\u00f3dulo. Es \u00fatil para nombres de uso frecuente. Comentarios sobre la importaci\u00f3n Las variaciones en la importaci\u00f3n no cambian la forma en que funcionan los m\u00f3dulos. import math # versus import math as m # versus from math import cos, sin ... Espec\u00edficamente, import siempre ejecuta el archivo completo y los m\u00f3dulos siguen siendo entornos aislados. La declaraci\u00f3n import module as solo cambia el nombre localmente. La declaraci\u00f3n from math import cos, sin todav\u00eda carga el m\u00f3dulo matem\u00e1tico completo detr\u00e1s de escena. Simplemente copia los nombres cos y sin del m\u00f3dulo al espacio local despu\u00e9s de que finaliza. Carga de m\u00f3dulos Cada m\u00f3dulo se carga y se ejecuta solo una vez . Nota: Las importaciones repetidas solo devuelven una referencia al m\u00f3dulo cargado previamente. sys.modules es un diccionario de todos los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: Surge una confusi\u00f3n com\u00fan si repite una declaraci\u00f3n import despu\u00e9s de cambiar el c\u00f3digo fuente de un m\u00f3dulo. Debido a la cach\u00e9 de m\u00f3dulos sys.modules , las importaciones repetidas siempre devuelven el m\u00f3dulo cargado previamente, incluso si se realiz\u00f3 un cambio. La forma m\u00e1s segura de cargar c\u00f3digo modificado en Python es salir y reiniciar el int\u00e9rprete. Localizaci\u00f3n de m\u00f3dulos Python consulta una lista de rutas (sys.path) cuando busca m\u00f3dulos. >>> import sys >>> sys.path [ '', '/usr/local/lib/python36/python36.zip', '/usr/local/lib/python36', ... ] El directorio de trabajo actual suele ser el primero. Ruta de b\u00fasqueda de m\u00f3dulos Como se indic\u00f3, sys.path contiene las rutas de b\u00fasqueda. Puede ajustarlas manualmente si es necesario. import sys sys.path.append('/project/foo/pyfiles') Las rutas tambi\u00e9n se pueden agregar a trav\u00e9s de variables de entorno. bash % env PYTHONPATH=/project/foo/pyfiles python3 Python 3.13.0 (tags/v3.13.0:60403a5, Oct 7 2024, 09:38:07) [MSC v.1941 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import sys >>> sys.path ['', 'C:\\\\Program Files\\\\Git\\\\project\\\\foo\\\\pyfiles', ...] Como regla general, no deber\u00eda ser necesario ajustar manualmente la ruta de b\u00fasqueda del m\u00f3dulo. Sin embargo, a veces surge si intenta importar c\u00f3digo Python que se encuentra en una ubicaci\u00f3n inusual o que no es f\u00e1cilmente accesible desde el directorio de trabajo actual. Ejercicios Para este ejercicio que involucra m\u00f3dulos, es de vital importancia asegurarse de que est\u00e1 ejecutando Python en un entorno adecuado. Los m\u00f3dulos a menudo presentan a los nuevos programadores problemas relacionados con el directorio de trabajo actual o con la configuraci\u00f3n de la ruta de Python. Para este curso, se supone que est\u00e1 escribiendo todo su c\u00f3digo en el directorio Work/ . Para obtener mejores resultados, debe asegurarse de que tambi\u00e9n est\u00e1 en ese directorio cuando inicia el int\u00e9rprete. Si no es as\u00ed, debe asegurarse de que practical-python/Work se agregue a sys.path . Ejercicio 3.11: Importaciones de m\u00f3dulos En la secci\u00f3n 3, creamos una funci\u00f3n de prop\u00f3sito general parse_csv() para analizar el contenido de los archivos de datos CSV. Ahora, vamos a ver c\u00f3mo usar esa funci\u00f3n en otros programas. Primero, comienza en una nueva ventana de shell. Navega hasta la carpeta donde tienes todos tus archivos. Vamos a importarlos. Inicia el modo interactivo de Python. bash % $ python Python 3.13.0 (tags/v3.13.0:60403a5, Oct 7 2024, 09:38:07) [MSC v.1941 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Una vez que hayas hecho eso, intenta importar algunos de los programas que escribiste anteriormente. Deber\u00edas ver su salida exactamente como antes. Solo para enfatizar, importar un m\u00f3dulo ejecuta su c\u00f3digo. >>> import bounce ... mira el resultado ... >>> import mortgage ... mira el resultado ... >>> import report ... mira el resultado ... >>> Si nada de esto funciona, probablemente est\u00e9s ejecutando Python en el directorio incorrecto. Ahora, intenta importar tu m\u00f3dulo fileparse y obtener ayuda al respecto. >>> import fileparse >>> help(fileparse) ... mira el resultado... >>> dir(fileparse) ... mira el resultado... >>> Intenta usar el m\u00f3dulo para leer algunos datos: >>> portfolio = fileparse.parse_csv('Data/portfolio.csv',select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... mira el resultado... >>> pricelist = fileparse.parse_csv('Data/prices.csv',types=[str,float], has_headers=False) >>> pricelist ... mira el resultado... >>> prices = dict(pricelist) >>> prices ... mira el resultado... >>> prices['IBM'] 106.28 >>> Intenta importar una funci\u00f3n de modo que no necesites incluir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... mira el resultado... >>> Ejercicio 3.12: Uso del m\u00f3dulo de la biblioteca En la secci\u00f3n 2, escribiste un programa report.py que produjo un informe de acciones como este: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Tome ese programa y modif\u00edquelo de modo que todo el procesamiento del archivo de entrada se realice utilizando funciones en su m\u00f3dulo fileparse . Para ello, importe fileparse como m\u00f3dulo y cambie las funciones read_portfolio() y read_prices() para utilizar la funci\u00f3n parse_csv() . Use el modo interactivo al comienzo de este ejercicio como gu\u00eda. Despu\u00e9s, deber\u00eda obtener exactamente el mismo resultado que antes. Ejercicio 3.13: Se dej\u00f3 en blanco intencionalmente (omitir) Ejercicio 3.14: Uso de m\u00e1s importaciones de bibliotecas En la secci\u00f3n 1, escribi\u00f3 un programa pcost.py que lee una cartera y calcula su costo. >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Modifique el archivo pcost.py para que use la funci\u00f3n report.read_portfolio() . Comentario Cuando haya terminado con este ejercicio, deber\u00eda tener tres programas. fileparse.py que contiene una funci\u00f3n parse_csv() de prop\u00f3sito general. report.py que produce un informe atractivo, pero tambi\u00e9n contiene las funciones read_portfolio() y read_prices() . Y finalmente, pcost.py que calcula el costo de la cartera, pero hace uso de la funci\u00f3n read_portfolio() escrita para el programa report.py\\ . Contenido | Anterior (3.3 Comprobaci\u00f3n de errores) | Pr\u00f3ximo (3.5 M\u00f3dulo principal)","title":"04_Modules"},{"location":"03_Program_organization/04_Modules/#34-modulos","text":"Esta secci\u00f3n presenta el concepto de m\u00f3dulos y el trabajo con funciones que abarcan varios archivos.","title":"3.4 M\u00f3dulos"},{"location":"03_Program_organization/04_Modules/#modulos-e-importacion","text":"Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... La declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hola') ...","title":"M\u00f3dulos e importaci\u00f3n"},{"location":"03_Program_organization/04_Modules/#espacio-de-nombres","text":"Un m\u00f3dulo es una colecci\u00f3n de valores nombrados y a veces se dice que es un espacio de nombres o namespace . Los nombres son todas las variables y funciones globales definidas en el archivo fuente. Despu\u00e9s de la importaci\u00f3n, el nombre del m\u00f3dulo se utiliza como prefijo. De ah\u00ed el espacio de nombres . import foo a = foo.grok(2) b = foo.spam('Hola') ... El nombre del m\u00f3dulo est\u00e1 directamente vinculado al nombre del archivo (foo -> foo.py).","title":"Espacio de nombres"},{"location":"03_Program_organization/04_Modules/#definiciones-globales","text":"Todo lo definido en el \u00e1mbito global es lo que llena el espacio de nombres del m\u00f3dulo. Considere dos m\u00f3dulos que definen la misma variable x . # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... En este caso, las definiciones de x se refieren a diferentes variables. Una es foo.x y la otra es bar.x . Diferentes m\u00f3dulos pueden usar los mismos nombres y esos nombres no entrar\u00e1n en conflicto entre s\u00ed. Los m\u00f3dulos est\u00e1n aislados.","title":"Definiciones globales"},{"location":"03_Program_organization/04_Modules/#modulos-como-entornos","text":"Los m\u00f3dulos forman un entorno envolvente para todo el c\u00f3digo definido en su interior. # foo.py x = 42 def grok(a): print(x) Las variables globales siempre est\u00e1n vinculadas al m\u00f3dulo envolvente (mismo archivo). Cada archivo fuente es su propio peque\u00f1o universo.","title":"M\u00f3dulos como entornos"},{"location":"03_Program_organization/04_Modules/#ejecucion-de-modulo","text":"Cuando se importa un m\u00f3dulo, todas las instrucciones del m\u00f3dulo se ejecutan una tras otra hasta llegar al final del archivo. El contenido del espacio de nombres del m\u00f3dulo son todos los nombres globales que todav\u00eda est\u00e1n definidos al final del proceso de ejecuci\u00f3n. Si hay instrucciones de script que realizan tareas en el \u00e1mbito global (imprimir, crear archivos, etc.), ver\u00e1 que se ejecutan durante la importaci\u00f3n.","title":"Ejecuci\u00f3n de m\u00f3dulo"},{"location":"03_Program_organization/04_Modules/#instruccion-import-as","text":"Puede cambiar el nombre de un m\u00f3dulo mientras lo importa: import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona igual que una importaci\u00f3n normal. Simplemente cambia el nombre del m\u00f3dulo en ese archivo.","title":"Instrucci\u00f3n import as"},{"location":"03_Program_organization/04_Modules/#importacion-de-modulo-from","text":"Esto selecciona s\u00edmbolos seleccionados de un m\u00f3dulo y los pone a disposici\u00f3n localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esto permite que se utilicen partes de un m\u00f3dulo sin tener que escribir el prefijo del m\u00f3dulo. Es \u00fatil para nombres de uso frecuente.","title":"Importaci\u00f3n de m\u00f3dulo from"},{"location":"03_Program_organization/04_Modules/#comentarios-sobre-la-importacion","text":"Las variaciones en la importaci\u00f3n no cambian la forma en que funcionan los m\u00f3dulos. import math # versus import math as m # versus from math import cos, sin ... Espec\u00edficamente, import siempre ejecuta el archivo completo y los m\u00f3dulos siguen siendo entornos aislados. La declaraci\u00f3n import module as solo cambia el nombre localmente. La declaraci\u00f3n from math import cos, sin todav\u00eda carga el m\u00f3dulo matem\u00e1tico completo detr\u00e1s de escena. Simplemente copia los nombres cos y sin del m\u00f3dulo al espacio local despu\u00e9s de que finaliza.","title":"Comentarios sobre la importaci\u00f3n"},{"location":"03_Program_organization/04_Modules/#carga-de-modulos","text":"Cada m\u00f3dulo se carga y se ejecuta solo una vez . Nota: Las importaciones repetidas solo devuelven una referencia al m\u00f3dulo cargado previamente. sys.modules es un diccionario de todos los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: Surge una confusi\u00f3n com\u00fan si repite una declaraci\u00f3n import despu\u00e9s de cambiar el c\u00f3digo fuente de un m\u00f3dulo. Debido a la cach\u00e9 de m\u00f3dulos sys.modules , las importaciones repetidas siempre devuelven el m\u00f3dulo cargado previamente, incluso si se realiz\u00f3 un cambio. La forma m\u00e1s segura de cargar c\u00f3digo modificado en Python es salir y reiniciar el int\u00e9rprete.","title":"Carga de m\u00f3dulos"},{"location":"03_Program_organization/04_Modules/#localizacion-de-modulos","text":"Python consulta una lista de rutas (sys.path) cuando busca m\u00f3dulos. >>> import sys >>> sys.path [ '', '/usr/local/lib/python36/python36.zip', '/usr/local/lib/python36', ... ] El directorio de trabajo actual suele ser el primero.","title":"Localizaci\u00f3n de m\u00f3dulos"},{"location":"03_Program_organization/04_Modules/#ruta-de-busqueda-de-modulos","text":"Como se indic\u00f3, sys.path contiene las rutas de b\u00fasqueda. Puede ajustarlas manualmente si es necesario. import sys sys.path.append('/project/foo/pyfiles') Las rutas tambi\u00e9n se pueden agregar a trav\u00e9s de variables de entorno. bash % env PYTHONPATH=/project/foo/pyfiles python3 Python 3.13.0 (tags/v3.13.0:60403a5, Oct 7 2024, 09:38:07) [MSC v.1941 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import sys >>> sys.path ['', 'C:\\\\Program Files\\\\Git\\\\project\\\\foo\\\\pyfiles', ...] Como regla general, no deber\u00eda ser necesario ajustar manualmente la ruta de b\u00fasqueda del m\u00f3dulo. Sin embargo, a veces surge si intenta importar c\u00f3digo Python que se encuentra en una ubicaci\u00f3n inusual o que no es f\u00e1cilmente accesible desde el directorio de trabajo actual.","title":"Ruta de b\u00fasqueda de m\u00f3dulos"},{"location":"03_Program_organization/04_Modules/#ejercicios","text":"Para este ejercicio que involucra m\u00f3dulos, es de vital importancia asegurarse de que est\u00e1 ejecutando Python en un entorno adecuado. Los m\u00f3dulos a menudo presentan a los nuevos programadores problemas relacionados con el directorio de trabajo actual o con la configuraci\u00f3n de la ruta de Python. Para este curso, se supone que est\u00e1 escribiendo todo su c\u00f3digo en el directorio Work/ . Para obtener mejores resultados, debe asegurarse de que tambi\u00e9n est\u00e1 en ese directorio cuando inicia el int\u00e9rprete. Si no es as\u00ed, debe asegurarse de que practical-python/Work se agregue a sys.path .","title":"Ejercicios"},{"location":"03_Program_organization/04_Modules/#ejercicio-311-importaciones-de-modulos","text":"En la secci\u00f3n 3, creamos una funci\u00f3n de prop\u00f3sito general parse_csv() para analizar el contenido de los archivos de datos CSV. Ahora, vamos a ver c\u00f3mo usar esa funci\u00f3n en otros programas. Primero, comienza en una nueva ventana de shell. Navega hasta la carpeta donde tienes todos tus archivos. Vamos a importarlos. Inicia el modo interactivo de Python. bash % $ python Python 3.13.0 (tags/v3.13.0:60403a5, Oct 7 2024, 09:38:07) [MSC v.1941 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Una vez que hayas hecho eso, intenta importar algunos de los programas que escribiste anteriormente. Deber\u00edas ver su salida exactamente como antes. Solo para enfatizar, importar un m\u00f3dulo ejecuta su c\u00f3digo. >>> import bounce ... mira el resultado ... >>> import mortgage ... mira el resultado ... >>> import report ... mira el resultado ... >>> Si nada de esto funciona, probablemente est\u00e9s ejecutando Python en el directorio incorrecto. Ahora, intenta importar tu m\u00f3dulo fileparse y obtener ayuda al respecto. >>> import fileparse >>> help(fileparse) ... mira el resultado... >>> dir(fileparse) ... mira el resultado... >>> Intenta usar el m\u00f3dulo para leer algunos datos: >>> portfolio = fileparse.parse_csv('Data/portfolio.csv',select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... mira el resultado... >>> pricelist = fileparse.parse_csv('Data/prices.csv',types=[str,float], has_headers=False) >>> pricelist ... mira el resultado... >>> prices = dict(pricelist) >>> prices ... mira el resultado... >>> prices['IBM'] 106.28 >>> Intenta importar una funci\u00f3n de modo que no necesites incluir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... mira el resultado... >>>","title":"Ejercicio 3.11: Importaciones de m\u00f3dulos"},{"location":"03_Program_organization/04_Modules/#ejercicio-312-uso-del-modulo-de-la-biblioteca","text":"En la secci\u00f3n 2, escribiste un programa report.py que produjo un informe de acciones como este: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Tome ese programa y modif\u00edquelo de modo que todo el procesamiento del archivo de entrada se realice utilizando funciones en su m\u00f3dulo fileparse . Para ello, importe fileparse como m\u00f3dulo y cambie las funciones read_portfolio() y read_prices() para utilizar la funci\u00f3n parse_csv() . Use el modo interactivo al comienzo de este ejercicio como gu\u00eda. Despu\u00e9s, deber\u00eda obtener exactamente el mismo resultado que antes.","title":"Ejercicio 3.12: Uso del m\u00f3dulo de la biblioteca"},{"location":"03_Program_organization/04_Modules/#ejercicio-313-se-dejo-en-blanco-intencionalmente-omitir","text":"","title":"Ejercicio 3.13: Se dej\u00f3 en blanco intencionalmente (omitir)"},{"location":"03_Program_organization/04_Modules/#ejercicio-314-uso-de-mas-importaciones-de-bibliotecas","text":"En la secci\u00f3n 1, escribi\u00f3 un programa pcost.py que lee una cartera y calcula su costo. >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Modifique el archivo pcost.py para que use la funci\u00f3n report.read_portfolio() .","title":"Ejercicio 3.14: Uso de m\u00e1s importaciones de bibliotecas"},{"location":"03_Program_organization/04_Modules/#comentario","text":"Cuando haya terminado con este ejercicio, deber\u00eda tener tres programas. fileparse.py que contiene una funci\u00f3n parse_csv() de prop\u00f3sito general. report.py que produce un informe atractivo, pero tambi\u00e9n contiene las funciones read_portfolio() y read_prices() . Y finalmente, pcost.py que calcula el costo de la cartera, pero hace uso de la funci\u00f3n read_portfolio() escrita para el programa report.py\\ . Contenido | Anterior (3.3 Comprobaci\u00f3n de errores) | Pr\u00f3ximo (3.5 M\u00f3dulo principal)","title":"Comentario"},{"location":"03_Program_organization/05_Main_module/","text":"Conteido | Anterior (3.4 M\u00f3dulos) | Pr\u00f3ximo (3.6 Discusi\u00f3n sobre el dise\u00f1o) 3.5 M\u00f3dulo principal Esta secci\u00f3n presenta el concepto de un programa principal o m\u00f3dulo principal. Funciones principales En muchos lenguajes de programaci\u00f3n, existe el concepto de una funci\u00f3n o m\u00e9todo principal . // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Esta es la primera funci\u00f3n que se ejecuta cuando se inicia una aplicaci\u00f3n. M\u00f3dulo principal de Python Python no tiene una funci\u00f3n o m\u00e9todo principal . En cambio, hay un m\u00f3dulo principal . El m\u00f3dulo principal es el archivo fuente que se ejecuta primero. bash % python3 prog.py ... Cualquier archivo que le d\u00e9 al int\u00e9rprete al inicio se convierte en principal . No importa el nombre. __main__ verificaci\u00f3n Es una pr\u00e1ctica est\u00e1ndar para los m\u00f3dulos que se ejecutan como un script principal usar esta convenci\u00f3n: # prog.py ... if __name__ == '__main__': # Ejecutando como el programa principal ... declaraciones ... Las declaraciones incluidas dentro de la declaraci\u00f3n if se convierten en el programa principal . Programas principales vs. importaciones de bibliotecas Cualquier archivo Python puede ejecutarse como principal o como una importaci\u00f3n de biblioteca: bash % python3 prog.py # Ejecutando como principal import prog # Ejecutando como importaci\u00f3n de biblioteca En ambos casos, __name__ es el nombre del m\u00f3dulo. Sin embargo, solo se establecer\u00e1 en __main__ si se ejecuta como principal. Por lo general, no desea que las declaraciones que son parte del programa principal se ejecuten en una importaci\u00f3n de biblioteca. Por lo tanto, es com\u00fan tener un if- check en el c\u00f3digo que se puede usar de cualquier manera. if __name__ == '__main__': # No se ejecuta si se carga con importaci\u00f3n ... Plantilla de programa A continuaci\u00f3n, se incluye una plantilla de programa com\u00fan para escribir un programa Python: # prog.py # Declaraciones de importaci\u00f3n (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(): ... if __name__ == '__main__': main() Herramientas de l\u00ednea de comandos Python se utiliza a menudo para herramientas de l\u00ednea de comandos bash % python3 report.py portfolio.csv prices.csv Significa que los scripts se ejecutan desde el shell/terminal. Los casos de uso m\u00e1s comunes son la automatizaci\u00f3n, las tareas en segundo plano, etc. Argumentos de la l\u00ednea de comandos La l\u00ednea de comandos es una lista de cadenas de texto. bash % python3 -i report.py portfolio.csv prices.csv Esta lista de cadenas de texto se encuentra en sys.argv . # En el comando bash anterior >>> import sys >>> sys.argv # ['report.py, 'portfolio.csv', 'prices.csv'] A continuaci\u00f3n, se incluye un ejemplo simple de procesamiento de argumentos: import sys if len(sys.argv) != 3: raise SystemExit(f'Usage: {sys.argv[0]} ' 'portfile pricefile') portfile = sys.argv[1] pricefile = sys.argv[2] ... E/S est\u00e1ndar La entrada/salida est\u00e1ndar (o stdio ) son archivos que funcionan de la misma manera que los archivos normales. sys.stdout sys.stderr sys.stdin De manera predeterminada, la impresi\u00f3n se dirige a sys.stdout . La entrada se lee desde sys.stdin . Los seguimientos y errores se dirigen a sys.stderr . Tenga en cuenta que stdio podr\u00eda estar conectado a terminales, archivos, tuber\u00edas, etc. bash % python3 prog.py > results.txt # o bash % cmd1 | python prog.py | cmd2 Variables de entorno Las variables de entorno se configuran en el shell. bash % setenv NAME dave bash % setenv RSH ssh bash % python prog.py os.environ es un diccionario que contiene estos valores. import os name = os.environ['NAME'] # 'dave' Los cambios se reflejan en cualquier subproceso que el programa inicie posteriormente. Salida del programa La salida del programa se maneja mediante excepciones. raise SystemExit raise SystemExit(exitcode) raise SystemExit('Mensaje Informativo') Una alternativa. import sys sys.exit(exitcode) Un c\u00f3digo de salida distinto de cero indica un error. La l\u00ednea #! En Unix, la l\u00ednea #! puede iniciar un script como Python. Agregue lo siguiente a la primera l\u00ednea de su archivo de script. #!/usr/bin/env python # prog.py ... Requiere el permiso de ejecuci\u00f3n. bash % chmod +x prog.py # Luego puedes ejecutar bash % prog.py ... output ... Nota: El lanzador de Python en Windows tambi\u00e9n busca la l\u00ednea #! para indicar la versi\u00f3n del idioma. Plantilla de script Finalmente, aqu\u00ed hay una plantilla de c\u00f3digo com\u00fan para programas Python que se ejecutan como scripts de l\u00ednea de comandos: #!/usr/bin/env python # prog.py # Declaraciones de importaci\u00f3n (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(argv): # Analizar argumentos de l\u00ednea de comandos, entorno, etc. ... if __name__ == '__main__': import sys main(sys.argv) Ejercicios Ejercicio 3.15: funciones main() En el archivo report.py , agregue una funci\u00f3n main() que acepte una lista de opciones de l\u00ednea de comandos y produzca el mismo resultado que antes. Deber\u00eda poder ejecutarla en modo interactivo de esta manera: >>> import report >>> report.main(['report.py', 'Data/portfolio.csv', 'Data/prices.csv']) Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el archivo `pcost.py` para que tenga una funci\u00f3n `main()` similar: ```python >>> import pcost >>> pcost.main(['pcost.py', 'Data/portfolio.csv']) Total cost: 44671.15 >>> Ejercicio 3.16: Creaci\u00f3n de scripts Modifique los programas report.py y pcost.py para que puedan ejecutarse como un script en la l\u00ednea de comandos: bash % python3 report.py Data/portfolio.csv Data/prices.csv Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash $ python3 pcost.py Data/portfolio.csv Total cost: 44671.15 Contenido | Anterior (3.4 M\u00f3dulos) | Pr\u00f3ximo (3.6 Discusi\u00f3n sobre el dise\u00f1o)","title":"05_Main_module"},{"location":"03_Program_organization/05_Main_module/#35-modulo-principal","text":"Esta secci\u00f3n presenta el concepto de un programa principal o m\u00f3dulo principal.","title":"3.5 M\u00f3dulo principal"},{"location":"03_Program_organization/05_Main_module/#funciones-principales","text":"En muchos lenguajes de programaci\u00f3n, existe el concepto de una funci\u00f3n o m\u00e9todo principal . // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Esta es la primera funci\u00f3n que se ejecuta cuando se inicia una aplicaci\u00f3n.","title":"Funciones principales"},{"location":"03_Program_organization/05_Main_module/#modulo-principal-de-python","text":"Python no tiene una funci\u00f3n o m\u00e9todo principal . En cambio, hay un m\u00f3dulo principal . El m\u00f3dulo principal es el archivo fuente que se ejecuta primero. bash % python3 prog.py ... Cualquier archivo que le d\u00e9 al int\u00e9rprete al inicio se convierte en principal . No importa el nombre.","title":"M\u00f3dulo principal de Python"},{"location":"03_Program_organization/05_Main_module/#__main__-verificacion","text":"Es una pr\u00e1ctica est\u00e1ndar para los m\u00f3dulos que se ejecutan como un script principal usar esta convenci\u00f3n: # prog.py ... if __name__ == '__main__': # Ejecutando como el programa principal ... declaraciones ... Las declaraciones incluidas dentro de la declaraci\u00f3n if se convierten en el programa principal .","title":"__main__ verificaci\u00f3n"},{"location":"03_Program_organization/05_Main_module/#programas-principales-vs-importaciones-de-bibliotecas","text":"Cualquier archivo Python puede ejecutarse como principal o como una importaci\u00f3n de biblioteca: bash % python3 prog.py # Ejecutando como principal import prog # Ejecutando como importaci\u00f3n de biblioteca En ambos casos, __name__ es el nombre del m\u00f3dulo. Sin embargo, solo se establecer\u00e1 en __main__ si se ejecuta como principal. Por lo general, no desea que las declaraciones que son parte del programa principal se ejecuten en una importaci\u00f3n de biblioteca. Por lo tanto, es com\u00fan tener un if- check en el c\u00f3digo que se puede usar de cualquier manera. if __name__ == '__main__': # No se ejecuta si se carga con importaci\u00f3n ...","title":"Programas principales vs. importaciones de bibliotecas"},{"location":"03_Program_organization/05_Main_module/#plantilla-de-programa","text":"A continuaci\u00f3n, se incluye una plantilla de programa com\u00fan para escribir un programa Python: # prog.py # Declaraciones de importaci\u00f3n (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(): ... if __name__ == '__main__': main()","title":"Plantilla de programa"},{"location":"03_Program_organization/05_Main_module/#herramientas-de-linea-de-comandos","text":"Python se utiliza a menudo para herramientas de l\u00ednea de comandos bash % python3 report.py portfolio.csv prices.csv Significa que los scripts se ejecutan desde el shell/terminal. Los casos de uso m\u00e1s comunes son la automatizaci\u00f3n, las tareas en segundo plano, etc.","title":"Herramientas de l\u00ednea de comandos"},{"location":"03_Program_organization/05_Main_module/#argumentos-de-la-linea-de-comandos","text":"La l\u00ednea de comandos es una lista de cadenas de texto. bash % python3 -i report.py portfolio.csv prices.csv Esta lista de cadenas de texto se encuentra en sys.argv . # En el comando bash anterior >>> import sys >>> sys.argv # ['report.py, 'portfolio.csv', 'prices.csv'] A continuaci\u00f3n, se incluye un ejemplo simple de procesamiento de argumentos: import sys if len(sys.argv) != 3: raise SystemExit(f'Usage: {sys.argv[0]} ' 'portfile pricefile') portfile = sys.argv[1] pricefile = sys.argv[2] ...","title":"Argumentos de la l\u00ednea de comandos"},{"location":"03_Program_organization/05_Main_module/#es-estandar","text":"La entrada/salida est\u00e1ndar (o stdio ) son archivos que funcionan de la misma manera que los archivos normales. sys.stdout sys.stderr sys.stdin De manera predeterminada, la impresi\u00f3n se dirige a sys.stdout . La entrada se lee desde sys.stdin . Los seguimientos y errores se dirigen a sys.stderr . Tenga en cuenta que stdio podr\u00eda estar conectado a terminales, archivos, tuber\u00edas, etc. bash % python3 prog.py > results.txt # o bash % cmd1 | python prog.py | cmd2","title":"E/S est\u00e1ndar"},{"location":"03_Program_organization/05_Main_module/#variables-de-entorno","text":"Las variables de entorno se configuran en el shell. bash % setenv NAME dave bash % setenv RSH ssh bash % python prog.py os.environ es un diccionario que contiene estos valores. import os name = os.environ['NAME'] # 'dave' Los cambios se reflejan en cualquier subproceso que el programa inicie posteriormente.","title":"Variables de entorno"},{"location":"03_Program_organization/05_Main_module/#salida-del-programa","text":"La salida del programa se maneja mediante excepciones. raise SystemExit raise SystemExit(exitcode) raise SystemExit('Mensaje Informativo') Una alternativa. import sys sys.exit(exitcode) Un c\u00f3digo de salida distinto de cero indica un error.","title":"Salida del programa"},{"location":"03_Program_organization/05_Main_module/#la-linea","text":"En Unix, la l\u00ednea #! puede iniciar un script como Python. Agregue lo siguiente a la primera l\u00ednea de su archivo de script. #!/usr/bin/env python # prog.py ... Requiere el permiso de ejecuci\u00f3n. bash % chmod +x prog.py # Luego puedes ejecutar bash % prog.py ... output ... Nota: El lanzador de Python en Windows tambi\u00e9n busca la l\u00ednea #! para indicar la versi\u00f3n del idioma.","title":"La l\u00ednea #!"},{"location":"03_Program_organization/05_Main_module/#plantilla-de-script","text":"Finalmente, aqu\u00ed hay una plantilla de c\u00f3digo com\u00fan para programas Python que se ejecutan como scripts de l\u00ednea de comandos: #!/usr/bin/env python # prog.py # Declaraciones de importaci\u00f3n (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(argv): # Analizar argumentos de l\u00ednea de comandos, entorno, etc. ... if __name__ == '__main__': import sys main(sys.argv)","title":"Plantilla de script"},{"location":"03_Program_organization/05_Main_module/#ejercicios","text":"","title":"Ejercicios"},{"location":"03_Program_organization/05_Main_module/#ejercicio-315-funciones-main","text":"En el archivo report.py , agregue una funci\u00f3n main() que acepte una lista de opciones de l\u00ednea de comandos y produzca el mismo resultado que antes. Deber\u00eda poder ejecutarla en modo interactivo de esta manera: >>> import report >>> report.main(['report.py', 'Data/portfolio.csv', 'Data/prices.csv']) Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el archivo `pcost.py` para que tenga una funci\u00f3n `main()` similar: ```python >>> import pcost >>> pcost.main(['pcost.py', 'Data/portfolio.csv']) Total cost: 44671.15 >>>","title":"Ejercicio 3.15: funciones main()"},{"location":"03_Program_organization/05_Main_module/#ejercicio-316-creacion-de-scripts","text":"Modifique los programas report.py y pcost.py para que puedan ejecutarse como un script en la l\u00ednea de comandos: bash % python3 report.py Data/portfolio.csv Data/prices.csv Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash $ python3 pcost.py Data/portfolio.csv Total cost: 44671.15 Contenido | Anterior (3.4 M\u00f3dulos) | Pr\u00f3ximo (3.6 Discusi\u00f3n sobre el dise\u00f1o)","title":"Ejercicio 3.16: Creaci\u00f3n de scripts"},{"location":"03_Program_organization/06_Design_discussion/","text":"Contenido | Anterior (3.5 M\u00f3dulo principal) | Pr\u00f3ximo (4. Clases y Objetos) 3.6 Discusi\u00f3n sobre el dise\u00f1o En esta secci\u00f3n reconsideramos una decisi\u00f3n de dise\u00f1o tomada anteriormente. Nombres de archivo versus iterables Compare estos dos programas que devuelven el mismo resultado. # Proporcione un nombre de archivo def read_data(filename): records = [] with open(filename) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # Proporcione l\u00edneas def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de estas funciones prefiere? \u00bfPor qu\u00e9? \u00bfCu\u00e1l de estas funciones es m\u00e1s flexible? Idea profunda: \"Duck Typing\" Duck Typing es un concepto de programaci\u00f3n inform\u00e1tica para determinar si un objeto se puede usar para un prop\u00f3sito particular. Es una aplicaci\u00f3n de la prueba del pato . Si parece un pato, nada como un pato y grazna como un pato, entonces probablemente sea un pato. En la segunda versi\u00f3n de read_data() anterior, la funci\u00f3n espera cualquier objeto iterable. No solo las l\u00edneas de un archivo. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto significa que podemos usarlo con otras l\u00edneas . # Un archivo CSV lines = open('data.csv') data = read_data(lines) # Un archivo comprimido lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # La entrada est\u00e1ndar lines = sys.stdin data = read_data(lines) # Una lista de cadenas lines = ['ACME,50,91.1','IBM,75,123.45', ... ] data = read_data(lines) Este dise\u00f1o ofrece una flexibilidad considerable. Pregunta: \u00bfDeber\u00edamos adoptar o luchar contra esta flexibilidad? Mejores pr\u00e1cticas de dise\u00f1o de bibliotecas Las bibliotecas de c\u00f3digo suelen funcionar mejor si adoptan la flexibilidad. No restrinja sus opciones. Una gran flexibilidad conlleva un gran poder. Ejercicio Ejercicio 3.17: De nombres de archivo a objetos similares a archivos Ahora ha creado un archivo fileparse.py que conten\u00eda una funci\u00f3n parse_csv() . La funci\u00f3n funcionaba de la siguiente manera: >>> import fileparse >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> En este momento, la funci\u00f3n espera que se le pase un nombre de archivo. Sin embargo, puede hacer que el c\u00f3digo sea m\u00e1s flexible. Modifique la funci\u00f3n para que funcione con cualquier objeto iterable o similar a un archivo. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as file: ... port = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['name,shares,price', 'AA,100,34.23', 'IBM,50,91.1', 'HPE,75,45.1'] >>> port = fileparse.parse_csv(lines, types=[str,int,float]) >>> En este nuevo c\u00f3digo, \u00bfqu\u00e9 sucede si pasa un nombre de archivo como antes? >>> port = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> port ... mira la salida (deber\u00eda ser una locura) ... >>> S\u00ed, tendr\u00e1s que tener cuidado. \u00bfPodr\u00edas agregar una comprobaci\u00f3n de seguridad para evitar esto? Ejercicio 3.18: Corregir funciones existentes Corrige las funciones read_portfolio() y read_prices() en el archivo report.py para que funcionen con la versi\u00f3n modificada de parse_csv() . Esto solo deber\u00eda implicar una modificaci\u00f3n menor. Despu\u00e9s, tus programas report.py y pcost.py deber\u00edan funcionar de la misma manera que siempre lo hicieron. Contenido | Anterior (3.5 M\u00f3dulo principal) | Pr\u00f3ximo (4. Clases y Objetos)","title":"06_Design_discussion"},{"location":"03_Program_organization/06_Design_discussion/#36-discusion-sobre-el-diseno","text":"En esta secci\u00f3n reconsideramos una decisi\u00f3n de dise\u00f1o tomada anteriormente.","title":"3.6 Discusi\u00f3n sobre el dise\u00f1o"},{"location":"03_Program_organization/06_Design_discussion/#nombres-de-archivo-versus-iterables","text":"Compare estos dos programas que devuelven el mismo resultado. # Proporcione un nombre de archivo def read_data(filename): records = [] with open(filename) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # Proporcione l\u00edneas def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de estas funciones prefiere? \u00bfPor qu\u00e9? \u00bfCu\u00e1l de estas funciones es m\u00e1s flexible?","title":"Nombres de archivo versus iterables"},{"location":"03_Program_organization/06_Design_discussion/#idea-profunda-duck-typing","text":"Duck Typing es un concepto de programaci\u00f3n inform\u00e1tica para determinar si un objeto se puede usar para un prop\u00f3sito particular. Es una aplicaci\u00f3n de la prueba del pato . Si parece un pato, nada como un pato y grazna como un pato, entonces probablemente sea un pato. En la segunda versi\u00f3n de read_data() anterior, la funci\u00f3n espera cualquier objeto iterable. No solo las l\u00edneas de un archivo. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto significa que podemos usarlo con otras l\u00edneas . # Un archivo CSV lines = open('data.csv') data = read_data(lines) # Un archivo comprimido lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # La entrada est\u00e1ndar lines = sys.stdin data = read_data(lines) # Una lista de cadenas lines = ['ACME,50,91.1','IBM,75,123.45', ... ] data = read_data(lines) Este dise\u00f1o ofrece una flexibilidad considerable. Pregunta: \u00bfDeber\u00edamos adoptar o luchar contra esta flexibilidad?","title":"Idea profunda: \"Duck Typing\""},{"location":"03_Program_organization/06_Design_discussion/#mejores-practicas-de-diseno-de-bibliotecas","text":"Las bibliotecas de c\u00f3digo suelen funcionar mejor si adoptan la flexibilidad. No restrinja sus opciones. Una gran flexibilidad conlleva un gran poder.","title":"Mejores pr\u00e1cticas de dise\u00f1o de bibliotecas"},{"location":"03_Program_organization/06_Design_discussion/#ejercicio","text":"","title":"Ejercicio"},{"location":"03_Program_organization/06_Design_discussion/#ejercicio-317-de-nombres-de-archivo-a-objetos-similares-a-archivos","text":"Ahora ha creado un archivo fileparse.py que conten\u00eda una funci\u00f3n parse_csv() . La funci\u00f3n funcionaba de la siguiente manera: >>> import fileparse >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> En este momento, la funci\u00f3n espera que se le pase un nombre de archivo. Sin embargo, puede hacer que el c\u00f3digo sea m\u00e1s flexible. Modifique la funci\u00f3n para que funcione con cualquier objeto iterable o similar a un archivo. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as file: ... port = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['name,shares,price', 'AA,100,34.23', 'IBM,50,91.1', 'HPE,75,45.1'] >>> port = fileparse.parse_csv(lines, types=[str,int,float]) >>> En este nuevo c\u00f3digo, \u00bfqu\u00e9 sucede si pasa un nombre de archivo como antes? >>> port = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> port ... mira la salida (deber\u00eda ser una locura) ... >>> S\u00ed, tendr\u00e1s que tener cuidado. \u00bfPodr\u00edas agregar una comprobaci\u00f3n de seguridad para evitar esto?","title":"Ejercicio 3.17: De nombres de archivo a objetos similares a archivos"},{"location":"03_Program_organization/06_Design_discussion/#ejercicio-318-corregir-funciones-existentes","text":"Corrige las funciones read_portfolio() y read_prices() en el archivo report.py para que funcionen con la versi\u00f3n modificada de parse_csv() . Esto solo deber\u00eda implicar una modificaci\u00f3n menor. Despu\u00e9s, tus programas report.py y pcost.py deber\u00edan funcionar de la misma manera que siempre lo hicieron. Contenido | Anterior (3.5 M\u00f3dulo principal) | Pr\u00f3ximo (4. Clases y Objetos)","title":"Ejercicio 3.18: Corregir funciones existentes"},{"location":"04_Classes_objects/00_Overview/","text":"Contenido | Anterior (3 Organizaci\u00f3n del programa) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python) 4. Clases y objetos Hasta ahora, nuestros programas solo han utilizado tipos de datos integrados de Python. En esta secci\u00f3n, presentamos el concepto de clases y objetos. Aprender\u00e1 sobre la declaraci\u00f3n class que le permite crear nuevos objetos. Tambi\u00e9n presentaremos el concepto de herencia, una herramienta que se usa com\u00fanmente para crear programas extensibles. Finalmente, veremos algunas otras caracter\u00edsticas de las clases, incluidos los m\u00e9todos especiales, la b\u00fasqueda din\u00e1mica de atributos y la definici\u00f3n de nuevas excepciones. 4.1 Introducci\u00f3n de clases 4.2 Herencia 4.3 M\u00e9todos especiales 4.4 Definici\u00f3n de excepciones Contenido | Anterior (3 Organizaci\u00f3n del programa) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python)","title":"00_Overview"},{"location":"04_Classes_objects/00_Overview/#4-clases-y-objetos","text":"Hasta ahora, nuestros programas solo han utilizado tipos de datos integrados de Python. En esta secci\u00f3n, presentamos el concepto de clases y objetos. Aprender\u00e1 sobre la declaraci\u00f3n class que le permite crear nuevos objetos. Tambi\u00e9n presentaremos el concepto de herencia, una herramienta que se usa com\u00fanmente para crear programas extensibles. Finalmente, veremos algunas otras caracter\u00edsticas de las clases, incluidos los m\u00e9todos especiales, la b\u00fasqueda din\u00e1mica de atributos y la definici\u00f3n de nuevas excepciones. 4.1 Introducci\u00f3n de clases 4.2 Herencia 4.3 M\u00e9todos especiales 4.4 Definici\u00f3n de excepciones Contenido | Anterior (3 Organizaci\u00f3n del programa) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python)","title":"4. Clases y objetos"},{"location":"04_Classes_objects/01_Class/","text":"Contenido | Anterior (3.6 Discusi\u00f3n sobre el dise\u00f1o) | Pr\u00f3ximo (4.2 Herencia) 4.1 Clases Esta secci\u00f3n presenta la declaraci\u00f3n de clase y la idea de crear nuevos objetos. Programaci\u00f3n Orientada a Objetos (OO) Una t\u00e9cnica de programaci\u00f3n en la que el c\u00f3digo se organiza como una colecci\u00f3n de objetos . Un objeto consta de: Datos. Atributos Comportamiento. M\u00e9todos que son funciones aplicadas al objeto. Ya ha estado utilizando algo de OO durante este curso. Por ejemplo, manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # M\u00e9todo >>> nums.insert(1,10) # M\u00e9todo >>> nums [1, 10, 2, 3, 4] # Datos >>> nums es una instancia de una lista. Los m\u00e9todos ( append() y insert() ) se adjuntan a la instancia ( nums ). La declaraci\u00f3n class Use la declaraci\u00f3n class para definir un nuevo objeto. class Player: def __init__(self, x, y): self.x = x self.y = y self.health = 100 def move(self, dx, dy): self.x += dx self.y += dy def damage(self, pts): self.health -= pts En pocas palabras, una clase es un conjunto de funciones que realizan varias operaciones en las llamadas instancias . Instancias Las instancias son los objetos reales que manipulas en tu programa. Se crean llamando a la clase como una funci\u00f3n. >>> a = Player(2, 3) >>> b = Player(10, 20) >>> a y b son instancias de Player . Enfatizar: La declaraci\u00f3n de clase es solo la definici\u00f3n (no hace nada por s\u00ed misma). Similar a una definici\u00f3n de funci\u00f3n. Datos de instancia Cada instancia tiene sus propios datos locales. >>> a.x 2 >>> b.x 10 Estos datos se inicializan mediante __init__() . class Player: def __init__(self, x, y): # Cualquier valor almacenado en `self` son datos de instancia self.x = x self.y = y self.health = 100 No hay restricciones sobre la cantidad total o el tipo de atributos almacenados. M\u00e9todos de instancia Los m\u00e9todos de instancia son funciones que se aplican a instancias de un objeto. class Player: ... # `move` es un m\u00e9todo def move(self, dx, dy): self.x += dx self.y += dy El objeto en s\u00ed siempre se pasa como primer argumento. >>> a.move(1, 2) # hace coincidir `a` con `self` # hace coincidir `1` con `dx` # hace coincidir `2` con `dy` def move(self, dx, dy): Por convenci\u00f3n, la instancia se llama self . Sin embargo, el nombre real utilizado no es importante. El objeto siempre se pasa como primer argumento. Es simplemente el estilo de programaci\u00f3n de Python llamar a este argumento self . Alcance de la clase Las clases no definen un alcance de nombres. class Player: ... def move(self, dx, dy): self.x += dx self.y += dy def left(self, amt): move(-amt, 0) # NO. Llama a una funci\u00f3n `move` global self.move(-amt, 0) # S\u00cd. Llama al m\u00e9todo `move` de arriba. Si desea operar en una instancia, siempre debe hacer referencia a ella expl\u00edcitamente (por ejemplo, self ). Ejercicios A partir de este conjunto de ejercicios, comenzaremos a realizar una serie de cambios en el c\u00f3digo existente de las secciones anteriores. Es fundamental que tenga una versi\u00f3n funcional del Ejercicio 3.18 para comenzar. Si no la tiene, trabaje a partir del c\u00f3digo de soluci\u00f3n que se encuentra en el directorio Solutions/3_18 . Est\u00e1 bien copiarlo. Ejercicio 4.1: Objetos como estructuras de datos En las secciones 2 y 3, trabajamos con datos representados como tuplas y diccionarios. Por ejemplo, una cartera de acciones se podr\u00eda representar como una tupla como esta: s = ('GOOG',100,490.10) o como un diccionario como este: s = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.10 } Incluso puede escribir funciones para manipular dichos datos. Por ejemplo: def cost(s): return s['shares'] * s['price'] Sin embargo, a medida que su programa crezca, es posible que desee crear una mejor sensaci\u00f3n de organizaci\u00f3n. Por lo tanto, otro enfoque para representar datos ser\u00eda definir una clase. Cree un archivo llamado stock.py y defina una clase Stock que represente una \u00fanica tenencia de acciones. Haga que las instancias de Stock tengan los atributos name , shares y price . Por ejemplo: >>> import stock >>> a = stock.Stock('GOOG',100,490.10) >>> a.name 'GOOG' >>> a.shares 100 >>> a.price 490.1 >>> Cree algunos objetos Stock m\u00e1s y manip\u00falelos. Por ejemplo: >>> b = stock.Stock('AAPL', 50, 122.34) >>> c = stock.Stock('IBM', 75, 91.75) >>> b.shares * b.price 6117.0 >>> c.shares * c.price 6881.25 >>> stocks = [a, b, c] >>> stocks [<stock.Objeto Stock en 0x37d0b0>, <stock.Objeto Stock en 0x37d110>, <stock.Objeto Stock en 0x37d050>] >>> for s in stocks: print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}') ... mira el resultado... >>> Una cosa que hay que destacar aqu\u00ed es que la clase Stock act\u00faa como una f\u00e1brica para crear instancias de objetos. B\u00e1sicamente, la llamas como una funci\u00f3n y crea un nuevo objeto para ti. Adem\u00e1s, hay que destacar que cada objeto es distinto: cada uno tiene sus propios datos que est\u00e1n separados de otros objetos que se han creado. Un objeto definido por una clase es algo similar a un diccionario, solo que con una sintaxis ligeramente diferente. Por ejemplo, en lugar de escribir s['nombre'] o s['precio'] , ahora escribes s.nombre y s.precio . Ejercicio 4.2: Agregar algunos m\u00e9todos Con las clases, puedes adjuntar funciones a tus objetos. Estas se conocen como m\u00e9todos y son funciones que operan sobre los datos almacenados dentro de un objeto. Agrega un m\u00e9todo cost() y sell() a tu objeto Stock . Deber\u00edan funcionar as\u00ed: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.10) >>> s.cost() 49010.0 >>> s.shares 100 >>> s.sell(25) >>> s.shares 75 >>> s.cost() 36757.5 >>> Ejercicio 4.3: Creaci\u00f3n de una lista de instancias Pruebe estos pasos para crear una lista de instancias de Stock a partir de una lista de diccionarios. Luego, calcula el costo total: >>> import fileparse >>> with open('Data/portfolio.csv') as lines: ... portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) ... >>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts] >>> portfolio [<stock.Objeto Stock en 0x10c9e2128>, <stock.Objeto Stock en 0x10c9e2048>, <stock.Objeto Stock en 0x10c9e2080>, <stock.Objeto Stock en 0x10c9e25f8>, <stock.Objeto Stock en 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>, <stock.Stock object at 0x10ca6f7b8>] >>> sum([s.cost() for s in portfolio]) 44671.15 >>> Ejercicio 4.4: Utilizando tu clase Modifique la funci\u00f3n read_portfolio() en el programa report.py para que lea un portfolio en una lista de instancias de Stock como se muestra en el Ejercicio 4.3. Una vez que haya hecho eso, corrija todo el c\u00f3digo en report.py y pcost.py para que funcione con instancias Stock en lugar de diccionarios. Sugerencia: No deber\u00eda tener que hacer cambios importantes en el c\u00f3digo. Principalmente cambiar\u00e1 el acceso al diccionario como s['shares'] a s.shares . Deber\u00edas poder ejecutar tus funciones de la misma manera que antes: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Contenido | Anterior (3.6 Discusi\u00f3n sobre el dise\u00f1o) | Pr\u00f3ximo (4.2 Herencia)","title":"01_Class"},{"location":"04_Classes_objects/01_Class/#41-clases","text":"Esta secci\u00f3n presenta la declaraci\u00f3n de clase y la idea de crear nuevos objetos.","title":"4.1 Clases"},{"location":"04_Classes_objects/01_Class/#programacion-orientada-a-objetos-oo","text":"Una t\u00e9cnica de programaci\u00f3n en la que el c\u00f3digo se organiza como una colecci\u00f3n de objetos . Un objeto consta de: Datos. Atributos Comportamiento. M\u00e9todos que son funciones aplicadas al objeto. Ya ha estado utilizando algo de OO durante este curso. Por ejemplo, manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # M\u00e9todo >>> nums.insert(1,10) # M\u00e9todo >>> nums [1, 10, 2, 3, 4] # Datos >>> nums es una instancia de una lista. Los m\u00e9todos ( append() y insert() ) se adjuntan a la instancia ( nums ).","title":"Programaci\u00f3n Orientada a Objetos (OO)"},{"location":"04_Classes_objects/01_Class/#la-declaracion-class","text":"Use la declaraci\u00f3n class para definir un nuevo objeto. class Player: def __init__(self, x, y): self.x = x self.y = y self.health = 100 def move(self, dx, dy): self.x += dx self.y += dy def damage(self, pts): self.health -= pts En pocas palabras, una clase es un conjunto de funciones que realizan varias operaciones en las llamadas instancias .","title":"La declaraci\u00f3n class"},{"location":"04_Classes_objects/01_Class/#instancias","text":"Las instancias son los objetos reales que manipulas en tu programa. Se crean llamando a la clase como una funci\u00f3n. >>> a = Player(2, 3) >>> b = Player(10, 20) >>> a y b son instancias de Player . Enfatizar: La declaraci\u00f3n de clase es solo la definici\u00f3n (no hace nada por s\u00ed misma). Similar a una definici\u00f3n de funci\u00f3n.","title":"Instancias"},{"location":"04_Classes_objects/01_Class/#datos-de-instancia","text":"Cada instancia tiene sus propios datos locales. >>> a.x 2 >>> b.x 10 Estos datos se inicializan mediante __init__() . class Player: def __init__(self, x, y): # Cualquier valor almacenado en `self` son datos de instancia self.x = x self.y = y self.health = 100 No hay restricciones sobre la cantidad total o el tipo de atributos almacenados.","title":"Datos de instancia"},{"location":"04_Classes_objects/01_Class/#metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones que se aplican a instancias de un objeto. class Player: ... # `move` es un m\u00e9todo def move(self, dx, dy): self.x += dx self.y += dy El objeto en s\u00ed siempre se pasa como primer argumento. >>> a.move(1, 2) # hace coincidir `a` con `self` # hace coincidir `1` con `dx` # hace coincidir `2` con `dy` def move(self, dx, dy): Por convenci\u00f3n, la instancia se llama self . Sin embargo, el nombre real utilizado no es importante. El objeto siempre se pasa como primer argumento. Es simplemente el estilo de programaci\u00f3n de Python llamar a este argumento self .","title":"M\u00e9todos de instancia"},{"location":"04_Classes_objects/01_Class/#alcance-de-la-clase","text":"Las clases no definen un alcance de nombres. class Player: ... def move(self, dx, dy): self.x += dx self.y += dy def left(self, amt): move(-amt, 0) # NO. Llama a una funci\u00f3n `move` global self.move(-amt, 0) # S\u00cd. Llama al m\u00e9todo `move` de arriba. Si desea operar en una instancia, siempre debe hacer referencia a ella expl\u00edcitamente (por ejemplo, self ).","title":"Alcance de la clase"},{"location":"04_Classes_objects/01_Class/#ejercicios","text":"A partir de este conjunto de ejercicios, comenzaremos a realizar una serie de cambios en el c\u00f3digo existente de las secciones anteriores. Es fundamental que tenga una versi\u00f3n funcional del Ejercicio 3.18 para comenzar. Si no la tiene, trabaje a partir del c\u00f3digo de soluci\u00f3n que se encuentra en el directorio Solutions/3_18 . Est\u00e1 bien copiarlo.","title":"Ejercicios"},{"location":"04_Classes_objects/01_Class/#ejercicio-41-objetos-como-estructuras-de-datos","text":"En las secciones 2 y 3, trabajamos con datos representados como tuplas y diccionarios. Por ejemplo, una cartera de acciones se podr\u00eda representar como una tupla como esta: s = ('GOOG',100,490.10) o como un diccionario como este: s = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.10 } Incluso puede escribir funciones para manipular dichos datos. Por ejemplo: def cost(s): return s['shares'] * s['price'] Sin embargo, a medida que su programa crezca, es posible que desee crear una mejor sensaci\u00f3n de organizaci\u00f3n. Por lo tanto, otro enfoque para representar datos ser\u00eda definir una clase. Cree un archivo llamado stock.py y defina una clase Stock que represente una \u00fanica tenencia de acciones. Haga que las instancias de Stock tengan los atributos name , shares y price . Por ejemplo: >>> import stock >>> a = stock.Stock('GOOG',100,490.10) >>> a.name 'GOOG' >>> a.shares 100 >>> a.price 490.1 >>> Cree algunos objetos Stock m\u00e1s y manip\u00falelos. Por ejemplo: >>> b = stock.Stock('AAPL', 50, 122.34) >>> c = stock.Stock('IBM', 75, 91.75) >>> b.shares * b.price 6117.0 >>> c.shares * c.price 6881.25 >>> stocks = [a, b, c] >>> stocks [<stock.Objeto Stock en 0x37d0b0>, <stock.Objeto Stock en 0x37d110>, <stock.Objeto Stock en 0x37d050>] >>> for s in stocks: print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}') ... mira el resultado... >>> Una cosa que hay que destacar aqu\u00ed es que la clase Stock act\u00faa como una f\u00e1brica para crear instancias de objetos. B\u00e1sicamente, la llamas como una funci\u00f3n y crea un nuevo objeto para ti. Adem\u00e1s, hay que destacar que cada objeto es distinto: cada uno tiene sus propios datos que est\u00e1n separados de otros objetos que se han creado. Un objeto definido por una clase es algo similar a un diccionario, solo que con una sintaxis ligeramente diferente. Por ejemplo, en lugar de escribir s['nombre'] o s['precio'] , ahora escribes s.nombre y s.precio .","title":"Ejercicio 4.1: Objetos como estructuras de datos"},{"location":"04_Classes_objects/01_Class/#ejercicio-42-agregar-algunos-metodos","text":"Con las clases, puedes adjuntar funciones a tus objetos. Estas se conocen como m\u00e9todos y son funciones que operan sobre los datos almacenados dentro de un objeto. Agrega un m\u00e9todo cost() y sell() a tu objeto Stock . Deber\u00edan funcionar as\u00ed: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.10) >>> s.cost() 49010.0 >>> s.shares 100 >>> s.sell(25) >>> s.shares 75 >>> s.cost() 36757.5 >>>","title":"Ejercicio 4.2: Agregar algunos m\u00e9todos"},{"location":"04_Classes_objects/01_Class/#ejercicio-43-creacion-de-una-lista-de-instancias","text":"Pruebe estos pasos para crear una lista de instancias de Stock a partir de una lista de diccionarios. Luego, calcula el costo total: >>> import fileparse >>> with open('Data/portfolio.csv') as lines: ... portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) ... >>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts] >>> portfolio [<stock.Objeto Stock en 0x10c9e2128>, <stock.Objeto Stock en 0x10c9e2048>, <stock.Objeto Stock en 0x10c9e2080>, <stock.Objeto Stock en 0x10c9e25f8>, <stock.Objeto Stock en 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>, <stock.Stock object at 0x10ca6f7b8>] >>> sum([s.cost() for s in portfolio]) 44671.15 >>>","title":"Ejercicio 4.3: Creaci\u00f3n de una lista de instancias"},{"location":"04_Classes_objects/01_Class/#ejercicio-44-utilizando-tu-clase","text":"Modifique la funci\u00f3n read_portfolio() en el programa report.py para que lea un portfolio en una lista de instancias de Stock como se muestra en el Ejercicio 4.3. Una vez que haya hecho eso, corrija todo el c\u00f3digo en report.py y pcost.py para que funcione con instancias Stock en lugar de diccionarios. Sugerencia: No deber\u00eda tener que hacer cambios importantes en el c\u00f3digo. Principalmente cambiar\u00e1 el acceso al diccionario como s['shares'] a s.shares . Deber\u00edas poder ejecutar tus funciones de la misma manera que antes: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Contenido | Anterior (3.6 Discusi\u00f3n sobre el dise\u00f1o) | Pr\u00f3ximo (4.2 Herencia)","title":"Ejercicio 4.4: Utilizando tu clase"},{"location":"04_Classes_objects/02_Inheritance/","text":"Contenido | Anterior (4.1 Clases) | Pr\u00f3ximo (4.3 M\u00e9todos especiales) 4.2 Herencia La herencia es una herramienta que se utiliza habitualmente para escribir programas extensibles. Esta secci\u00f3n explora esa idea. Introducci\u00f3n La herencia se utiliza para especializar objetos existentes: class Parent: ... class Child(Parent): ... La nueva clase Child se denomina clase derivada o subclase. La clase Parent se conoce como clase base o superclase. Parent se especifica en () despu\u00e9s del nombre de la clase, class Child(Parent): . Extenci\u00f3n Con la herencia, tomas una clase existente y: Agregas nuevos m\u00e9todos Redefines algunos de los m\u00e9todos existentes Agregas nuevos atributos a las instancias Al final, extiendes el c\u00f3digo existente . Ejemplo Sup\u00f3n que esta es tu clase inicial: class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares Puedes cambiar cualquier parte de esto mediante la herencia. Agrega un nuevo m\u00e9todo class MyStock(Stock): def panic(self): self.sell(self.shares) Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.sell(25) >>> s.shares 75 >>> s.panic() >>> s.shares 0 >>> Redefinici\u00f3n de un m\u00e9todo existente class MyStock(Stock): def cost(self): return 1.25 * self.shares * self.price Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.cost() 61262.5 >>> El nuevo m\u00e9todo reemplaza al anterior. Los otros m\u00e9todos no se ven afectados. Es fant\u00e1stico. Sobreescritura A veces, una clase extiende un m\u00e9todo existente, pero desea utilizar la implementaci\u00f3n original dentro de la redefinici\u00f3n. Para ello, utilice super() : class Stock: ... def cost(self): return self.shares * self.price ... class MyStock(Stock): def cost(self): # Verifique la llamada a `super` actual_cost = super().cost() return 1.25 * actual_cost Use super() para llamar a la versi\u00f3n anterior. Precauci\u00f3n: En Python 2, la sintaxis era m\u00e1s detallada. actual_cost = super(MyStock, self).cost() __init__ y herencia Si se redefine __init__ , es esencial inicializar el padre. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price class MyStock(Stock): def __init__(self, name, shares, price, factor): # Verifica la llamada a `super` y `__init__` super().__init__(name, shares, price) self.factor = factor def cost(self): return self.factor * super().cost() Debes llamar al m\u00e9todo __init__() en super , que es la forma de llamar a la versi\u00f3n anterior como se mostr\u00f3 anteriormente. Uso de herencia La herencia se usa a veces para organizar objetos relacionados. class Shape: ... class Circle(Shape): ... class Rectangle(Shape): ... Piensa en una jerarqu\u00eda l\u00f3gica o taxonom\u00eda. Sin embargo, un uso m\u00e1s com\u00fan (y pr\u00e1ctico) est\u00e1 relacionado con la creaci\u00f3n de c\u00f3digo reutilizable o extensible. Por ejemplo, un marco de trabajo puede definir una clase base y darte instrucciones para personalizarla. class CustomHandler(TCPHandler): def handle_request(self): ... # Procesamiento personalizado La clase base contiene c\u00f3digo de prop\u00f3sito general. Tu clase hereda y personaliza partes espec\u00edficas. Relaci\u00f3n \"es una\" La herencia establece una relaci\u00f3n de tipos. class Shape: ... class Circle(Shape): ... Comprueba si hay una instancia de objeto. >>> c = Circle(4.0) >>> isinstance(c, Shape) True >>> Importante: idealmente, cualquier c\u00f3digo que haya funcionado con instancias de la clase padre tambi\u00e9n funcionar\u00e1 con instancias de la clase hija. Clase base object Si una clase no tiene padre, a veces ver\u00e1s que object se usa como base. class Shape(object): ... object es el padre de todos los objetos en Python. *Nota: t\u00e9cnicamente no es obligatorio, pero a menudo lo ves especificado como un remanente de su uso obligatorio en Python 2. Si se omite, la clase a\u00fan hereda impl\u00edcitamente de object . Herencia m\u00faltiple Puedes heredar de varias clases especific\u00e1ndolas en la definici\u00f3n de la clase. class Mother: ... class Father: ... class Child(Mother, Father): ... La clase Child hereda caracter\u00edsticas de ambos padres. Hay algunos detalles un poco complicados. No lo hagas a menos que sepas lo que est\u00e1s haciendo. Se dar\u00e1 m\u00e1s informaci\u00f3n en la siguiente secci\u00f3n, pero no vamos a utilizar m\u00e1s la herencia m\u00faltiple en este curso. Ejercicios Un uso importante de la herencia es escribir c\u00f3digo que se puede ampliar o personalizar de varias maneras, especialmente en bibliotecas o marcos. Para ilustrarlo, considere la funci\u00f3n print_report() en su programa report.py . Deber\u00eda verse algo como esto: def print_report(reportdata): ''' Imprima una tabla con un formato agradable a partir de una lista de tuplas (name, shares, price, change). ''' headers = ('Name','Shares','Price','Change') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in reportdata: print('%10s %10d %10.2f %10.2f' % row) Cuando ejecute su programa de informe, deber\u00eda obtener un resultado como este: >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Ejercicio 4.5: Un problema de extensibilidad Supongamos que desea modificar la funci\u00f3n print_report() para que admita una variedad de formatos de salida diferentes, como texto sin formato, HTML, CSV o XML. Para ello, podr\u00eda intentar escribir una funci\u00f3n gigantesca que hiciera todo. Sin embargo, hacerlo probablemente conducir\u00eda a un desastre imposible de mantener. En cambio, esta es una oportunidad perfecta para utilizar la herencia. Para comenzar, conc\u00e9ntrese en los pasos que intervienen en la creaci\u00f3n de una tabla. En la parte superior de la tabla hay un conjunto de encabezados de tabla. Despu\u00e9s de eso, aparecen las filas de datos de la tabla. Tomemos esos pasos y pong\u00e1moslos en su propia clase. Cree un archivo llamado tableformat.py y defina la siguiente clase: # tableformat.py class TableFormatter: def headers(self, headers): ''' Emite los encabezados de la tabla. ''' raise NotImplementedError() def row(self, rowdata): ''' Emite una sola fila de datos de la tabla. ''' raise NotImplementedError() Esta clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para clases adicionales que se definir\u00e1n en breve. A una clase como esta a veces se la llama \"clase base abstracta\". Modifique la funci\u00f3n print_report() para que acepte un objeto TableFormatter como entrada e invoque m\u00e9todos en \u00e9l para producir la salida. Por ejemplo, de esta manera: # report.py ... def print_report(reportdata, formatter): ''' Imprime una tabla con un formato agradable a partir de una lista de tuplas (name, shares, price, change). ''' formatter.headings(['Name','Shares','Price','Change']) for name, shares, price, change in reportdata: rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ] formatter.row(rowdata) Dado que agregaste un argumento a print_report() , tambi\u00e9n necesitar\u00e1s modificar la funci\u00f3n portfolio_report() . C\u00e1mbielo para que cree un TableFormatter` como este: # report.py import tableformat ... def portfolio_report(portfoliofile, pricefile): ''' Cree un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.TableFormatter() print_report(report, formatter) Ejecutar este nuevo c\u00f3digo: >>> ================================== RESTART ================================== >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... se bloquea ... Deber\u00eda bloquearse inmediatamente con una excepci\u00f3n NotImplementedError . No es muy interesante, pero es exactamente lo que esper\u00e1bamos. Contin\u00fae con la siguiente parte. Ejercicio 4.6: Uso de la herencia para producir resultados diferentes La clase TableFormatter que defini\u00f3 en la parte (a) est\u00e1 pensada para extenderse mediante herencia. De hecho, esa es la idea. Para ilustrarlo, defina una clase TextTableFormatter de la siguiente manera: # tableformat.py ... class TextTableFormatter(TableFormatter): ''' Emite una tabla en formato de texto simple ''' def headings(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def row(self, rowdata): for d in rowdata: print(f'{d:>10s}', end=' ') print() Modifique la funci\u00f3n portfolio_report() de esta manera y pru\u00e9bela: # report.py ... def portfolio_report(portfoliofile, pricefile): ''' Genere un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.TextTableFormatter() print_report(report, formatter) Esto deber\u00eda producir el mismo resultado que antes: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Sin embargo, cambiemos la salida por otra cosa. Definamos una nueva clase CSVTableFormatter que produzca una salida en formato CSV: # tableformat.py ... class CSVTableFormatter(TableFormatter): ''' Datos de cartera de salida en formato CSV. ''' def headings(self, headers): print(','.join(headers)) def row(self, rowdata): print(','.join(rowdata)) Modifique su programa principal de la siguiente manera: def portfolio_report(portfoliofile, pricefile): ''' Genere un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.CSVTableFormatter() print_report(report, formatter) Ahora deber\u00eda ver una salida CSV como esta: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 Usando una idea similar, defina una clase HTMLTableFormatter que produzca una tabla con lo siguiente salida: <tr><th>Name</th><th>Shares</th><th>Price</th><th>Change</th></tr> <tr><td>AA</td><td>100</td><td>9.22</td><td>-22.98</td></tr> <tr><td>IBM</td><td>50</td><td>106.28</td><td>15.18</td></tr> <tr><td>CAT</td><td>150</td><td>35.46</td><td>-47.98</td></tr> <tr><td>MSFT</td><td>200</td><td>20.89</td><td>-30.34</td></tr> <tr><td>GE</td><td>95</td><td>13.48</td><td>-26.89</td></tr> <tr><td>MSFT</td><td>50</td><td>20.89</td><td>-44.21</td></tr> <tr><td>IBM</td><td>100</td><td>106.28</td><td>35.84</td></tr> Pruebe Su c\u00f3digo modificando el programa principal para crear un objeto HTMLTableFormatter en lugar de un objeto CSVTableFormatter . Ejercicio 4.7: Polimorfismo en acci\u00f3n Una caracter\u00edstica importante de la programaci\u00f3n orientada a objetos es que puede conectar un objeto a un programa y funcionar\u00e1 sin tener que cambiar nada del c\u00f3digo existente. Por ejemplo, si escribi\u00f3 un programa que esperaba utilizar un objeto TableFormatter , funcionar\u00eda sin importar qu\u00e9 tipo de TableFormatter le haya asignado. Este comportamiento a veces se denomina \"polimorfismo\". Un problema potencial es averiguar c\u00f3mo permitir que un usuario elija el formateador que desea. El uso directo de los nombres de clase como TextTableFormatter suele ser molesto. Por lo tanto, puede considerar un enfoque simplificado. Tal vez puedas incorporar una declaraci\u00f3n if- en el c\u00f3digo de esta manera: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Crea un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo if fmt == 'txt': formatter = tableformat.TextTableFormatter() elif fmt == 'csv': formatter = tableformat.CSVTableFormatter() elif fmt == 'html': formatter = tableformat.HTMLTableFormatter() else: raise RuntimeError(f'Formato deconocido {fmt}') print_report(report, formatter) En este c\u00f3digo, el usuario especifica un nombre simplificado como 'txt' o 'csv' para elegir un formato. Sin embargo, \u00bfes la mejor idea poner una declaraci\u00f3n if grande en la funci\u00f3n portfolio_report() ? Tal vez sea mejor mover ese c\u00f3digo a una funci\u00f3n de prop\u00f3sito general en otro lugar. En el archivo tableformat.py , agregue una funci\u00f3n create_formatter(name) que permita a un usuario crear un formateador dado un nombre de salida como 'txt' , 'csv' o 'html' . Modifique portfolio_report() para que se vea as\u00ed: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Cree un informe de acciones dados los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.create_formatter(fmt) print_report(report, formatter) Intente llamar a la funci\u00f3n con diferentes formatos para asegurarse de que est\u00e9 funcionando. Ejercicio 4.8: Uniendo todo Modifique el programa report.py para que la funci\u00f3n portfolio_report() acepte un argumento opcional que especifique el formato de salida. Por ejemplo: >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el programa principal para que se pueda proporcionar un formato en la l\u00ednea de comandos: bash % python3 report.py Data/portfolio.csv Data/prices.csv csv Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 bash % Discusi\u00f3n Escribir c\u00f3digo extensible es uno de los usos m\u00e1s comunes de la herencia en bibliotecas y marcos. Por ejemplo, un marco puede indicarle que defina su propio objeto que hereda de una clase base proporcionada. Luego se le indica que complete varios m\u00e9todos que implementan varios fragmentos de funcionalidad. Otro concepto un poco m\u00e1s profundo es la idea de \"ser due\u00f1o de sus abstracciones\". En los ejercicios, definimos nuestra propia clase para formatear una tabla. Puede mirar su c\u00f3digo y decirse a s\u00ed mismo \"\u00a1Deber\u00eda usar una biblioteca de formato o algo que alguien m\u00e1s ya haya creado!\" No, debe usar TANTO su clase como una biblioteca. Usar su propia clase promueve el acoplamiento estrecho ( loose coupling ) [ https://en.wikipedia.org/wiki/Loose_coupling ] es m\u00e1s independiente y es m\u00e1s flexible. Mientras su aplicaci\u00f3n use la interfaz de programaci\u00f3n de su clase, puede cambiar la implementaci\u00f3n interna para que funcione de la forma que desee. Puede escribir c\u00f3digo totalmente personalizado. Puede usar el paquete de alguien. Puede cambiar un paquete de terceros por un paquete diferente cuando encuentre uno mejor. No importa: nada del c\u00f3digo de su aplicaci\u00f3n se romper\u00e1 mientras conserve la interfaz. Esa es una idea poderosa y es una de las razones por las que podr\u00eda considerar la herencia para algo como esto. Dicho esto, dise\u00f1ar programas orientados a objetos puede ser extremadamente dif\u00edcil. Para obtener m\u00e1s informaci\u00f3n, probablemente deber\u00eda buscar libros sobre el tema de los patrones de dise\u00f1o (aunque comprender lo que sucedi\u00f3 en este ejercicio lo llevar\u00e1 bastante lejos en t\u00e9rminos de usar objetos de una manera pr\u00e1ctica y \u00fatil). Contenido | Anterior (4.1 Clases) | Pr\u00f3ximo (4.3 M\u00e9todos especiales)","title":"02_Inheritance"},{"location":"04_Classes_objects/02_Inheritance/#42-herencia","text":"La herencia es una herramienta que se utiliza habitualmente para escribir programas extensibles. Esta secci\u00f3n explora esa idea.","title":"4.2 Herencia"},{"location":"04_Classes_objects/02_Inheritance/#introduccion","text":"La herencia se utiliza para especializar objetos existentes: class Parent: ... class Child(Parent): ... La nueva clase Child se denomina clase derivada o subclase. La clase Parent se conoce como clase base o superclase. Parent se especifica en () despu\u00e9s del nombre de la clase, class Child(Parent): .","title":"Introducci\u00f3n"},{"location":"04_Classes_objects/02_Inheritance/#extencion","text":"Con la herencia, tomas una clase existente y: Agregas nuevos m\u00e9todos Redefines algunos de los m\u00e9todos existentes Agregas nuevos atributos a las instancias Al final, extiendes el c\u00f3digo existente .","title":"Extenci\u00f3n"},{"location":"04_Classes_objects/02_Inheritance/#ejemplo","text":"Sup\u00f3n que esta es tu clase inicial: class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares Puedes cambiar cualquier parte de esto mediante la herencia.","title":"Ejemplo"},{"location":"04_Classes_objects/02_Inheritance/#agrega-un-nuevo-metodo","text":"class MyStock(Stock): def panic(self): self.sell(self.shares) Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.sell(25) >>> s.shares 75 >>> s.panic() >>> s.shares 0 >>>","title":"Agrega un nuevo m\u00e9todo"},{"location":"04_Classes_objects/02_Inheritance/#redefinicion-de-un-metodo-existente","text":"class MyStock(Stock): def cost(self): return 1.25 * self.shares * self.price Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.cost() 61262.5 >>> El nuevo m\u00e9todo reemplaza al anterior. Los otros m\u00e9todos no se ven afectados. Es fant\u00e1stico.","title":"Redefinici\u00f3n de un m\u00e9todo existente"},{"location":"04_Classes_objects/02_Inheritance/#sobreescritura","text":"A veces, una clase extiende un m\u00e9todo existente, pero desea utilizar la implementaci\u00f3n original dentro de la redefinici\u00f3n. Para ello, utilice super() : class Stock: ... def cost(self): return self.shares * self.price ... class MyStock(Stock): def cost(self): # Verifique la llamada a `super` actual_cost = super().cost() return 1.25 * actual_cost Use super() para llamar a la versi\u00f3n anterior. Precauci\u00f3n: En Python 2, la sintaxis era m\u00e1s detallada. actual_cost = super(MyStock, self).cost()","title":"Sobreescritura"},{"location":"04_Classes_objects/02_Inheritance/#__init__-y-herencia","text":"Si se redefine __init__ , es esencial inicializar el padre. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price class MyStock(Stock): def __init__(self, name, shares, price, factor): # Verifica la llamada a `super` y `__init__` super().__init__(name, shares, price) self.factor = factor def cost(self): return self.factor * super().cost() Debes llamar al m\u00e9todo __init__() en super , que es la forma de llamar a la versi\u00f3n anterior como se mostr\u00f3 anteriormente.","title":"__init__ y herencia"},{"location":"04_Classes_objects/02_Inheritance/#uso-de-herencia","text":"La herencia se usa a veces para organizar objetos relacionados. class Shape: ... class Circle(Shape): ... class Rectangle(Shape): ... Piensa en una jerarqu\u00eda l\u00f3gica o taxonom\u00eda. Sin embargo, un uso m\u00e1s com\u00fan (y pr\u00e1ctico) est\u00e1 relacionado con la creaci\u00f3n de c\u00f3digo reutilizable o extensible. Por ejemplo, un marco de trabajo puede definir una clase base y darte instrucciones para personalizarla. class CustomHandler(TCPHandler): def handle_request(self): ... # Procesamiento personalizado La clase base contiene c\u00f3digo de prop\u00f3sito general. Tu clase hereda y personaliza partes espec\u00edficas.","title":"Uso de herencia"},{"location":"04_Classes_objects/02_Inheritance/#relacion-es-una","text":"La herencia establece una relaci\u00f3n de tipos. class Shape: ... class Circle(Shape): ... Comprueba si hay una instancia de objeto. >>> c = Circle(4.0) >>> isinstance(c, Shape) True >>> Importante: idealmente, cualquier c\u00f3digo que haya funcionado con instancias de la clase padre tambi\u00e9n funcionar\u00e1 con instancias de la clase hija.","title":"Relaci\u00f3n \"es una\""},{"location":"04_Classes_objects/02_Inheritance/#clase-base-object","text":"Si una clase no tiene padre, a veces ver\u00e1s que object se usa como base. class Shape(object): ... object es el padre de todos los objetos en Python. *Nota: t\u00e9cnicamente no es obligatorio, pero a menudo lo ves especificado como un remanente de su uso obligatorio en Python 2. Si se omite, la clase a\u00fan hereda impl\u00edcitamente de object .","title":"Clase base object"},{"location":"04_Classes_objects/02_Inheritance/#herencia-multiple","text":"Puedes heredar de varias clases especific\u00e1ndolas en la definici\u00f3n de la clase. class Mother: ... class Father: ... class Child(Mother, Father): ... La clase Child hereda caracter\u00edsticas de ambos padres. Hay algunos detalles un poco complicados. No lo hagas a menos que sepas lo que est\u00e1s haciendo. Se dar\u00e1 m\u00e1s informaci\u00f3n en la siguiente secci\u00f3n, pero no vamos a utilizar m\u00e1s la herencia m\u00faltiple en este curso.","title":"Herencia m\u00faltiple"},{"location":"04_Classes_objects/02_Inheritance/#ejercicios","text":"Un uso importante de la herencia es escribir c\u00f3digo que se puede ampliar o personalizar de varias maneras, especialmente en bibliotecas o marcos. Para ilustrarlo, considere la funci\u00f3n print_report() en su programa report.py . Deber\u00eda verse algo como esto: def print_report(reportdata): ''' Imprima una tabla con un formato agradable a partir de una lista de tuplas (name, shares, price, change). ''' headers = ('Name','Shares','Price','Change') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in reportdata: print('%10s %10d %10.2f %10.2f' % row) Cuando ejecute su programa de informe, deber\u00eda obtener un resultado como este: >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84","title":"Ejercicios"},{"location":"04_Classes_objects/02_Inheritance/#ejercicio-45-un-problema-de-extensibilidad","text":"Supongamos que desea modificar la funci\u00f3n print_report() para que admita una variedad de formatos de salida diferentes, como texto sin formato, HTML, CSV o XML. Para ello, podr\u00eda intentar escribir una funci\u00f3n gigantesca que hiciera todo. Sin embargo, hacerlo probablemente conducir\u00eda a un desastre imposible de mantener. En cambio, esta es una oportunidad perfecta para utilizar la herencia. Para comenzar, conc\u00e9ntrese en los pasos que intervienen en la creaci\u00f3n de una tabla. En la parte superior de la tabla hay un conjunto de encabezados de tabla. Despu\u00e9s de eso, aparecen las filas de datos de la tabla. Tomemos esos pasos y pong\u00e1moslos en su propia clase. Cree un archivo llamado tableformat.py y defina la siguiente clase: # tableformat.py class TableFormatter: def headers(self, headers): ''' Emite los encabezados de la tabla. ''' raise NotImplementedError() def row(self, rowdata): ''' Emite una sola fila de datos de la tabla. ''' raise NotImplementedError() Esta clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para clases adicionales que se definir\u00e1n en breve. A una clase como esta a veces se la llama \"clase base abstracta\". Modifique la funci\u00f3n print_report() para que acepte un objeto TableFormatter como entrada e invoque m\u00e9todos en \u00e9l para producir la salida. Por ejemplo, de esta manera: # report.py ... def print_report(reportdata, formatter): ''' Imprime una tabla con un formato agradable a partir de una lista de tuplas (name, shares, price, change). ''' formatter.headings(['Name','Shares','Price','Change']) for name, shares, price, change in reportdata: rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ] formatter.row(rowdata) Dado que agregaste un argumento a print_report() , tambi\u00e9n necesitar\u00e1s modificar la funci\u00f3n portfolio_report() . C\u00e1mbielo para que cree un TableFormatter` como este: # report.py import tableformat ... def portfolio_report(portfoliofile, pricefile): ''' Cree un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.TableFormatter() print_report(report, formatter) Ejecutar este nuevo c\u00f3digo: >>> ================================== RESTART ================================== >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... se bloquea ... Deber\u00eda bloquearse inmediatamente con una excepci\u00f3n NotImplementedError . No es muy interesante, pero es exactamente lo que esper\u00e1bamos. Contin\u00fae con la siguiente parte.","title":"Ejercicio 4.5: Un problema de extensibilidad"},{"location":"04_Classes_objects/02_Inheritance/#ejercicio-46-uso-de-la-herencia-para-producir-resultados-diferentes","text":"La clase TableFormatter que defini\u00f3 en la parte (a) est\u00e1 pensada para extenderse mediante herencia. De hecho, esa es la idea. Para ilustrarlo, defina una clase TextTableFormatter de la siguiente manera: # tableformat.py ... class TextTableFormatter(TableFormatter): ''' Emite una tabla en formato de texto simple ''' def headings(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def row(self, rowdata): for d in rowdata: print(f'{d:>10s}', end=' ') print() Modifique la funci\u00f3n portfolio_report() de esta manera y pru\u00e9bela: # report.py ... def portfolio_report(portfoliofile, pricefile): ''' Genere un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.TextTableFormatter() print_report(report, formatter) Esto deber\u00eda producir el mismo resultado que antes: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Sin embargo, cambiemos la salida por otra cosa. Definamos una nueva clase CSVTableFormatter que produzca una salida en formato CSV: # tableformat.py ... class CSVTableFormatter(TableFormatter): ''' Datos de cartera de salida en formato CSV. ''' def headings(self, headers): print(','.join(headers)) def row(self, rowdata): print(','.join(rowdata)) Modifique su programa principal de la siguiente manera: def portfolio_report(portfoliofile, pricefile): ''' Genere un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.CSVTableFormatter() print_report(report, formatter) Ahora deber\u00eda ver una salida CSV como esta: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 Usando una idea similar, defina una clase HTMLTableFormatter que produzca una tabla con lo siguiente salida: <tr><th>Name</th><th>Shares</th><th>Price</th><th>Change</th></tr> <tr><td>AA</td><td>100</td><td>9.22</td><td>-22.98</td></tr> <tr><td>IBM</td><td>50</td><td>106.28</td><td>15.18</td></tr> <tr><td>CAT</td><td>150</td><td>35.46</td><td>-47.98</td></tr> <tr><td>MSFT</td><td>200</td><td>20.89</td><td>-30.34</td></tr> <tr><td>GE</td><td>95</td><td>13.48</td><td>-26.89</td></tr> <tr><td>MSFT</td><td>50</td><td>20.89</td><td>-44.21</td></tr> <tr><td>IBM</td><td>100</td><td>106.28</td><td>35.84</td></tr> Pruebe Su c\u00f3digo modificando el programa principal para crear un objeto HTMLTableFormatter en lugar de un objeto CSVTableFormatter .","title":"Ejercicio 4.6: Uso de la herencia para producir resultados diferentes"},{"location":"04_Classes_objects/02_Inheritance/#ejercicio-47-polimorfismo-en-accion","text":"Una caracter\u00edstica importante de la programaci\u00f3n orientada a objetos es que puede conectar un objeto a un programa y funcionar\u00e1 sin tener que cambiar nada del c\u00f3digo existente. Por ejemplo, si escribi\u00f3 un programa que esperaba utilizar un objeto TableFormatter , funcionar\u00eda sin importar qu\u00e9 tipo de TableFormatter le haya asignado. Este comportamiento a veces se denomina \"polimorfismo\". Un problema potencial es averiguar c\u00f3mo permitir que un usuario elija el formateador que desea. El uso directo de los nombres de clase como TextTableFormatter suele ser molesto. Por lo tanto, puede considerar un enfoque simplificado. Tal vez puedas incorporar una declaraci\u00f3n if- en el c\u00f3digo de esta manera: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Crea un informe de acciones a partir de los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo if fmt == 'txt': formatter = tableformat.TextTableFormatter() elif fmt == 'csv': formatter = tableformat.CSVTableFormatter() elif fmt == 'html': formatter = tableformat.HTMLTableFormatter() else: raise RuntimeError(f'Formato deconocido {fmt}') print_report(report, formatter) En este c\u00f3digo, el usuario especifica un nombre simplificado como 'txt' o 'csv' para elegir un formato. Sin embargo, \u00bfes la mejor idea poner una declaraci\u00f3n if grande en la funci\u00f3n portfolio_report() ? Tal vez sea mejor mover ese c\u00f3digo a una funci\u00f3n de prop\u00f3sito general en otro lugar. En el archivo tableformat.py , agregue una funci\u00f3n create_formatter(name) que permita a un usuario crear un formateador dado un nombre de salida como 'txt' , 'csv' o 'html' . Modifique portfolio_report() para que se vea as\u00ed: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Cree un informe de acciones dados los archivos de datos de cartera y precios. ''' # Leer archivos de datos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crear los datos del informe report = make_report_data(portfolio, prices) # Imprimirlo formatter = tableformat.create_formatter(fmt) print_report(report, formatter) Intente llamar a la funci\u00f3n con diferentes formatos para asegurarse de que est\u00e9 funcionando.","title":"Ejercicio 4.7: Polimorfismo en acci\u00f3n"},{"location":"04_Classes_objects/02_Inheritance/#ejercicio-48-uniendo-todo","text":"Modifique el programa report.py para que la funci\u00f3n portfolio_report() acepte un argumento opcional que especifique el formato de salida. Por ejemplo: >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el programa principal para que se pueda proporcionar un formato en la l\u00ednea de comandos: bash % python3 report.py Data/portfolio.csv Data/prices.csv csv Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 bash %","title":"Ejercicio 4.8: Uniendo todo"},{"location":"04_Classes_objects/02_Inheritance/#discusion","text":"Escribir c\u00f3digo extensible es uno de los usos m\u00e1s comunes de la herencia en bibliotecas y marcos. Por ejemplo, un marco puede indicarle que defina su propio objeto que hereda de una clase base proporcionada. Luego se le indica que complete varios m\u00e9todos que implementan varios fragmentos de funcionalidad. Otro concepto un poco m\u00e1s profundo es la idea de \"ser due\u00f1o de sus abstracciones\". En los ejercicios, definimos nuestra propia clase para formatear una tabla. Puede mirar su c\u00f3digo y decirse a s\u00ed mismo \"\u00a1Deber\u00eda usar una biblioteca de formato o algo que alguien m\u00e1s ya haya creado!\" No, debe usar TANTO su clase como una biblioteca. Usar su propia clase promueve el acoplamiento estrecho ( loose coupling ) [ https://en.wikipedia.org/wiki/Loose_coupling ] es m\u00e1s independiente y es m\u00e1s flexible. Mientras su aplicaci\u00f3n use la interfaz de programaci\u00f3n de su clase, puede cambiar la implementaci\u00f3n interna para que funcione de la forma que desee. Puede escribir c\u00f3digo totalmente personalizado. Puede usar el paquete de alguien. Puede cambiar un paquete de terceros por un paquete diferente cuando encuentre uno mejor. No importa: nada del c\u00f3digo de su aplicaci\u00f3n se romper\u00e1 mientras conserve la interfaz. Esa es una idea poderosa y es una de las razones por las que podr\u00eda considerar la herencia para algo como esto. Dicho esto, dise\u00f1ar programas orientados a objetos puede ser extremadamente dif\u00edcil. Para obtener m\u00e1s informaci\u00f3n, probablemente deber\u00eda buscar libros sobre el tema de los patrones de dise\u00f1o (aunque comprender lo que sucedi\u00f3 en este ejercicio lo llevar\u00e1 bastante lejos en t\u00e9rminos de usar objetos de una manera pr\u00e1ctica y \u00fatil). Contenido | Anterior (4.1 Clases) | Pr\u00f3ximo (4.3 M\u00e9todos especiales)","title":"Discusi\u00f3n"},{"location":"04_Classes_objects/03_Special_methods/","text":"Contenido | Anterior (4.2 Herencia) | Pr\u00f3ximo (4.4 Definici\u00f3n de excepciones) 4.3 M\u00e9todos especiales Varias partes del comportamiento de Python se pueden personalizar mediante m\u00e9todos especiales o los llamados \"m\u00e1gicos\". Esta secci\u00f3n presenta esa idea. Adem\u00e1s, se analizan el acceso din\u00e1mico a los atributos y los m\u00e9todos enlazados. Introducci\u00f3n Las clases pueden definir m\u00e9todos especiales. Estos tienen un significado especial para el int\u00e9rprete de Python. Siempre est\u00e1n precedidos y seguidos por __ . Por ejemplo, __init__ . class Stock(object): def __init__(self): ... def __repr__(self): ... Existen docenas de m\u00e9todos especiales, pero solo veremos algunos ejemplos espec\u00edficos. M\u00e9todos especiales para conversiones de strins Los objetos tienen dos representaciones de cadena. >>> from datetime import date >>> d = date(2012, 12, 21) >>> print(d) 2012-12-21 >>> d datetime.date(2012, 12, 21) >>> La funci\u00f3n str() se utiliza para crear una salida imprimible agradable: >>> str(d) '2012-12-21' >>> La funci\u00f3n repr() se utiliza para crear una representaci\u00f3n m\u00e1s detallada para los programadores. >>> repr(d) 'datetime.date(2012, 12, 21)' >>> Estas funciones, str() y repr() , utilizan un par de m\u00e9todos especiales en la clase para producir la cadena que se mostrar\u00e1. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Se utiliza con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Se utiliza con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: La convenci\u00f3n para __repr__() es devolver una cadena que, cuando se ingresa en eval() , recrear\u00e1 el objeto subyacente. Si esto no es posible, se utiliza alg\u00fan tipo de representaci\u00f3n de f\u00e1cil lectura en su lugar. M\u00e9todos especiales para matem\u00e1ticas Los operadores matem\u00e1ticos implican llamadas a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__() M\u00e9todos especiales para el acceso a elementos Estos son los m\u00e9todos para implementar contenedores. len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Puedes usarlos en tus clases. class Sequence: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ... Invocaci\u00f3n al m\u00e9todo Invocar un m\u00e9todo es un proceso de dos pasos. B\u00fasqueda: el operador . Invocaci\u00f3n al m\u00e9todo: el operador () >>> s = Stock('GOOG',100,490.10) >>> c = s.cost # Busqueda >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() # Invocando al m\u00e9todo 49010.0 >>> M\u00e9todos enlazados Un m\u00e9todo que a\u00fan no ha sido invocado por el operador de llamada de funci\u00f3n () se conoce como m\u00e9todo enlazado . Opera en la instancia en la que se origin\u00f3. >>> s = Stock('GOOG', 100, 490.10) >>> s <Stock object at 0x590d0> >>> c = s.cost >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() 49010.0 >>> Los m\u00e9todos enlazados suelen ser una fuente de errores no obvios causados \u200b\u200bpor descuido. Por ejemplo: >>> s = Stock('GOOG', 100, 490.10) >>> print('Cost : %0.2f' % s.cost) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O un comportamiento tortuoso que es dif\u00edcil de depurar. f = open(filename, 'w') ... f.close # Ups, no hice nada en absoluto. `f` sigue abierto. En ambos casos, el error se debe a que se olvid\u00f3 incluir los par\u00e9ntesis finales. Por ejemplo, s.cost() o f.close() . Acceso a atributos Existe una forma alternativa de acceder, manipular y administrar atributos. getattr(obj, 'name') # Igual que obj.name setattr(obj, 'name', value) # Igual que obj.name = value delattr(obj, 'name') # Igual que del obj.name hasattr(obj, 'name') # Comprueba si el atributo existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None *Nota: getattr() tambi\u00e9n tiene un valor predeterminado \u00fatil default . x = getattr(obj, 'x', None) Ejercicios Ejercicio 4.9: Mejor salida para imprimir objetos Modifique el objeto Stock que defini\u00f3 en stock.py para que el m\u00e9todo __repr__() produzca una salida m\u00e1s \u00fatil. Por ejemplo: >>> goog = Stock('GOOG', 100, 490.1) >>> goog Stock('GOOG', 100, 490.1) >>> Observa lo que sucede cuando lees una cartera de acciones y visualizas la lista resultante despu\u00e9s de haber realizado estos cambios. Por ejemplo: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> portfolio ... observa cu\u00e1l es el resultado... >>> Ejercicio 4.10: Un ejemplo de uso de getattr() getattr() es un mecanismo alternativo para leer atributos. Se puede utilizar para escribir c\u00f3digo extremadamente flexible. Para comenzar, pruebe este ejemplo: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.1) >>> columns = ['name', 'shares'] >>> for colname in columns: print(colname, '=', getattr(s, colname)) name = GOOG shares = 100 >>> Observe con atenci\u00f3n que los datos de salida est\u00e1n determinados completamente por los nombres de los atributos que se enumeran en la variable columnas . En el archivo tableformat.py , tome esta idea y ampl\u00edela a una funci\u00f3n generalizada print_table() que imprima una tabla que muestre los atributos especificados por el usuario de una lista de objetos arbitrarios. Al igual que con la funci\u00f3n print_report() anterior, print_table() tambi\u00e9n debe aceptar una instancia de TableFormatter para controlar el formato de salida. As\u00ed es como deber\u00eda funcionar: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> from tableformat import create_formatter, print_table >>> formatter = create_formatter('txt') >>> print_table(portfolio, ['name','shares'], formatter) name shares ---------- ---------- AA 100 IBM 50 CAT 150 MSFT 200 GE 95 MSFT 50 IBM 100 >>> print_table(portfolio, ['name','shares','price'], formatter) name shares price ---------- ---------- ---------- AA 100 32.2 IBM 50 91.1 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.1 IBM 100 70.44 >>> Contenido | Anterior (4.2 Herencia) | Pr\u00f3ximo (4.4 Definici\u00f3n de una nueva excepci\u00f3n)","title":"03_Special_methods"},{"location":"04_Classes_objects/03_Special_methods/#43-metodos-especiales","text":"Varias partes del comportamiento de Python se pueden personalizar mediante m\u00e9todos especiales o los llamados \"m\u00e1gicos\". Esta secci\u00f3n presenta esa idea. Adem\u00e1s, se analizan el acceso din\u00e1mico a los atributos y los m\u00e9todos enlazados.","title":"4.3 M\u00e9todos especiales"},{"location":"04_Classes_objects/03_Special_methods/#introduccion","text":"Las clases pueden definir m\u00e9todos especiales. Estos tienen un significado especial para el int\u00e9rprete de Python. Siempre est\u00e1n precedidos y seguidos por __ . Por ejemplo, __init__ . class Stock(object): def __init__(self): ... def __repr__(self): ... Existen docenas de m\u00e9todos especiales, pero solo veremos algunos ejemplos espec\u00edficos.","title":"Introducci\u00f3n"},{"location":"04_Classes_objects/03_Special_methods/#metodos-especiales-para-conversiones-de-strins","text":"Los objetos tienen dos representaciones de cadena. >>> from datetime import date >>> d = date(2012, 12, 21) >>> print(d) 2012-12-21 >>> d datetime.date(2012, 12, 21) >>> La funci\u00f3n str() se utiliza para crear una salida imprimible agradable: >>> str(d) '2012-12-21' >>> La funci\u00f3n repr() se utiliza para crear una representaci\u00f3n m\u00e1s detallada para los programadores. >>> repr(d) 'datetime.date(2012, 12, 21)' >>> Estas funciones, str() y repr() , utilizan un par de m\u00e9todos especiales en la clase para producir la cadena que se mostrar\u00e1. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Se utiliza con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Se utiliza con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: La convenci\u00f3n para __repr__() es devolver una cadena que, cuando se ingresa en eval() , recrear\u00e1 el objeto subyacente. Si esto no es posible, se utiliza alg\u00fan tipo de representaci\u00f3n de f\u00e1cil lectura en su lugar.","title":"M\u00e9todos especiales para conversiones de strins"},{"location":"04_Classes_objects/03_Special_methods/#metodos-especiales-para-matematicas","text":"Los operadores matem\u00e1ticos implican llamadas a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__()","title":"M\u00e9todos especiales para matem\u00e1ticas"},{"location":"04_Classes_objects/03_Special_methods/#metodos-especiales-para-el-acceso-a-elementos","text":"Estos son los m\u00e9todos para implementar contenedores. len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Puedes usarlos en tus clases. class Sequence: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ...","title":"M\u00e9todos especiales para el acceso a elementos"},{"location":"04_Classes_objects/03_Special_methods/#invocacion-al-metodo","text":"Invocar un m\u00e9todo es un proceso de dos pasos. B\u00fasqueda: el operador . Invocaci\u00f3n al m\u00e9todo: el operador () >>> s = Stock('GOOG',100,490.10) >>> c = s.cost # Busqueda >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() # Invocando al m\u00e9todo 49010.0 >>>","title":"Invocaci\u00f3n al m\u00e9todo"},{"location":"04_Classes_objects/03_Special_methods/#metodos-enlazados","text":"Un m\u00e9todo que a\u00fan no ha sido invocado por el operador de llamada de funci\u00f3n () se conoce como m\u00e9todo enlazado . Opera en la instancia en la que se origin\u00f3. >>> s = Stock('GOOG', 100, 490.10) >>> s <Stock object at 0x590d0> >>> c = s.cost >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() 49010.0 >>> Los m\u00e9todos enlazados suelen ser una fuente de errores no obvios causados \u200b\u200bpor descuido. Por ejemplo: >>> s = Stock('GOOG', 100, 490.10) >>> print('Cost : %0.2f' % s.cost) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O un comportamiento tortuoso que es dif\u00edcil de depurar. f = open(filename, 'w') ... f.close # Ups, no hice nada en absoluto. `f` sigue abierto. En ambos casos, el error se debe a que se olvid\u00f3 incluir los par\u00e9ntesis finales. Por ejemplo, s.cost() o f.close() .","title":"M\u00e9todos enlazados"},{"location":"04_Classes_objects/03_Special_methods/#acceso-a-atributos","text":"Existe una forma alternativa de acceder, manipular y administrar atributos. getattr(obj, 'name') # Igual que obj.name setattr(obj, 'name', value) # Igual que obj.name = value delattr(obj, 'name') # Igual que del obj.name hasattr(obj, 'name') # Comprueba si el atributo existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None *Nota: getattr() tambi\u00e9n tiene un valor predeterminado \u00fatil default . x = getattr(obj, 'x', None)","title":"Acceso a atributos"},{"location":"04_Classes_objects/03_Special_methods/#ejercicios","text":"","title":"Ejercicios"},{"location":"04_Classes_objects/03_Special_methods/#ejercicio-49-mejor-salida-para-imprimir-objetos","text":"Modifique el objeto Stock que defini\u00f3 en stock.py para que el m\u00e9todo __repr__() produzca una salida m\u00e1s \u00fatil. Por ejemplo: >>> goog = Stock('GOOG', 100, 490.1) >>> goog Stock('GOOG', 100, 490.1) >>> Observa lo que sucede cuando lees una cartera de acciones y visualizas la lista resultante despu\u00e9s de haber realizado estos cambios. Por ejemplo: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> portfolio ... observa cu\u00e1l es el resultado... >>>","title":"Ejercicio 4.9: Mejor salida para imprimir objetos"},{"location":"04_Classes_objects/03_Special_methods/#ejercicio-410-un-ejemplo-de-uso-de-getattr","text":"getattr() es un mecanismo alternativo para leer atributos. Se puede utilizar para escribir c\u00f3digo extremadamente flexible. Para comenzar, pruebe este ejemplo: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.1) >>> columns = ['name', 'shares'] >>> for colname in columns: print(colname, '=', getattr(s, colname)) name = GOOG shares = 100 >>> Observe con atenci\u00f3n que los datos de salida est\u00e1n determinados completamente por los nombres de los atributos que se enumeran en la variable columnas . En el archivo tableformat.py , tome esta idea y ampl\u00edela a una funci\u00f3n generalizada print_table() que imprima una tabla que muestre los atributos especificados por el usuario de una lista de objetos arbitrarios. Al igual que con la funci\u00f3n print_report() anterior, print_table() tambi\u00e9n debe aceptar una instancia de TableFormatter para controlar el formato de salida. As\u00ed es como deber\u00eda funcionar: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> from tableformat import create_formatter, print_table >>> formatter = create_formatter('txt') >>> print_table(portfolio, ['name','shares'], formatter) name shares ---------- ---------- AA 100 IBM 50 CAT 150 MSFT 200 GE 95 MSFT 50 IBM 100 >>> print_table(portfolio, ['name','shares','price'], formatter) name shares price ---------- ---------- ---------- AA 100 32.2 IBM 50 91.1 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.1 IBM 100 70.44 >>> Contenido | Anterior (4.2 Herencia) | Pr\u00f3ximo (4.4 Definici\u00f3n de una nueva excepci\u00f3n)","title":"Ejercicio 4.10: Un ejemplo de uso de getattr()"},{"location":"04_Classes_objects/04_Defining_exceptions/","text":"Contenido | Anterior (4.3 M\u00e9todos especiales) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python) 4.4 Definici\u00f3n de excepciones Las excepciones definidas por el usuario se definen por clases. class NetworkError(Exception): pass Las excepciones siempre heredan de Exception . Normalmente son clases vac\u00edas. Utilice pass para el cuerpo. Tambi\u00e9n puede crear una jerarqu\u00eda de sus excepciones. class AuthenticationError(NetworkError): pass class ProtocolError(NetworkError): pass Ejercicios Ejercicio 4.11: Definici\u00f3n de una excepci\u00f3n personalizada A menudo, es una buena pr\u00e1ctica que las bibliotecas definan sus propias excepciones. Esto facilita la distinci\u00f3n entre las excepciones de Python generadas en respuesta a errores de programaci\u00f3n comunes y las excepciones generadas intencionalmente por una biblioteca para se\u00f1alar un problema de uso espec\u00edfico. Modifique la funci\u00f3n create_formatter() del \u00faltimo ejercicio para que genere una excepci\u00f3n FormatError personalizada cuando el usuario proporcione un nombre de formato incorrecto. Por ejemplo: >>> from tableformat import create_formatter >>> formatter = create_formatter('xls') Traceback (most recent call last): File \"<python-input-1>\", line 1, in <module> formatter = create_formatter('xls') File \"C:\\Users\\Mario\\practical-python\\Work\\tableformat.py\", line 30, in create_formatter raise FormatError(f'Unknown table format {name}') tableformat.FormatError: Unknown table format xls >>> Contenido | Anterior (4.3 M\u00e9todos especiales) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python)","title":"04_Defining_exceptions"},{"location":"04_Classes_objects/04_Defining_exceptions/#44-definicion-de-excepciones","text":"Las excepciones definidas por el usuario se definen por clases. class NetworkError(Exception): pass Las excepciones siempre heredan de Exception . Normalmente son clases vac\u00edas. Utilice pass para el cuerpo. Tambi\u00e9n puede crear una jerarqu\u00eda de sus excepciones. class AuthenticationError(NetworkError): pass class ProtocolError(NetworkError): pass","title":"4.4 Definici\u00f3n de excepciones"},{"location":"04_Classes_objects/04_Defining_exceptions/#ejercicios","text":"","title":"Ejercicios"},{"location":"04_Classes_objects/04_Defining_exceptions/#ejercicio-411-definicion-de-una-excepcion-personalizada","text":"A menudo, es una buena pr\u00e1ctica que las bibliotecas definan sus propias excepciones. Esto facilita la distinci\u00f3n entre las excepciones de Python generadas en respuesta a errores de programaci\u00f3n comunes y las excepciones generadas intencionalmente por una biblioteca para se\u00f1alar un problema de uso espec\u00edfico. Modifique la funci\u00f3n create_formatter() del \u00faltimo ejercicio para que genere una excepci\u00f3n FormatError personalizada cuando el usuario proporcione un nombre de formato incorrecto. Por ejemplo: >>> from tableformat import create_formatter >>> formatter = create_formatter('xls') Traceback (most recent call last): File \"<python-input-1>\", line 1, in <module> formatter = create_formatter('xls') File \"C:\\Users\\Mario\\practical-python\\Work\\tableformat.py\", line 30, in create_formatter raise FormatError(f'Unknown table format {name}') tableformat.FormatError: Unknown table format xls >>> Contenido | Anterior (4.3 M\u00e9todos especiales) | Pr\u00f3ximo (5. Funcionamiento interno de los objetos de Python)","title":"Ejercicio 4.11: Definici\u00f3n de una excepci\u00f3n personalizada"},{"location":"05_Object_model/00_Overview/","text":"Contenido | Anterior (4 Clases y Objetos) | Pr\u00f3ximo (6 Generadores) 5. Funcionamiento interno de los objetos de Python Esta secci\u00f3n cubre algunos de los funcionamientos internos de los objetos de Python. Los programadores que vienen de otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases de Python carece de caracter\u00edsticas. Por ejemplo, no hay noci\u00f3n de control de acceso (p. ej., privado, protegido), todo el argumento self se siente extra\u00f1o y, francamente, trabajar con objetos a veces se siente como un \"vale para todos\". Tal vez eso sea cierto, pero descubriremos c\u00f3mo funciona todo, as\u00ed como algunos modismos de programaci\u00f3n comunes para encapsular mejor los aspectos internos de los objetos. No es necesario preocuparse por los detalles internos para ser productivo. Sin embargo, la mayor\u00eda de los programadores de Python tienen un conocimiento b\u00e1sico de c\u00f3mo funcionan las clases. Por eso lo cubriremos. 5.1 Revisi\u00f3n de diccionarios (Implementaci\u00f3n de objetos) 5.2 T\u00e9cnicas de encapsulaci\u00f3n Contenido | Anterior (4 Clases y Objetos) | Pr\u00f3ximo (6 Generadores)","title":"00_Overview"},{"location":"05_Object_model/00_Overview/#5-funcionamiento-interno-de-los-objetos-de-python","text":"Esta secci\u00f3n cubre algunos de los funcionamientos internos de los objetos de Python. Los programadores que vienen de otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases de Python carece de caracter\u00edsticas. Por ejemplo, no hay noci\u00f3n de control de acceso (p. ej., privado, protegido), todo el argumento self se siente extra\u00f1o y, francamente, trabajar con objetos a veces se siente como un \"vale para todos\". Tal vez eso sea cierto, pero descubriremos c\u00f3mo funciona todo, as\u00ed como algunos modismos de programaci\u00f3n comunes para encapsular mejor los aspectos internos de los objetos. No es necesario preocuparse por los detalles internos para ser productivo. Sin embargo, la mayor\u00eda de los programadores de Python tienen un conocimiento b\u00e1sico de c\u00f3mo funcionan las clases. Por eso lo cubriremos. 5.1 Revisi\u00f3n de diccionarios (Implementaci\u00f3n de objetos) 5.2 T\u00e9cnicas de encapsulaci\u00f3n Contenido | Anterior (4 Clases y Objetos) | Pr\u00f3ximo (6 Generadores)","title":"5. Funcionamiento interno de los objetos de Python"},{"location":"05_Object_model/01_Dicts_revisited/","text":"Contenido | Anterior (4.4 Definici\u00f3n de excepciones) | Pr\u00f3ximo (5.2 T\u00e9cnicas de encapsulaci\u00f3n) 5.1 Revisi\u00f3n de diccionarios El sistema de objetos de Python se basa en gran medida en una implementaci\u00f3n que involucra diccionarios. Esta secci\u00f3n trata sobre eso. Diccionarios revisitados Recuerde que un diccionario es una colecci\u00f3n de valores nombrados. stock = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.1 } Los diccionarios se usan com\u00fanmente para estructuras de datos simples. Sin embargo, se usan para partes cr\u00edticas del int\u00e9rprete y pueden ser el tipo de datos m\u00e1s importante en Python . Diccionarios y m\u00f3dulos Dentro de un m\u00f3dulo, un diccionario contiene todas las variables y funciones globales. # foo.py x = 42 def bar(): ... def spam(): ... Si inspecciona foo.__dict__ o globals() , ver\u00e1 el diccionario. { 'x' : 42, 'bar' : <function bar>, 'spam' : <function spam> } Diccionarios y objetos Los objetos definidos por el usuario tambi\u00e9n usan diccionarios tanto para los datos de instancia como para las clases. De hecho, todo el sistema de objetos es principalmente una capa adicional que se coloca sobre los diccionarios. Un diccionario contiene los datos de instancia, __dict__ . >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ {'name' : 'GOOG', 'shares' : 100, 'price': 490.1 } Este diccionario (y la instancia) se rellenan al asignar a self . class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Los datos de la instancia, self.__dict__ , tienen este aspecto: { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } Cada instancia obtiene su propio diccionario privado. s = Stock('GOOG', 100, 490.1) # {'name' : 'GOOG','shares' : 100, 'price': 490.1 } t = Stock('AAPL', 50, 123.45) # {'name' : 'AAPL','shares' : 50, 'price': 123.45 } Si creaste 100 instancias de alguna clase, hay 100 diccionarios que contienen datos. Miembros de clase Un diccionario separado tambi\u00e9n contiene los m\u00e9todos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares El diccionario est\u00e1 en Stock.__dict__ . { 'cost': <function>, 'sell': <function>, '__init__': <function> } Instancias y clases Las instancias y las clases est\u00e1n vinculadas entre s\u00ed. El atributo __class__ hace referencia a la clase. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s.__class__ <class '__main__.Stock'> >>> El diccionario de instancias contiene datos exclusivos de cada instancia, mientras que el diccionario de clases contiene datos compartidos colectivamente por todas las instancias. Acceso a atributos Cuando trabaja con objetos, accede a los datos y m\u00e9todos utilizando el operador . . x = obj.name # Obtenci\u00f3n obj.name = value # Configuraci\u00f3n del obj.name # Eliminaci\u00f3n Estas operaciones est\u00e1n directamente vinculadas a los diccionarios que se encuentran debajo de las s\u00e1banas. Modificaci\u00f3n de instancias Las operaciones que modifican un objeto actualizan el diccionario subyacente. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'nombre': 'GOOG', 'acciones': 100, 'precio': 490.1 } >>> s.shares = 50 # Configuraci\u00f3n >>> s.date = '6/7/2007' # Configuraci\u00f3n >>> s.__dict__ { 'nombre': 'GOOG', 'acciones': 50, 'precio': 490.1, 'fecha': '6/7/2007' } >>> del s.shares # Eliminando >>> s.__dict__ { 'nombre': 'GOOG', 'precio': 490.1, 'fecha': '6/7/2007' } >>> Lectura de atributos Supongamos que lee un atributo en una instancia. x = obj.name El atributo puede existir en dos lugares: Diccionario de instancia local. Diccionario de clase. Se deben verificar ambos diccionarios. Primero, verifique en __dict__ local. Si no se encuentra, busque en __dict__ de la clase hasta __class__ . >>> s = Stock(...) >>> s.name 'GOOG' >>> s.cost() 49010.0 >>> Este esquema de b\u00fasqueda es la forma en que los miembros de una clase se comparten entre todas las instancias. C\u00f3mo funciona la herencia Las clases pueden heredar de otras clases. class A(B, C): ... Las clases base se almacenan en una tupla en cada clase. >>> A.__bases__ (<class '__main__.B'>, <class '__main__.C'>) >>> Esto proporciona un enlace a las clases padre. Lectura de atributos con herencia L\u00f3gicamente, el proceso para encontrar un atributo es el siguiente. Primero, verifique en __dict__ local. Si no lo encuentra, busque en __dict__ de la clase. Si no lo encuentra en la clase, busque en las clases base a trav\u00e9s de __bases__ . Sin embargo, hay algunos aspectos sutiles de esto que se analizan a continuaci\u00f3n. Lectura de atributos con herencia \u00fanica En las jerarqu\u00edas de herencia, los atributos se encuentran recorriendo el \u00e1rbol de herencia en orden. class A: pass class B(A): pass class C(A): pass class D(B): pass class E(D): pass Con herencia simple, hay una \u00fanica ruta hacia la cima. Se detiene en la primera coincidencia. Orden de resoluci\u00f3n de m\u00e9todos o MRO Python precalcula una cadena de herencia y la almacena en el atributo MRO de la clase. Puede verla. >>> E.__mro__ (<class '__main__.E'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>) >>> Esta cadena se denomina Orden de resoluci\u00f3n de m\u00e9todos . Para encontrar un atributo, Python recorre el MRO en orden. La primera coincidencia gana. MRO en herencia m\u00faltiple Con la herencia m\u00faltiple, no hay una \u00fanica ruta hacia la cima. Veamos un ejemplo. class A: pass class B: pass class C(A, B): pass class D(B): pass class E(C, D): pass \u00bfQu\u00e9 sucede cuando se accede a un atributo? e = E() e.attr Se lleva a cabo un proceso de b\u00fasqueda de atributos, pero \u00bfcu\u00e1l es el orden? Eso es un problema. Python utiliza herencia m\u00faltiple cooperativa que obedece algunas reglas sobre el orden de las clases. Los hijos siempre se comprueban antes que los padres Los padres (si son m\u00faltiples) siempre se comprueban en el orden indicado. El MRO se calcula ordenando todas las clases en una jerarqu\u00eda de acuerdo con esas reglas. >>> E.__mro__ ( <class 'E'>, <class 'C'>, <class 'A'>, <class 'D'>, <class 'B'>, <class 'object'>) >>> El algoritmo subyacente se llama \"Algoritmo de linealizaci\u00f3n C3\". Los detalles precisos no son importantes siempre que recuerde que una jerarqu\u00eda de clases obedece las mismas reglas de ordenamiento que podr\u00eda seguir si su casa se incendiara y tuviera que evacuar: primero los ni\u00f1os, luego los padres. Una reutilizaci\u00f3n de c\u00f3digo extra\u00f1a (que implica herencia m\u00faltiple) Considere dos objetos completamente no relacionados: class Dog: # Perro def noise(self): # ruido return 'Bark' # Ladrar def chase(self): # caza return 'Chasing!' # Cazando class LoudDog(Dog): # Perro ruidoso def noise(self): # C\u00f3digo com\u00fan con LoudBike (abajo) return super().noise().upper() Y class Bike: def noise(self): return 'On Your Left' def pedal(self): return 'Pedaling!' class LoudBike(Bike): def noise(self): # C\u00f3digo com\u00fan con LoudDog (arriba) return super().noise().upper() Hay un c\u00f3digo com\u00fan en la implementaci\u00f3n de LoudDog.noise() y LoudBike.noise() . De hecho, el c\u00f3digo es exactamente el mismo. Naturalmente, c\u00f3digo como ese est\u00e1 destinado a atraer a los ingenieros de software. El patr\u00f3n \"Mixin\" El patr\u00f3n Mixin es una clase con un fragmento de c\u00f3digo. class Loud: def noise(self): return super().noise().upper() Esta clase no se puede usar de forma aislada. Se mezcla con otras clases a trav\u00e9s de la herencia. class LoudDog(Loud, Dog): pass class LoudBike(Loud, Bike): pass Milagrosamente, la sonoridad ahora se implement\u00f3 solo una vez y se reutiliz\u00f3 en dos clases completamente no relacionadas. Este tipo de truco es uno de los usos principales de la herencia m\u00faltiple en Python. Por qu\u00e9 super() Siempre use super() al anular m\u00e9todos. class Loud: def noise(self): return super().noise().upper() super() delega a la pr\u00f3xima clase en el MRO. La parte complicada es que no sabe cual es. En particular, no sabe cual es si se utiliza la herencia m\u00faltiple. Algunas precauciones La herencia m\u00faltiple es una herramienta poderosa. Recuerde que el poder conlleva responsabilidad. Los marcos de trabajo y las bibliotecas a veces la utilizan para funciones avanzadas que implican la composici\u00f3n de componentes. Ahora, olv\u00eddese de que vio eso. Ejercicios En la Secci\u00f3n 4, defini\u00f3 una clase Stock que representaba una tenencia de acciones. En este ejercicio, utilizaremos esa clase. Reinicie el int\u00e9rprete y cree algunas instancias: >>> ================================= RESTART ================================== >>> from stock import Stock >>> goog = Stock('GOOG',100,490.10) >>> ibm = Stock('IBM',50, 91.23) >>> Ejercicio 5.1: Representaci\u00f3n de instancias En el modo interactivo, inspeccione los diccionarios subyacentes de las dos instancias que cre\u00f3: >>> goog.__dict__ ... observe la salida ... >>> ibm.__dict__ ... observe la salida ... >>> Ejercicio 5.2: Modificaci\u00f3n de datos de instancia Intente configurar un nuevo atributo en una de las instancias anteriores: >>> goog.date = '6/11/2007' >>> goog.__dict__ ... observe el resultado ... >>> ibm.__dict__ ... observe el resultado ... >>> En el resultado anterior, notar\u00e1 que la instancia goog tiene un atributo date mientras que la instancia ibm no lo tiene. Es importante notar que Python realmente no impone ninguna restricci\u00f3n sobre los atributos. Por ejemplo, los atributos de una instancia no est\u00e1n limitados a los configurados en el m\u00e9todo __init__() . En lugar de establecer un atributo, intente colocar un nuevo valor directamente en el objeto __dict__ : >>> goog.__dict__['time'] = '9:45am' >>> goog.time '9:45am' >>> Aqu\u00ed, realmente se nota el hecho de que una instancia es solo la parte superior de un diccionario. Nota: se debe enfatizar que la manipulaci\u00f3n directa del diccionario es poco com\u00fan; siempre debe escribir su c\u00f3digo para usar la sintaxis ( . ). Ejercicio 5.3: El rol de las clases Las definiciones que componen una definici\u00f3n de clase son compartidas por todas las instancias de esa clase. Tenga en cuenta que todas las instancias tienen un enlace a su clase asociada: >>> goog.__class__ ... observe la salida ... >>> ibm.__class__ ... observe la salida ... >>> Intente llamar a un m\u00e9todo en las instancias: >>> goog.cost() 49010.0 >>> ibm.cost() 4561.5 >>> Observe que el nombre cost no est\u00e1 definido ni en goog.__dict__ ni en ibm.__dict__ . En cambio, lo proporciona el diccionario de clases. Pruebe esto: >>> Stock.__dict__['cost'] ... observe la salida... >>> Intente llamar al m\u00e9todo cost() directamente a trav\u00e9s del diccionario: >>> Stock.__dict__['cost'](goog) 49010.0 >>> Stock.__dict__['cost'](ibm) 4561.5 >>> Observe c\u00f3mo est\u00e1 llamando a la funci\u00f3n definida en la definici\u00f3n de clase y c\u00f3mo el argumento self obtiene la instancia. Intenta agregar un nuevo atributo a la clase Stock : >>> Stock.foo = 42 >>> Observa c\u00f3mo este nuevo atributo ahora aparece en todas las instancias: >>> goog.foo 42 >>> ibm.foo 42 >>> Sin embargo, observa que no es parte del diccionario de la instancia: >>> goog.__dict__ ... observa la salida y observa que no hay ning\u00fan atributo 'foo' ... >>> La raz\u00f3n por la que puedes acceder al atributo foo en las instancias es que Python siempre verifica el diccionario de clase si no puede encontrar algo en la instancia misma. Nota: Esta parte del ejercicio ilustra algo conocido como variable de clase. Supongamos, por ejemplo, que tiene una clase como esta: class Foo: a = 13 # Variable de clase def __init__(self,b): self.b = b # Variable de instancia En esta clase, la variable a , asignada en el cuerpo de la clase misma, es una \"variable de clase\". Es compartida por todas las instancias que se crean. Por ejemplo: >>> f = Foo(10) >>> g = Foo(20) >>> f.a # Inspeccionar la variable de clase (igual para ambas instancias) 13 >>> g.a 13 >>> f.b # Inspeccionar la variable de instancia (difiere) 10 >>> g.b 20 >>> Foo.a = 42 # Cambiar el valor de la variable de clase >>> f.a 42 >>> g.a 42 >>> Ejercicio 5.4: M\u00e9todos enlazados Una caracter\u00edstica sutil de Python es que invocar un m\u00e9todo en realidad implica dos pasos y algo conocido como m\u00e9todo enlazado. Por ejemplo: >>> s = goog.sell >>> s <bound method Stock.sell of Stock('GOOG', 100, 490.1)> >>> s(25) >>> goog.shares 75 >>> Los m\u00e9todos enlazados en realidad contienen todas las piezas necesarias para llamar a un m\u00e9todo. Por ejemplo, mantienen un registro de la funci\u00f3n que implementa el m\u00e9todo: >>> s.__func__ <function sell at 0x10049af50> >>> Este es el mismo valor que se encuentra en el diccionario Stock . >>> Stock.__dict__['sell'] <function sell at 0x10049af50> >>> Los m\u00e9todos enlazados tambi\u00e9n registran la instancia, que es el argumento self . >>> s.__self__ Stock('GOOG',75,490.1) >>> Cuando invocas la funci\u00f3n usando () todas las piezas se unen. Por ejemplo, llamar a s(25) en realidad hace esto: >>> s.__func__(s.__self__, 25) # Igual que s(25) >>> goog.shares 50 >>> Ejercicio 5.5: Herencia Crea una nueva clase que herede de Stock . >>> class NewStock(Stock): def yow(self): print('Yow!') >>> n = NewStock('ACME', 50, 123.45) >>> n.cost() 6172.50 >>> n.yow() Yow! >>> La herencia se implementa extendiendo el proceso de b\u00fasqueda de atributos. El atributo __bases__ tiene una tupla de los padres inmediatos: >>> NewStock.__bases__ (<class 'stock.Stock'>,) >>> El atributo __mro__ tiene una tupla de todos los padres, en el orden en que se buscar\u00e1n los atributos. >>> NewStock.__mro__ (<class '__main__.NewStock'>, <class 'stock.Stock'>, <class 'object'>) >>> As\u00ed es como se encontrar\u00eda el m\u00e9todo cost() de la instancia n anterior: >>> for cls in n.__class__.__mro__: if 'cost' in cls.__dict__: break >>> cls <class '__main__.Stock'> >>> cls.__dict__['cost'] <function cost at 0x101aed598> >>> Contenido | Anterior (4.4 Definici\u00f3n de excepciones) | Pr\u00f3ximo (5.2 T\u00e9cnicas de encapsulaci\u00f3n)","title":"01_Dicts_revisited"},{"location":"05_Object_model/01_Dicts_revisited/#51-revision-de-diccionarios","text":"El sistema de objetos de Python se basa en gran medida en una implementaci\u00f3n que involucra diccionarios. Esta secci\u00f3n trata sobre eso.","title":"5.1 Revisi\u00f3n de diccionarios"},{"location":"05_Object_model/01_Dicts_revisited/#diccionarios-revisitados","text":"Recuerde que un diccionario es una colecci\u00f3n de valores nombrados. stock = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.1 } Los diccionarios se usan com\u00fanmente para estructuras de datos simples. Sin embargo, se usan para partes cr\u00edticas del int\u00e9rprete y pueden ser el tipo de datos m\u00e1s importante en Python .","title":"Diccionarios revisitados"},{"location":"05_Object_model/01_Dicts_revisited/#diccionarios-y-modulos","text":"Dentro de un m\u00f3dulo, un diccionario contiene todas las variables y funciones globales. # foo.py x = 42 def bar(): ... def spam(): ... Si inspecciona foo.__dict__ o globals() , ver\u00e1 el diccionario. { 'x' : 42, 'bar' : <function bar>, 'spam' : <function spam> }","title":"Diccionarios y m\u00f3dulos"},{"location":"05_Object_model/01_Dicts_revisited/#diccionarios-y-objetos","text":"Los objetos definidos por el usuario tambi\u00e9n usan diccionarios tanto para los datos de instancia como para las clases. De hecho, todo el sistema de objetos es principalmente una capa adicional que se coloca sobre los diccionarios. Un diccionario contiene los datos de instancia, __dict__ . >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ {'name' : 'GOOG', 'shares' : 100, 'price': 490.1 } Este diccionario (y la instancia) se rellenan al asignar a self . class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Los datos de la instancia, self.__dict__ , tienen este aspecto: { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } Cada instancia obtiene su propio diccionario privado. s = Stock('GOOG', 100, 490.1) # {'name' : 'GOOG','shares' : 100, 'price': 490.1 } t = Stock('AAPL', 50, 123.45) # {'name' : 'AAPL','shares' : 50, 'price': 123.45 } Si creaste 100 instancias de alguna clase, hay 100 diccionarios que contienen datos.","title":"Diccionarios y objetos"},{"location":"05_Object_model/01_Dicts_revisited/#miembros-de-clase","text":"Un diccionario separado tambi\u00e9n contiene los m\u00e9todos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares El diccionario est\u00e1 en Stock.__dict__ . { 'cost': <function>, 'sell': <function>, '__init__': <function> }","title":"Miembros de clase"},{"location":"05_Object_model/01_Dicts_revisited/#instancias-y-clases","text":"Las instancias y las clases est\u00e1n vinculadas entre s\u00ed. El atributo __class__ hace referencia a la clase. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s.__class__ <class '__main__.Stock'> >>> El diccionario de instancias contiene datos exclusivos de cada instancia, mientras que el diccionario de clases contiene datos compartidos colectivamente por todas las instancias.","title":"Instancias y clases"},{"location":"05_Object_model/01_Dicts_revisited/#acceso-a-atributos","text":"Cuando trabaja con objetos, accede a los datos y m\u00e9todos utilizando el operador . . x = obj.name # Obtenci\u00f3n obj.name = value # Configuraci\u00f3n del obj.name # Eliminaci\u00f3n Estas operaciones est\u00e1n directamente vinculadas a los diccionarios que se encuentran debajo de las s\u00e1banas.","title":"Acceso a atributos"},{"location":"05_Object_model/01_Dicts_revisited/#modificacion-de-instancias","text":"Las operaciones que modifican un objeto actualizan el diccionario subyacente. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'nombre': 'GOOG', 'acciones': 100, 'precio': 490.1 } >>> s.shares = 50 # Configuraci\u00f3n >>> s.date = '6/7/2007' # Configuraci\u00f3n >>> s.__dict__ { 'nombre': 'GOOG', 'acciones': 50, 'precio': 490.1, 'fecha': '6/7/2007' } >>> del s.shares # Eliminando >>> s.__dict__ { 'nombre': 'GOOG', 'precio': 490.1, 'fecha': '6/7/2007' } >>>","title":"Modificaci\u00f3n de instancias"},{"location":"05_Object_model/01_Dicts_revisited/#lectura-de-atributos","text":"Supongamos que lee un atributo en una instancia. x = obj.name El atributo puede existir en dos lugares: Diccionario de instancia local. Diccionario de clase. Se deben verificar ambos diccionarios. Primero, verifique en __dict__ local. Si no se encuentra, busque en __dict__ de la clase hasta __class__ . >>> s = Stock(...) >>> s.name 'GOOG' >>> s.cost() 49010.0 >>> Este esquema de b\u00fasqueda es la forma en que los miembros de una clase se comparten entre todas las instancias.","title":"Lectura de atributos"},{"location":"05_Object_model/01_Dicts_revisited/#como-funciona-la-herencia","text":"Las clases pueden heredar de otras clases. class A(B, C): ... Las clases base se almacenan en una tupla en cada clase. >>> A.__bases__ (<class '__main__.B'>, <class '__main__.C'>) >>> Esto proporciona un enlace a las clases padre.","title":"C\u00f3mo funciona la herencia"},{"location":"05_Object_model/01_Dicts_revisited/#lectura-de-atributos-con-herencia","text":"L\u00f3gicamente, el proceso para encontrar un atributo es el siguiente. Primero, verifique en __dict__ local. Si no lo encuentra, busque en __dict__ de la clase. Si no lo encuentra en la clase, busque en las clases base a trav\u00e9s de __bases__ . Sin embargo, hay algunos aspectos sutiles de esto que se analizan a continuaci\u00f3n.","title":"Lectura de atributos con herencia"},{"location":"05_Object_model/01_Dicts_revisited/#lectura-de-atributos-con-herencia-unica","text":"En las jerarqu\u00edas de herencia, los atributos se encuentran recorriendo el \u00e1rbol de herencia en orden. class A: pass class B(A): pass class C(A): pass class D(B): pass class E(D): pass Con herencia simple, hay una \u00fanica ruta hacia la cima. Se detiene en la primera coincidencia.","title":"Lectura de atributos con herencia \u00fanica"},{"location":"05_Object_model/01_Dicts_revisited/#orden-de-resolucion-de-metodos-o-mro","text":"Python precalcula una cadena de herencia y la almacena en el atributo MRO de la clase. Puede verla. >>> E.__mro__ (<class '__main__.E'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>) >>> Esta cadena se denomina Orden de resoluci\u00f3n de m\u00e9todos . Para encontrar un atributo, Python recorre el MRO en orden. La primera coincidencia gana.","title":"Orden de resoluci\u00f3n de m\u00e9todos o MRO"},{"location":"05_Object_model/01_Dicts_revisited/#mro-en-herencia-multiple","text":"Con la herencia m\u00faltiple, no hay una \u00fanica ruta hacia la cima. Veamos un ejemplo. class A: pass class B: pass class C(A, B): pass class D(B): pass class E(C, D): pass \u00bfQu\u00e9 sucede cuando se accede a un atributo? e = E() e.attr Se lleva a cabo un proceso de b\u00fasqueda de atributos, pero \u00bfcu\u00e1l es el orden? Eso es un problema. Python utiliza herencia m\u00faltiple cooperativa que obedece algunas reglas sobre el orden de las clases. Los hijos siempre se comprueban antes que los padres Los padres (si son m\u00faltiples) siempre se comprueban en el orden indicado. El MRO se calcula ordenando todas las clases en una jerarqu\u00eda de acuerdo con esas reglas. >>> E.__mro__ ( <class 'E'>, <class 'C'>, <class 'A'>, <class 'D'>, <class 'B'>, <class 'object'>) >>> El algoritmo subyacente se llama \"Algoritmo de linealizaci\u00f3n C3\". Los detalles precisos no son importantes siempre que recuerde que una jerarqu\u00eda de clases obedece las mismas reglas de ordenamiento que podr\u00eda seguir si su casa se incendiara y tuviera que evacuar: primero los ni\u00f1os, luego los padres.","title":"MRO en herencia m\u00faltiple"},{"location":"05_Object_model/01_Dicts_revisited/#una-reutilizacion-de-codigo-extrana-que-implica-herencia-multiple","text":"Considere dos objetos completamente no relacionados: class Dog: # Perro def noise(self): # ruido return 'Bark' # Ladrar def chase(self): # caza return 'Chasing!' # Cazando class LoudDog(Dog): # Perro ruidoso def noise(self): # C\u00f3digo com\u00fan con LoudBike (abajo) return super().noise().upper() Y class Bike: def noise(self): return 'On Your Left' def pedal(self): return 'Pedaling!' class LoudBike(Bike): def noise(self): # C\u00f3digo com\u00fan con LoudDog (arriba) return super().noise().upper() Hay un c\u00f3digo com\u00fan en la implementaci\u00f3n de LoudDog.noise() y LoudBike.noise() . De hecho, el c\u00f3digo es exactamente el mismo. Naturalmente, c\u00f3digo como ese est\u00e1 destinado a atraer a los ingenieros de software.","title":"Una reutilizaci\u00f3n de c\u00f3digo extra\u00f1a (que implica herencia m\u00faltiple)"},{"location":"05_Object_model/01_Dicts_revisited/#el-patron-mixin","text":"El patr\u00f3n Mixin es una clase con un fragmento de c\u00f3digo. class Loud: def noise(self): return super().noise().upper() Esta clase no se puede usar de forma aislada. Se mezcla con otras clases a trav\u00e9s de la herencia. class LoudDog(Loud, Dog): pass class LoudBike(Loud, Bike): pass Milagrosamente, la sonoridad ahora se implement\u00f3 solo una vez y se reutiliz\u00f3 en dos clases completamente no relacionadas. Este tipo de truco es uno de los usos principales de la herencia m\u00faltiple en Python.","title":"El patr\u00f3n \"Mixin\""},{"location":"05_Object_model/01_Dicts_revisited/#por-que-super","text":"Siempre use super() al anular m\u00e9todos. class Loud: def noise(self): return super().noise().upper() super() delega a la pr\u00f3xima clase en el MRO. La parte complicada es que no sabe cual es. En particular, no sabe cual es si se utiliza la herencia m\u00faltiple.","title":"Por qu\u00e9 super()"},{"location":"05_Object_model/01_Dicts_revisited/#algunas-precauciones","text":"La herencia m\u00faltiple es una herramienta poderosa. Recuerde que el poder conlleva responsabilidad. Los marcos de trabajo y las bibliotecas a veces la utilizan para funciones avanzadas que implican la composici\u00f3n de componentes. Ahora, olv\u00eddese de que vio eso.","title":"Algunas precauciones"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicios","text":"En la Secci\u00f3n 4, defini\u00f3 una clase Stock que representaba una tenencia de acciones. En este ejercicio, utilizaremos esa clase. Reinicie el int\u00e9rprete y cree algunas instancias: >>> ================================= RESTART ================================== >>> from stock import Stock >>> goog = Stock('GOOG',100,490.10) >>> ibm = Stock('IBM',50, 91.23) >>>","title":"Ejercicios"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicio-51-representacion-de-instancias","text":"En el modo interactivo, inspeccione los diccionarios subyacentes de las dos instancias que cre\u00f3: >>> goog.__dict__ ... observe la salida ... >>> ibm.__dict__ ... observe la salida ... >>>","title":"Ejercicio 5.1: Representaci\u00f3n de instancias"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicio-52-modificacion-de-datos-de-instancia","text":"Intente configurar un nuevo atributo en una de las instancias anteriores: >>> goog.date = '6/11/2007' >>> goog.__dict__ ... observe el resultado ... >>> ibm.__dict__ ... observe el resultado ... >>> En el resultado anterior, notar\u00e1 que la instancia goog tiene un atributo date mientras que la instancia ibm no lo tiene. Es importante notar que Python realmente no impone ninguna restricci\u00f3n sobre los atributos. Por ejemplo, los atributos de una instancia no est\u00e1n limitados a los configurados en el m\u00e9todo __init__() . En lugar de establecer un atributo, intente colocar un nuevo valor directamente en el objeto __dict__ : >>> goog.__dict__['time'] = '9:45am' >>> goog.time '9:45am' >>> Aqu\u00ed, realmente se nota el hecho de que una instancia es solo la parte superior de un diccionario. Nota: se debe enfatizar que la manipulaci\u00f3n directa del diccionario es poco com\u00fan; siempre debe escribir su c\u00f3digo para usar la sintaxis ( . ).","title":"Ejercicio 5.2: Modificaci\u00f3n de datos de instancia"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicio-53-el-rol-de-las-clases","text":"Las definiciones que componen una definici\u00f3n de clase son compartidas por todas las instancias de esa clase. Tenga en cuenta que todas las instancias tienen un enlace a su clase asociada: >>> goog.__class__ ... observe la salida ... >>> ibm.__class__ ... observe la salida ... >>> Intente llamar a un m\u00e9todo en las instancias: >>> goog.cost() 49010.0 >>> ibm.cost() 4561.5 >>> Observe que el nombre cost no est\u00e1 definido ni en goog.__dict__ ni en ibm.__dict__ . En cambio, lo proporciona el diccionario de clases. Pruebe esto: >>> Stock.__dict__['cost'] ... observe la salida... >>> Intente llamar al m\u00e9todo cost() directamente a trav\u00e9s del diccionario: >>> Stock.__dict__['cost'](goog) 49010.0 >>> Stock.__dict__['cost'](ibm) 4561.5 >>> Observe c\u00f3mo est\u00e1 llamando a la funci\u00f3n definida en la definici\u00f3n de clase y c\u00f3mo el argumento self obtiene la instancia. Intenta agregar un nuevo atributo a la clase Stock : >>> Stock.foo = 42 >>> Observa c\u00f3mo este nuevo atributo ahora aparece en todas las instancias: >>> goog.foo 42 >>> ibm.foo 42 >>> Sin embargo, observa que no es parte del diccionario de la instancia: >>> goog.__dict__ ... observa la salida y observa que no hay ning\u00fan atributo 'foo' ... >>> La raz\u00f3n por la que puedes acceder al atributo foo en las instancias es que Python siempre verifica el diccionario de clase si no puede encontrar algo en la instancia misma. Nota: Esta parte del ejercicio ilustra algo conocido como variable de clase. Supongamos, por ejemplo, que tiene una clase como esta: class Foo: a = 13 # Variable de clase def __init__(self,b): self.b = b # Variable de instancia En esta clase, la variable a , asignada en el cuerpo de la clase misma, es una \"variable de clase\". Es compartida por todas las instancias que se crean. Por ejemplo: >>> f = Foo(10) >>> g = Foo(20) >>> f.a # Inspeccionar la variable de clase (igual para ambas instancias) 13 >>> g.a 13 >>> f.b # Inspeccionar la variable de instancia (difiere) 10 >>> g.b 20 >>> Foo.a = 42 # Cambiar el valor de la variable de clase >>> f.a 42 >>> g.a 42 >>>","title":"Ejercicio 5.3: El rol de las clases"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicio-54-metodos-enlazados","text":"Una caracter\u00edstica sutil de Python es que invocar un m\u00e9todo en realidad implica dos pasos y algo conocido como m\u00e9todo enlazado. Por ejemplo: >>> s = goog.sell >>> s <bound method Stock.sell of Stock('GOOG', 100, 490.1)> >>> s(25) >>> goog.shares 75 >>> Los m\u00e9todos enlazados en realidad contienen todas las piezas necesarias para llamar a un m\u00e9todo. Por ejemplo, mantienen un registro de la funci\u00f3n que implementa el m\u00e9todo: >>> s.__func__ <function sell at 0x10049af50> >>> Este es el mismo valor que se encuentra en el diccionario Stock . >>> Stock.__dict__['sell'] <function sell at 0x10049af50> >>> Los m\u00e9todos enlazados tambi\u00e9n registran la instancia, que es el argumento self . >>> s.__self__ Stock('GOOG',75,490.1) >>> Cuando invocas la funci\u00f3n usando () todas las piezas se unen. Por ejemplo, llamar a s(25) en realidad hace esto: >>> s.__func__(s.__self__, 25) # Igual que s(25) >>> goog.shares 50 >>>","title":"Ejercicio 5.4: M\u00e9todos enlazados"},{"location":"05_Object_model/01_Dicts_revisited/#ejercicio-55-herencia","text":"Crea una nueva clase que herede de Stock . >>> class NewStock(Stock): def yow(self): print('Yow!') >>> n = NewStock('ACME', 50, 123.45) >>> n.cost() 6172.50 >>> n.yow() Yow! >>> La herencia se implementa extendiendo el proceso de b\u00fasqueda de atributos. El atributo __bases__ tiene una tupla de los padres inmediatos: >>> NewStock.__bases__ (<class 'stock.Stock'>,) >>> El atributo __mro__ tiene una tupla de todos los padres, en el orden en que se buscar\u00e1n los atributos. >>> NewStock.__mro__ (<class '__main__.NewStock'>, <class 'stock.Stock'>, <class 'object'>) >>> As\u00ed es como se encontrar\u00eda el m\u00e9todo cost() de la instancia n anterior: >>> for cls in n.__class__.__mro__: if 'cost' in cls.__dict__: break >>> cls <class '__main__.Stock'> >>> cls.__dict__['cost'] <function cost at 0x101aed598> >>> Contenido | Anterior (4.4 Definici\u00f3n de excepciones) | Pr\u00f3ximo (5.2 T\u00e9cnicas de encapsulaci\u00f3n)","title":"Ejercicio 5.5: Herencia"},{"location":"05_Object_model/02_Classes_encapsulation/","text":"Contenido | Anterior (5.1 Diccionarios revisados) | Pr\u00f3ximo (6 Generadores) 5.2 Clases y encapsulaci\u00f3n Al escribir clases, es com\u00fan intentar encapsular detalles internos. Esta secci\u00f3n presenta algunos modismos de programaci\u00f3n de Python para esto, incluidas las variables y propiedades privadas. P\u00fablico vs. Privado. Una de las funciones principales de una clase es encapsular datos y detalles de implementaci\u00f3n interna de un objeto. Sin embargo, una clase tambi\u00e9n define una interfaz p\u00fablica que se supone que el mundo exterior debe usar para manipular el objeto. Esta distinci\u00f3n entre los detalles de implementaci\u00f3n y la interfaz p\u00fablica es importante. Un problema En Python, casi todo lo relacionado con las clases y los objetos es abierto . Puede inspeccionar f\u00e1cilmente los componentes internos de los objetos. Puedes cambiar las cosas a voluntad. No existe una noci\u00f3n s\u00f3lida de control de acceso (es decir, miembros de clase privados) Eso es un problema cuando intentas aislar detalles de la implementaci\u00f3n interna . Encapsulaci\u00f3n de Python Python se basa en convenciones de programaci\u00f3n para indicar el uso previsto de algo. Estas convenciones se basan en la denominaci\u00f3n. Existe una actitud general de que es responsabilidad del programador observar las reglas en lugar de que el lenguaje las imponga. Atributos privados Cualquier nombre de atributo con _ inicial se considera privado . class Person: def __init__(self, name): self._name = name Como se mencion\u00f3 anteriormente, este es solo un estilo de programaci\u00f3n. A\u00fan puedes acceder a \u00e9l y cambiarlo. >>> p = Person('Guido') >>> p._name 'Guido' >>> p._name = 'Dave' >>> Como regla general, cualquier nombre con un _ inicial se considera una implementaci\u00f3n interna, ya sea una variable, una funci\u00f3n o el nombre de un m\u00f3dulo. Si te encuentras usando dichos nombres directamente, probablemente est\u00e9s haciendo algo mal. Busca una funcionalidad de nivel superior. Atributos simples Considera la siguiente clase. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Una caracter\u00edstica sorprendente es que puedes establecer los atributos con cualquier valor: >>> s = Stock('IBM', 50, 91.1) >>> s.shares = 100 >>> s.shares = \"hundred\" >>> s.shares = [1, 0, 0] >>> Puedes ver eso y pensar que necesitas algunas comprobaciones adicionales. s.shares = '50' # Generar un TypeError, esto es una cadena \u00bfC\u00f3mo lo har\u00edas? Atributos administrados Un enfoque: introducir m\u00e9todos de acceso. class Stock: def __init__(self, name, shares, price): self.name = name self.set_shares(shares) self.price = price # Funci\u00f3n que superpone la operaci\u00f3n \"get\" def get_shares(self): return self._shares # Funci\u00f3n que superpone la operaci\u00f3n \"set\" def set_shares(self, value): if not isinstance(value, int): raise TypeError('Se espera un int') self._shares = value Es una l\u00e1stima que esto rompa todo nuestro c\u00f3digo existente. s.shares = 50 se convierte en s.set_shares(50) Propiedades Existe un enfoque alternativo al patr\u00f3n anterior. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Esperado un int') self._shares = value El acceso normal a los atributos ahora activa los m\u00e9todos getter y setter en @property y @shares.setter . >>> s = Stock('IBM', 50, 91.1) >>> s.shares # Disparado por @property 50 >>> s.shares = 75 # Disparado por @shares.setter >>> Con este patr\u00f3n, no se necesitan cambios en el c\u00f3digo fuente. El nuevo setter tambi\u00e9n se llama cuando hay una asignaci\u00f3n dentro de la clase, incluso dentro del m\u00e9todo __init__() . class Stock: def __init__(self, name, shares, price): ... # Esta asignaci\u00f3n llama al configurador que aparece a continuaci\u00f3n self.shares = shares ... ... @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Esperado un int') self._shares = value A menudo existe una confusi\u00f3n entre una propiedad y el uso de nombres privados. Aunque una propiedad usa internamente un nombre privado como _shares , el resto de la clase (no la propiedad) puede seguir usando un nombre como shares . Las propiedades tambi\u00e9n son \u00fatiles para los atributos de datos calculados. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def cost(self): return self.shares * self.price ... Esto le permite eliminar los par\u00e9ntesis adicionales, ocultando el hecho de que en realidad es un m\u00e9todo: >>> s = Stock('GOOG', 100, 490.1) >>> s.shares # Variable de instancia 100 >>> s.cost # Valor calculado 49010.0 >>> Acceso uniforme El \u00faltimo ejemplo muestra c\u00f3mo poner una interfaz m\u00e1s uniforme en un objeto. Si no lo hace, un objeto puede resultar confuso de usar: >>> s = Stock('GOOG', 100, 490.1) >>> a = s.cost() # M\u00e9todo 49010.0 >>> b = s.shares # Atributo de datos 100 >>> \u00bfPor qu\u00e9 se requiere () para cost , pero no para shares ? Una propiedad puede solucionar esto. Sintaxis del decorador La sintaxis @ se conoce como \"decoraci\u00f3n\". Especifica un modificador que se aplica a la definici\u00f3n de funci\u00f3n que sigue inmediatamente. ... @property def cost(self): return self.shares * self.price Se proporcionan m\u00e1s detalles en la Secci\u00f3n 7 . Atributo __slots__ Puede restringir el conjunto de nombres de atributos. class Stock: __slots__ = ('name','_shares','price') def __init__(self, name, shares, price): self.name = name ... Se generar\u00e1 un error para otros atributos. >>> s = Stock('GOOG', 100, 490.1) >>> s.price = 385.15 >>> s.prices = 410.2 Traceback (most recent call last): File \"<string>\", line 1, in <module> AttributeError: 'Stock' object has no attribute 'prices' and no __dict__ for setting new attributes. Did you mean: 'price'? Aunque esto evita errores y restringe el uso de objetos, en realidad se utiliza para mejorar el rendimiento y hace que Python utilice la memoria de forma m\u00e1s eficiente. Comentarios finales sobre la encapsulaci\u00f3n No se exceda con los atributos privados, las propiedades, los slots, etc. Tienen una finalidad espec\u00edfica y puede verlos al leer otro c\u00f3digo Python. Sin embargo, no son necesarios para la mayor\u00eda de la codificaci\u00f3n del d\u00eda a d\u00eda. Ejercicios Ejercicio 5.6: Propiedades simples Las propiedades son una forma \u00fatil de agregar \"atributos calculados\" a un objeto. En stock.py , cre\u00f3 un objeto Stock . Observa que en tu objeto hay una ligera inconsistencia en c\u00f3mo se extraen los diferentes tipos de datos: >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.shares 100 >>> s.price 490.1 >>> s.cost() 49010.0 >>> En concreto, observa c\u00f3mo tienes que a\u00f1adir el extra () a cost porque es un m\u00e9todo. Puedes deshacerte del extra () en cost() si lo conviertes en una propiedad. Tome su clase Stock y modif\u00edquela para que el c\u00e1lculo de costos funcione de esta manera: >>> ================================= RESTART ================================== >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.cost 49010.0 >>> Intente llamar a s.cost() como una funci\u00f3n y observe que no funciona ahora que cost se ha definido como una propiedad. >>> s.cost() ... falla ... >>> Hacer este cambio probablemente romper\u00e1 su programa pcost.py anterior. Es posible que deba volver atr\u00e1s y deshacerse del () en el m\u00e9todo cost() . Ejercicio 5.7: Properties and Setters Modifique el atributo shares para que el valor se almacene en un atributo privado y se utilice un par de funciones con @property para garantizar que siempre se establezca en un valor entero. Aqu\u00ed hay un ejemplo del comportamiento esperado: >>> ================================= RESTART ================================== >>> from stock import Stock >>> s = Stock('GOOG',100,490.10) >>> s.shares = 50 >>> s.shares = 'a lot' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: Esperado un int >>> Ejercicio 5.8: Agregar __slots__ Modifique la clase Stock para que tenga un atributo __slots__ . Luego, verifique que no se puedan agregar nuevos atributos: >>> ================================= RESTART ================================= >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.10) >>> s.name 'GOOG' >>> s.blah = 42 ... vea qu\u00e9 sucede... >>> Cuando usa __slots__ , Python usa una representaci\u00f3n interna m\u00e1s eficiente de los objetos. \u00bfQu\u00e9 sucede si intenta inspeccionar el diccionario subyacente de s arriba? >>> s.__dict__ ... vea lo que sucede... >>> Cabe se\u00f1alar que __slots__ se utiliza m\u00e1s com\u00fanmente como una optimizaci\u00f3n en clases que sirven como estructuras de datos. El uso de slots har\u00e1 que dichos programas utilicen mucha menos memoria y se ejecuten un poco m\u00e1s r\u00e1pido. Sin embargo, probablemente deber\u00eda evitar __slots__ en la mayor\u00eda de las otras clases. Contenido | Anterior (5.1 Diccionarios revisados) | Pr\u00f3ximo (6 Generadores)","title":"02_Classes_encapsulation"},{"location":"05_Object_model/02_Classes_encapsulation/#52-clases-y-encapsulacion","text":"Al escribir clases, es com\u00fan intentar encapsular detalles internos. Esta secci\u00f3n presenta algunos modismos de programaci\u00f3n de Python para esto, incluidas las variables y propiedades privadas.","title":"5.2 Clases y encapsulaci\u00f3n"},{"location":"05_Object_model/02_Classes_encapsulation/#publico-vs-privado","text":"Una de las funciones principales de una clase es encapsular datos y detalles de implementaci\u00f3n interna de un objeto. Sin embargo, una clase tambi\u00e9n define una interfaz p\u00fablica que se supone que el mundo exterior debe usar para manipular el objeto. Esta distinci\u00f3n entre los detalles de implementaci\u00f3n y la interfaz p\u00fablica es importante.","title":"P\u00fablico vs. Privado."},{"location":"05_Object_model/02_Classes_encapsulation/#un-problema","text":"En Python, casi todo lo relacionado con las clases y los objetos es abierto . Puede inspeccionar f\u00e1cilmente los componentes internos de los objetos. Puedes cambiar las cosas a voluntad. No existe una noci\u00f3n s\u00f3lida de control de acceso (es decir, miembros de clase privados) Eso es un problema cuando intentas aislar detalles de la implementaci\u00f3n interna .","title":"Un problema"},{"location":"05_Object_model/02_Classes_encapsulation/#encapsulacion-de-python","text":"Python se basa en convenciones de programaci\u00f3n para indicar el uso previsto de algo. Estas convenciones se basan en la denominaci\u00f3n. Existe una actitud general de que es responsabilidad del programador observar las reglas en lugar de que el lenguaje las imponga.","title":"Encapsulaci\u00f3n de Python"},{"location":"05_Object_model/02_Classes_encapsulation/#atributos-privados","text":"Cualquier nombre de atributo con _ inicial se considera privado . class Person: def __init__(self, name): self._name = name Como se mencion\u00f3 anteriormente, este es solo un estilo de programaci\u00f3n. A\u00fan puedes acceder a \u00e9l y cambiarlo. >>> p = Person('Guido') >>> p._name 'Guido' >>> p._name = 'Dave' >>> Como regla general, cualquier nombre con un _ inicial se considera una implementaci\u00f3n interna, ya sea una variable, una funci\u00f3n o el nombre de un m\u00f3dulo. Si te encuentras usando dichos nombres directamente, probablemente est\u00e9s haciendo algo mal. Busca una funcionalidad de nivel superior.","title":"Atributos privados"},{"location":"05_Object_model/02_Classes_encapsulation/#atributos-simples","text":"Considera la siguiente clase. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Una caracter\u00edstica sorprendente es que puedes establecer los atributos con cualquier valor: >>> s = Stock('IBM', 50, 91.1) >>> s.shares = 100 >>> s.shares = \"hundred\" >>> s.shares = [1, 0, 0] >>> Puedes ver eso y pensar que necesitas algunas comprobaciones adicionales. s.shares = '50' # Generar un TypeError, esto es una cadena \u00bfC\u00f3mo lo har\u00edas?","title":"Atributos simples"},{"location":"05_Object_model/02_Classes_encapsulation/#atributos-administrados","text":"Un enfoque: introducir m\u00e9todos de acceso. class Stock: def __init__(self, name, shares, price): self.name = name self.set_shares(shares) self.price = price # Funci\u00f3n que superpone la operaci\u00f3n \"get\" def get_shares(self): return self._shares # Funci\u00f3n que superpone la operaci\u00f3n \"set\" def set_shares(self, value): if not isinstance(value, int): raise TypeError('Se espera un int') self._shares = value Es una l\u00e1stima que esto rompa todo nuestro c\u00f3digo existente. s.shares = 50 se convierte en s.set_shares(50)","title":"Atributos administrados"},{"location":"05_Object_model/02_Classes_encapsulation/#propiedades","text":"Existe un enfoque alternativo al patr\u00f3n anterior. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Esperado un int') self._shares = value El acceso normal a los atributos ahora activa los m\u00e9todos getter y setter en @property y @shares.setter . >>> s = Stock('IBM', 50, 91.1) >>> s.shares # Disparado por @property 50 >>> s.shares = 75 # Disparado por @shares.setter >>> Con este patr\u00f3n, no se necesitan cambios en el c\u00f3digo fuente. El nuevo setter tambi\u00e9n se llama cuando hay una asignaci\u00f3n dentro de la clase, incluso dentro del m\u00e9todo __init__() . class Stock: def __init__(self, name, shares, price): ... # Esta asignaci\u00f3n llama al configurador que aparece a continuaci\u00f3n self.shares = shares ... ... @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Esperado un int') self._shares = value A menudo existe una confusi\u00f3n entre una propiedad y el uso de nombres privados. Aunque una propiedad usa internamente un nombre privado como _shares , el resto de la clase (no la propiedad) puede seguir usando un nombre como shares . Las propiedades tambi\u00e9n son \u00fatiles para los atributos de datos calculados. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def cost(self): return self.shares * self.price ... Esto le permite eliminar los par\u00e9ntesis adicionales, ocultando el hecho de que en realidad es un m\u00e9todo: >>> s = Stock('GOOG', 100, 490.1) >>> s.shares # Variable de instancia 100 >>> s.cost # Valor calculado 49010.0 >>>","title":"Propiedades"},{"location":"05_Object_model/02_Classes_encapsulation/#acceso-uniforme","text":"El \u00faltimo ejemplo muestra c\u00f3mo poner una interfaz m\u00e1s uniforme en un objeto. Si no lo hace, un objeto puede resultar confuso de usar: >>> s = Stock('GOOG', 100, 490.1) >>> a = s.cost() # M\u00e9todo 49010.0 >>> b = s.shares # Atributo de datos 100 >>> \u00bfPor qu\u00e9 se requiere () para cost , pero no para shares ? Una propiedad puede solucionar esto.","title":"Acceso uniforme"},{"location":"05_Object_model/02_Classes_encapsulation/#sintaxis-del-decorador","text":"La sintaxis @ se conoce como \"decoraci\u00f3n\". Especifica un modificador que se aplica a la definici\u00f3n de funci\u00f3n que sigue inmediatamente. ... @property def cost(self): return self.shares * self.price Se proporcionan m\u00e1s detalles en la Secci\u00f3n 7 .","title":"Sintaxis del decorador"},{"location":"05_Object_model/02_Classes_encapsulation/#atributo-__slots__","text":"Puede restringir el conjunto de nombres de atributos. class Stock: __slots__ = ('name','_shares','price') def __init__(self, name, shares, price): self.name = name ... Se generar\u00e1 un error para otros atributos. >>> s = Stock('GOOG', 100, 490.1) >>> s.price = 385.15 >>> s.prices = 410.2 Traceback (most recent call last): File \"<string>\", line 1, in <module> AttributeError: 'Stock' object has no attribute 'prices' and no __dict__ for setting new attributes. Did you mean: 'price'? Aunque esto evita errores y restringe el uso de objetos, en realidad se utiliza para mejorar el rendimiento y hace que Python utilice la memoria de forma m\u00e1s eficiente.","title":"Atributo __slots__"},{"location":"05_Object_model/02_Classes_encapsulation/#comentarios-finales-sobre-la-encapsulacion","text":"No se exceda con los atributos privados, las propiedades, los slots, etc. Tienen una finalidad espec\u00edfica y puede verlos al leer otro c\u00f3digo Python. Sin embargo, no son necesarios para la mayor\u00eda de la codificaci\u00f3n del d\u00eda a d\u00eda.","title":"Comentarios finales sobre la encapsulaci\u00f3n"},{"location":"05_Object_model/02_Classes_encapsulation/#ejercicios","text":"","title":"Ejercicios"},{"location":"05_Object_model/02_Classes_encapsulation/#ejercicio-56-propiedades-simples","text":"Las propiedades son una forma \u00fatil de agregar \"atributos calculados\" a un objeto. En stock.py , cre\u00f3 un objeto Stock . Observa que en tu objeto hay una ligera inconsistencia en c\u00f3mo se extraen los diferentes tipos de datos: >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.shares 100 >>> s.price 490.1 >>> s.cost() 49010.0 >>> En concreto, observa c\u00f3mo tienes que a\u00f1adir el extra () a cost porque es un m\u00e9todo. Puedes deshacerte del extra () en cost() si lo conviertes en una propiedad. Tome su clase Stock y modif\u00edquela para que el c\u00e1lculo de costos funcione de esta manera: >>> ================================= RESTART ================================== >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.cost 49010.0 >>> Intente llamar a s.cost() como una funci\u00f3n y observe que no funciona ahora que cost se ha definido como una propiedad. >>> s.cost() ... falla ... >>> Hacer este cambio probablemente romper\u00e1 su programa pcost.py anterior. Es posible que deba volver atr\u00e1s y deshacerse del () en el m\u00e9todo cost() .","title":"Ejercicio 5.6: Propiedades simples"},{"location":"05_Object_model/02_Classes_encapsulation/#ejercicio-57-properties-and-setters","text":"Modifique el atributo shares para que el valor se almacene en un atributo privado y se utilice un par de funciones con @property para garantizar que siempre se establezca en un valor entero. Aqu\u00ed hay un ejemplo del comportamiento esperado: >>> ================================= RESTART ================================== >>> from stock import Stock >>> s = Stock('GOOG',100,490.10) >>> s.shares = 50 >>> s.shares = 'a lot' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: Esperado un int >>>","title":"Ejercicio 5.7: Properties and Setters"},{"location":"05_Object_model/02_Classes_encapsulation/#ejercicio-58-agregar-__slots__","text":"Modifique la clase Stock para que tenga un atributo __slots__ . Luego, verifique que no se puedan agregar nuevos atributos: >>> ================================= RESTART ================================= >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.10) >>> s.name 'GOOG' >>> s.blah = 42 ... vea qu\u00e9 sucede... >>> Cuando usa __slots__ , Python usa una representaci\u00f3n interna m\u00e1s eficiente de los objetos. \u00bfQu\u00e9 sucede si intenta inspeccionar el diccionario subyacente de s arriba? >>> s.__dict__ ... vea lo que sucede... >>> Cabe se\u00f1alar que __slots__ se utiliza m\u00e1s com\u00fanmente como una optimizaci\u00f3n en clases que sirven como estructuras de datos. El uso de slots har\u00e1 que dichos programas utilicen mucha menos memoria y se ejecuten un poco m\u00e1s r\u00e1pido. Sin embargo, probablemente deber\u00eda evitar __slots__ en la mayor\u00eda de las otras clases. Contenido | Anterior (5.1 Diccionarios revisados) | Pr\u00f3ximo (6 Generadores)","title":"Ejercicio 5.8: Agregar __slots__"},{"location":"06_Generators/00_Overview/","text":"Contenido | Anterior (5 Funcionamiento interno de los objetos de Python) | Pr\u00f3ximo (7. Algunos temas avanzados) 6. Generadores La iteraci\u00f3n (el bucle for ) es uno de los patrones de programaci\u00f3n m\u00e1s comunes en Python. Los programas realizan muchas iteraciones para procesar listas, leer archivos, consultar bases de datos y m\u00e1s. Una de las caracter\u00edsticas m\u00e1s poderosas de Python es la capacidad de personalizar y redefinir la iteraci\u00f3n en forma de una denominada \"funci\u00f3n generadora\". Esta secci\u00f3n presenta este tema. Al final, escribir\u00e1 algunos programas que procesan algunos datos de transmisi\u00f3n en tiempo real de una manera interesante. 6.1 Protocolo de iteraci\u00f3n 6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores 6.3 Problemas y flujos de trabajo de productores y consumidores 6.4 Expresiones de generador Contenido | Anterior (5 Funcionamiento interno de los objetos de Python) | Pr\u00f3ximo (7. Algunos temas avanzados)","title":"00_Overview"},{"location":"06_Generators/00_Overview/#6-generadores","text":"La iteraci\u00f3n (el bucle for ) es uno de los patrones de programaci\u00f3n m\u00e1s comunes en Python. Los programas realizan muchas iteraciones para procesar listas, leer archivos, consultar bases de datos y m\u00e1s. Una de las caracter\u00edsticas m\u00e1s poderosas de Python es la capacidad de personalizar y redefinir la iteraci\u00f3n en forma de una denominada \"funci\u00f3n generadora\". Esta secci\u00f3n presenta este tema. Al final, escribir\u00e1 algunos programas que procesan algunos datos de transmisi\u00f3n en tiempo real de una manera interesante. 6.1 Protocolo de iteraci\u00f3n 6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores 6.3 Problemas y flujos de trabajo de productores y consumidores 6.4 Expresiones de generador Contenido | Anterior (5 Funcionamiento interno de los objetos de Python) | Pr\u00f3ximo (7. Algunos temas avanzados)","title":"6. Generadores"},{"location":"06_Generators/01_Iteration_protocol/","text":"Contenido | Anterior (5.2 T\u00e9cnicas de encapsulaci\u00f3n) | Pr\u00f3ximo (6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores) 6.1 Protocolo de iteraci\u00f3n Esta secci\u00f3n analiza el proceso subyacente de la iteraci\u00f3n. Iteraci\u00f3n en todas partes Muchos objetos diferentes admiten la iteraci\u00f3n. a = 'hello' for c in a: # Recorrer caracteres en a ... b = { 'name': 'Dave', 'password':'foo'} for k in b: # Recorrer claves en diccionario ... c = [1,2,3,4] for i in c: # Recorrer elementos en una lista/tupla ... f = open('foo.txt') for x in f: # Recorrer l\u00edneas en un archivo ... Iteraci\u00f3n: Protocolo Considere la declaraci\u00f3n for . for x in obj: # declaraciones ``` \u00bfQu\u00e9 sucede en segundo plano? ```python _iter = obj.__iter__() # Obtener objeto iterador while True: try: x = _iter.__next__() # Obtener siguiente elemento # declaraciones ... except StopIteration: # No m\u00e1s elementos break Todos los objetos que funcionan con el bucle for implementan este protocolo de iteraci\u00f3n de bajo nivel. Ejemplo: Iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> it = x.__iter__() >>> it <listiterator object at 0x590b0> >>> it.__next__() 1 >>> it.__next__() 2 >>> it.__next__() 3 >>> it.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Soporte de iteraci\u00f3n Conocer la iteraci\u00f3n es \u00fatil si desea agregarla a sus propios objetos. Por ejemplo, crear un contenedor personalizado. class Portfolio: def __init__(self): self.holdings = [] def __iter__(self): return self.holdings.__iter__() ... port = Portfolio() for s in port: ... Ejercicios Ejercicio 6.1: Iteraci\u00f3n ilustrada Cree la siguiente lista: a = [1,9,4,25,16] Itere manualmente sobre esta lista. Llame a __iter__() para obtener un iterador y llame al m\u00e9todo __next__() para obtener elementos sucesivos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): Archivo \"<stdin>\", l\u00ednea 1, en <module> StopIteration >>> La funci\u00f3n incorporada next() es un atajo para llamar al m\u00e9todo __next__() de un iterador. Intente usarlo en un archivo: >>> f = open('Data/portfolio.csv') >>> f.__iter__() # Nota: Esto devuelve el archivo en s\u00ed <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'> >>> next(f) 'name,shares,price\\n' >>> next(f) '\"AA\",100,32.20\\n' >>> next(f) '\"IBM\",50,91.10\\n' >>> Siga llamando a next(f) hasta que llegue al final del archivo. Observe lo que sucede. Ejercicio 6.2: Compatibilidad con iteraciones En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteraci\u00f3n, especialmente si su objeto envuelve una lista existente u otro iterable. En un nuevo archivo portfolio.py , defina la siguiente clase: # portfolio.py class Portfolio: def __init__(self, holdings): self._holdings = holdings @property def total_cost(self): return sum([s.cost for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Esta clase est\u00e1 pensada para ser una capa alrededor de una lista, pero con algunos m\u00e9todos adicionales como la propiedad total_cost . Modifique la funci\u00f3n read_portfolio() en report.py para que cree una instancia Portfolio como esta: # report.py ... import fileparse from stock import Stock from portfolio import Portfolio def read_portfolio(filename): ''' Lee un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as file: portdicts = fileparse.parse_csv(file, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) ... Intente ejecutar el programa report.py . Descubrir\u00e1s que falla espectacularmente debido al hecho de que las instancias de \"Portfolio\" no son iterables. >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... falla... Solucione esto modificando la clase Portfolio para que admita la iteraci\u00f3n: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Despu\u00e9s de realizar este cambio, su programa report.py deber\u00eda funcionar nuevamente. Mientras lo hace, arregle su programa pcost.py para que use el nuevo objeto Portfolio . De esta manera: # pcost.py import report def portfolio_cost(filename): ''' Calcula el costo total (shares*price) de un archivo de cartera ''' portfolio = report.read_portfolio(filename) return portfolio.total_cost ... Pru\u00e9belo para asegurarse de que funciona: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Ejercicio 6.3: C\u00f3mo crear un contenedor m\u00e1s apropiado Si crea una clase contenedora, a menudo querr\u00e1 hacer m\u00e1s que solo iterar. Modifique la clase Portfolio para que tenga otros m\u00e9todos especiales como este: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() def __len__(self): return len(self._holdings) def __getitem__(self, index): return self._holdings[index] def __contains__(self, name): return any([s.name == name for s in self._holdings]) @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Ahora, prueba algunos experimentos usando esta nueva clase: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> len(portfolio) 7 >>> portfolio[0] Stock('AA', 100, 32.2) >>> portfolio[1] Stock('IBM', 50, 91.1) >>> portfolio[0:3] [Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)] >>> 'IBM' in portfolio True >>> 'AAPL' in portfolio False >>> Una observaci\u00f3n importante sobre esto: en general, el c\u00f3digo se considera \"Pythonic\" si habla el vocabulario com\u00fan de c\u00f3mo funcionan normalmente otras partes de Python. Para los objetos contenedores, la compatibilidad con la iteraci\u00f3n, la indexaci\u00f3n, la contenci\u00f3n y otros tipos de operadores es una parte importante de esto. Contenido | Anterior (5.2 T\u00e9cnicas de encapsulaci\u00f3n) | Pr\u00f3ximo (6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores)","title":"01_Iteration_protocol"},{"location":"06_Generators/01_Iteration_protocol/#61-protocolo-de-iteracion","text":"Esta secci\u00f3n analiza el proceso subyacente de la iteraci\u00f3n.","title":"6.1 Protocolo de iteraci\u00f3n"},{"location":"06_Generators/01_Iteration_protocol/#iteracion-en-todas-partes","text":"Muchos objetos diferentes admiten la iteraci\u00f3n. a = 'hello' for c in a: # Recorrer caracteres en a ... b = { 'name': 'Dave', 'password':'foo'} for k in b: # Recorrer claves en diccionario ... c = [1,2,3,4] for i in c: # Recorrer elementos en una lista/tupla ... f = open('foo.txt') for x in f: # Recorrer l\u00edneas en un archivo ...","title":"Iteraci\u00f3n en todas partes"},{"location":"06_Generators/01_Iteration_protocol/#iteracion-protocolo","text":"Considere la declaraci\u00f3n for . for x in obj: # declaraciones ``` \u00bfQu\u00e9 sucede en segundo plano? ```python _iter = obj.__iter__() # Obtener objeto iterador while True: try: x = _iter.__next__() # Obtener siguiente elemento # declaraciones ... except StopIteration: # No m\u00e1s elementos break Todos los objetos que funcionan con el bucle for implementan este protocolo de iteraci\u00f3n de bajo nivel. Ejemplo: Iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> it = x.__iter__() >>> it <listiterator object at 0x590b0> >>> it.__next__() 1 >>> it.__next__() 2 >>> it.__next__() 3 >>> it.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>>","title":"Iteraci\u00f3n: Protocolo"},{"location":"06_Generators/01_Iteration_protocol/#soporte-de-iteracion","text":"Conocer la iteraci\u00f3n es \u00fatil si desea agregarla a sus propios objetos. Por ejemplo, crear un contenedor personalizado. class Portfolio: def __init__(self): self.holdings = [] def __iter__(self): return self.holdings.__iter__() ... port = Portfolio() for s in port: ...","title":"Soporte de iteraci\u00f3n"},{"location":"06_Generators/01_Iteration_protocol/#ejercicios","text":"","title":"Ejercicios"},{"location":"06_Generators/01_Iteration_protocol/#ejercicio-61-iteracion-ilustrada","text":"Cree la siguiente lista: a = [1,9,4,25,16] Itere manualmente sobre esta lista. Llame a __iter__() para obtener un iterador y llame al m\u00e9todo __next__() para obtener elementos sucesivos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): Archivo \"<stdin>\", l\u00ednea 1, en <module> StopIteration >>> La funci\u00f3n incorporada next() es un atajo para llamar al m\u00e9todo __next__() de un iterador. Intente usarlo en un archivo: >>> f = open('Data/portfolio.csv') >>> f.__iter__() # Nota: Esto devuelve el archivo en s\u00ed <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'> >>> next(f) 'name,shares,price\\n' >>> next(f) '\"AA\",100,32.20\\n' >>> next(f) '\"IBM\",50,91.10\\n' >>> Siga llamando a next(f) hasta que llegue al final del archivo. Observe lo que sucede.","title":"Ejercicio 6.1: Iteraci\u00f3n ilustrada"},{"location":"06_Generators/01_Iteration_protocol/#ejercicio-62-compatibilidad-con-iteraciones","text":"En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteraci\u00f3n, especialmente si su objeto envuelve una lista existente u otro iterable. En un nuevo archivo portfolio.py , defina la siguiente clase: # portfolio.py class Portfolio: def __init__(self, holdings): self._holdings = holdings @property def total_cost(self): return sum([s.cost for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Esta clase est\u00e1 pensada para ser una capa alrededor de una lista, pero con algunos m\u00e9todos adicionales como la propiedad total_cost . Modifique la funci\u00f3n read_portfolio() en report.py para que cree una instancia Portfolio como esta: # report.py ... import fileparse from stock import Stock from portfolio import Portfolio def read_portfolio(filename): ''' Lee un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as file: portdicts = fileparse.parse_csv(file, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) ... Intente ejecutar el programa report.py . Descubrir\u00e1s que falla espectacularmente debido al hecho de que las instancias de \"Portfolio\" no son iterables. >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... falla... Solucione esto modificando la clase Portfolio para que admita la iteraci\u00f3n: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Despu\u00e9s de realizar este cambio, su programa report.py deber\u00eda funcionar nuevamente. Mientras lo hace, arregle su programa pcost.py para que use el nuevo objeto Portfolio . De esta manera: # pcost.py import report def portfolio_cost(filename): ''' Calcula el costo total (shares*price) de un archivo de cartera ''' portfolio = report.read_portfolio(filename) return portfolio.total_cost ... Pru\u00e9belo para asegurarse de que funciona: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>>","title":"Ejercicio 6.2: Compatibilidad con iteraciones"},{"location":"06_Generators/01_Iteration_protocol/#ejercicio-63-como-crear-un-contenedor-mas-apropiado","text":"Si crea una clase contenedora, a menudo querr\u00e1 hacer m\u00e1s que solo iterar. Modifique la clase Portfolio para que tenga otros m\u00e9todos especiales como este: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() def __len__(self): return len(self._holdings) def __getitem__(self, index): return self._holdings[index] def __contains__(self, name): return any([s.name == name for s in self._holdings]) @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Ahora, prueba algunos experimentos usando esta nueva clase: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> len(portfolio) 7 >>> portfolio[0] Stock('AA', 100, 32.2) >>> portfolio[1] Stock('IBM', 50, 91.1) >>> portfolio[0:3] [Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)] >>> 'IBM' in portfolio True >>> 'AAPL' in portfolio False >>> Una observaci\u00f3n importante sobre esto: en general, el c\u00f3digo se considera \"Pythonic\" si habla el vocabulario com\u00fan de c\u00f3mo funcionan normalmente otras partes de Python. Para los objetos contenedores, la compatibilidad con la iteraci\u00f3n, la indexaci\u00f3n, la contenci\u00f3n y otros tipos de operadores es una parte importante de esto. Contenido | Anterior (5.2 T\u00e9cnicas de encapsulaci\u00f3n) | Pr\u00f3ximo (6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores)","title":"Ejercicio 6.3: C\u00f3mo crear un contenedor m\u00e1s apropiado"},{"location":"06_Generators/02_Customizing_iteration/","text":"Contenido | Anterior (6.1 Protocolo de iteraci\u00f3n) | Pr\u00f3ximo (6.3 Problemas y flujos de trabajo de productores y consumidores) 6.2 Personalizaci\u00f3n de la iteraci\u00f3n Esta secci\u00f3n analiza c\u00f3mo se puede personalizar la iteraci\u00f3n utilizando una funci\u00f3n generadora. Un problema Supongamos que desea crear su propio patr\u00f3n de iteraci\u00f3n personalizado. Por ejemplo, una cuenta regresiva. >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Hay una manera f\u00e1cil de hacer esto. Generadores Un generador es una funci\u00f3n que define la iteraci\u00f3n. def countdown(n): while n > 0: yield n n -= 1 Por ejemplo: >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que utiliza la declaraci\u00f3n yield . El comportamiento de los generadores es diferente al de una funci\u00f3n normal. Al llamar a una funci\u00f3n de generador se crea un objeto generador. No se ejecuta inmediatamente la funci\u00f3n. def countdown(n): # Se agreg\u00f3 una declaraci\u00f3n de impresi\u00f3n print('Cuenta regresiva desde', n) while n > 0: yield n n -= 1 >>> x = countdown(10) # NO HAY DECLARACI\u00d3N DE IMPRESI\u00d3N >>> x # x es un objeto generador <generator object countdown at 0x0000028C7FDB9FF0> >>> La funci\u00f3n solo se ejecuta en la llamada __next__() . >>> x = countdown(10) >>> x <generator object countdown at 0x0000028C7FDB9FF0> >>> x.__next__() Cuenta regresiva desde 10 10 >>> yield produce un valor, pero suspende la ejecuci\u00f3n de la funci\u00f3n. La funci\u00f3n se reanuda en la siguiente llamada a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando el generador finalmente retorna, la iteraci\u00f3n genera un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que las instrucciones for usan en listas, tuplas, diccionarios, archivos, etc. Ejercicios Ejercicio 6.4: Un generador simple Si alguna vez te encuentras con ganas de personalizar la iteraci\u00f3n, siempre debes pensar en funciones generadoras. Son f\u00e1ciles de escribir: crea una funci\u00f3n que lleve a cabo la l\u00f3gica de iteraci\u00f3n deseada y usa yield para emitir valores. Por ejemplo, prueba este generador que busca en un archivo l\u00edneas que contengan una subcadena coincidente: >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('Data/portfolio.csv'): print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> for line in filematch('Data/portfolio.csv', 'IBM'): print(line, end='') \"IBM\",50,91.10 \"IBM\",100,70.44 >>> Esto es bastante interesante: la idea de que se puede ocultar un mont\u00f3n de procesamiento personalizado en una funci\u00f3n y utilizarlo para alimentar un bucle for . El siguiente ejemplo analiza un caso m\u00e1s inusual. Ejercicio 6.5: Monitoreo de una fuente de datos en tiempo real Los generadores pueden ser una forma interesante de monitorear fuentes de datos en tiempo real, como archivos de registro o feeds del mercado de valores. En esta parte, exploraremos esta idea. Para comenzar, siga atentamente las siguientes instrucciones. El programa Data/stocksim.py es un programa que simula datos del mercado de valores. Como salida, el programa escribe constantemente datos en tiempo real en un archivo Data/stocklog.csv . En una ventana de comandos independiente, vaya al directorio Data/ y ejecute este programa: bash % python3 stocksim.py Si est\u00e1 en Windows, simplemente busque el programa stocksim.py y haga doble clic en \u00e9l para ejecutarlo. Ahora, olv\u00eddese de este programa (simplemente d\u00e9jelo ejecutar). En otra ventana, observe el archivo Data/stocklog.csv que est\u00e1 escribiendo el simulador. Deber\u00eda ver nuevas l\u00edneas de texto que se agregan al archivo cada pocos segundos. Nuevamente, simplemente deje que este programa se ejecute en segundo plano; se ejecutar\u00e1 durante varias horas (no deber\u00eda tener que preocuparse por eso). Una vez que se est\u00e9 ejecutando el programa anterior, escribamos un peque\u00f1o programa para abrir el archivo, buscar hasta el final y observar si hay un nuevo resultado. Cree un archivo follow.py y pon este c\u00f3digo en \u00e9l: # follow.py import os import time f = open('Data/stocklog.csv') f.seek(0, os.SEEK_END) # Mueve el puntero del archivo 0 bytes desde el final del archivo while True: line = f.readline() if line == '': time.sleep(0.1) # Duerme brevemente y vuelve a intentar continue fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Si ejecutas el programa, ver\u00e1s un indicador de cotizaci\u00f3n de acciones en tiempo real. Debajo del cap\u00f3, Este c\u00f3digo es similar al comando tail -f de Unix que se usa para ver un archivo de registro. Nota: El uso del m\u00e9todo readline() en este ejemplo es algo inusual, ya que no es la forma habitual de leer l\u00edneas de un archivo (normalmente, solo se usar\u00eda un bucle for ). Sin embargo, en este caso, lo estamos usando para sondear repetidamente el final del archivo para ver si se han agregado m\u00e1s datos ( readline() devolver\u00e1 datos nuevos o una cadena vac\u00eda). Ejercicio 6.6: Uso de un generador para producir datos Si observa el c\u00f3digo del Ejercicio 6.5, la primera parte del c\u00f3digo produce l\u00edneas de datos, mientras que las instrucciones al final del bucle while consumen los datos. Una caracter\u00edstica importante de las funciones generadoras es que puede mover todo el c\u00f3digo de producci\u00f3n de datos a una funci\u00f3n reutilizable. Modifique el c\u00f3digo del Ejercicio 6.5 para que la lectura del archivo la realice una funci\u00f3n generadora follow(filename) . Haz que funcione el siguiente c\u00f3digo: >>> for line in follow('Data/stocklog.csv'): print(line, end='') ... Deber\u00edas ver l\u00edneas de salida generadas aqu\u00ed... Modifica el c\u00f3digo del ticker de acciones para que se vea as\u00ed: if __name__ == '__main__': for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Ejercicio 6.7: Observando tu cartera Modifica el programa follow.py para que observe el flujo de datos de acciones e imprime un ticker que muestra informaci\u00f3n solo de las acciones en una cartera. Por ejemplo: if __name__ == '__main__': import report portfolio = report.read_portfolio('Data/portfolio.csv') for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if name in portfolio: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Nota: Para que esto funcione, su clase Portfolio debe admitir el operador in . Consulte el Ejercicio 6.3 y aseg\u00farese de implementar el operador __contains__() . Discusi\u00f3n Aqu\u00ed acaba de ocurrir algo muy poderoso. Has trasladado un patr\u00f3n de iteraci\u00f3n interesante (leer l\u00edneas al final de un archivo) a su propia peque\u00f1a funci\u00f3n. La funci\u00f3n follow() es ahora una utilidad de prop\u00f3sito completamente general que puede utilizar en cualquier programa. Por ejemplo, puede utilizarla para ver registros de servidores, registros de depuraci\u00f3n y otras fuentes de datos similares. Eso es genial. Contenido | Anterior (6.1 Protocolo de iteraci\u00f3n) | Pr\u00f3ximo (6.3 Problemas y flujos de trabajo de productores y consumidores)","title":"02_Customizing_iteration"},{"location":"06_Generators/02_Customizing_iteration/#62-personalizacion-de-la-iteracion","text":"Esta secci\u00f3n analiza c\u00f3mo se puede personalizar la iteraci\u00f3n utilizando una funci\u00f3n generadora.","title":"6.2 Personalizaci\u00f3n de la iteraci\u00f3n"},{"location":"06_Generators/02_Customizing_iteration/#un-problema","text":"Supongamos que desea crear su propio patr\u00f3n de iteraci\u00f3n personalizado. Por ejemplo, una cuenta regresiva. >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Hay una manera f\u00e1cil de hacer esto.","title":"Un problema"},{"location":"06_Generators/02_Customizing_iteration/#generadores","text":"Un generador es una funci\u00f3n que define la iteraci\u00f3n. def countdown(n): while n > 0: yield n n -= 1 Por ejemplo: >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que utiliza la declaraci\u00f3n yield . El comportamiento de los generadores es diferente al de una funci\u00f3n normal. Al llamar a una funci\u00f3n de generador se crea un objeto generador. No se ejecuta inmediatamente la funci\u00f3n. def countdown(n): # Se agreg\u00f3 una declaraci\u00f3n de impresi\u00f3n print('Cuenta regresiva desde', n) while n > 0: yield n n -= 1 >>> x = countdown(10) # NO HAY DECLARACI\u00d3N DE IMPRESI\u00d3N >>> x # x es un objeto generador <generator object countdown at 0x0000028C7FDB9FF0> >>> La funci\u00f3n solo se ejecuta en la llamada __next__() . >>> x = countdown(10) >>> x <generator object countdown at 0x0000028C7FDB9FF0> >>> x.__next__() Cuenta regresiva desde 10 10 >>> yield produce un valor, pero suspende la ejecuci\u00f3n de la funci\u00f3n. La funci\u00f3n se reanuda en la siguiente llamada a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando el generador finalmente retorna, la iteraci\u00f3n genera un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que las instrucciones for usan en listas, tuplas, diccionarios, archivos, etc.","title":"Generadores"},{"location":"06_Generators/02_Customizing_iteration/#ejercicios","text":"","title":"Ejercicios"},{"location":"06_Generators/02_Customizing_iteration/#ejercicio-64-un-generador-simple","text":"Si alguna vez te encuentras con ganas de personalizar la iteraci\u00f3n, siempre debes pensar en funciones generadoras. Son f\u00e1ciles de escribir: crea una funci\u00f3n que lleve a cabo la l\u00f3gica de iteraci\u00f3n deseada y usa yield para emitir valores. Por ejemplo, prueba este generador que busca en un archivo l\u00edneas que contengan una subcadena coincidente: >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('Data/portfolio.csv'): print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> for line in filematch('Data/portfolio.csv', 'IBM'): print(line, end='') \"IBM\",50,91.10 \"IBM\",100,70.44 >>> Esto es bastante interesante: la idea de que se puede ocultar un mont\u00f3n de procesamiento personalizado en una funci\u00f3n y utilizarlo para alimentar un bucle for . El siguiente ejemplo analiza un caso m\u00e1s inusual.","title":"Ejercicio 6.4: Un generador simple"},{"location":"06_Generators/02_Customizing_iteration/#ejercicio-65-monitoreo-de-una-fuente-de-datos-en-tiempo-real","text":"Los generadores pueden ser una forma interesante de monitorear fuentes de datos en tiempo real, como archivos de registro o feeds del mercado de valores. En esta parte, exploraremos esta idea. Para comenzar, siga atentamente las siguientes instrucciones. El programa Data/stocksim.py es un programa que simula datos del mercado de valores. Como salida, el programa escribe constantemente datos en tiempo real en un archivo Data/stocklog.csv . En una ventana de comandos independiente, vaya al directorio Data/ y ejecute este programa: bash % python3 stocksim.py Si est\u00e1 en Windows, simplemente busque el programa stocksim.py y haga doble clic en \u00e9l para ejecutarlo. Ahora, olv\u00eddese de este programa (simplemente d\u00e9jelo ejecutar). En otra ventana, observe el archivo Data/stocklog.csv que est\u00e1 escribiendo el simulador. Deber\u00eda ver nuevas l\u00edneas de texto que se agregan al archivo cada pocos segundos. Nuevamente, simplemente deje que este programa se ejecute en segundo plano; se ejecutar\u00e1 durante varias horas (no deber\u00eda tener que preocuparse por eso). Una vez que se est\u00e9 ejecutando el programa anterior, escribamos un peque\u00f1o programa para abrir el archivo, buscar hasta el final y observar si hay un nuevo resultado. Cree un archivo follow.py y pon este c\u00f3digo en \u00e9l: # follow.py import os import time f = open('Data/stocklog.csv') f.seek(0, os.SEEK_END) # Mueve el puntero del archivo 0 bytes desde el final del archivo while True: line = f.readline() if line == '': time.sleep(0.1) # Duerme brevemente y vuelve a intentar continue fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Si ejecutas el programa, ver\u00e1s un indicador de cotizaci\u00f3n de acciones en tiempo real. Debajo del cap\u00f3, Este c\u00f3digo es similar al comando tail -f de Unix que se usa para ver un archivo de registro. Nota: El uso del m\u00e9todo readline() en este ejemplo es algo inusual, ya que no es la forma habitual de leer l\u00edneas de un archivo (normalmente, solo se usar\u00eda un bucle for ). Sin embargo, en este caso, lo estamos usando para sondear repetidamente el final del archivo para ver si se han agregado m\u00e1s datos ( readline() devolver\u00e1 datos nuevos o una cadena vac\u00eda).","title":"Ejercicio 6.5: Monitoreo de una fuente de datos en tiempo real"},{"location":"06_Generators/02_Customizing_iteration/#ejercicio-66-uso-de-un-generador-para-producir-datos","text":"Si observa el c\u00f3digo del Ejercicio 6.5, la primera parte del c\u00f3digo produce l\u00edneas de datos, mientras que las instrucciones al final del bucle while consumen los datos. Una caracter\u00edstica importante de las funciones generadoras es que puede mover todo el c\u00f3digo de producci\u00f3n de datos a una funci\u00f3n reutilizable. Modifique el c\u00f3digo del Ejercicio 6.5 para que la lectura del archivo la realice una funci\u00f3n generadora follow(filename) . Haz que funcione el siguiente c\u00f3digo: >>> for line in follow('Data/stocklog.csv'): print(line, end='') ... Deber\u00edas ver l\u00edneas de salida generadas aqu\u00ed... Modifica el c\u00f3digo del ticker de acciones para que se vea as\u00ed: if __name__ == '__main__': for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')","title":"Ejercicio 6.6: Uso de un generador para producir datos"},{"location":"06_Generators/02_Customizing_iteration/#ejercicio-67-observando-tu-cartera","text":"Modifica el programa follow.py para que observe el flujo de datos de acciones e imprime un ticker que muestra informaci\u00f3n solo de las acciones en una cartera. Por ejemplo: if __name__ == '__main__': import report portfolio = report.read_portfolio('Data/portfolio.csv') for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if name in portfolio: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Nota: Para que esto funcione, su clase Portfolio debe admitir el operador in . Consulte el Ejercicio 6.3 y aseg\u00farese de implementar el operador __contains__() .","title":"Ejercicio 6.7: Observando tu cartera"},{"location":"06_Generators/02_Customizing_iteration/#discusion","text":"Aqu\u00ed acaba de ocurrir algo muy poderoso. Has trasladado un patr\u00f3n de iteraci\u00f3n interesante (leer l\u00edneas al final de un archivo) a su propia peque\u00f1a funci\u00f3n. La funci\u00f3n follow() es ahora una utilidad de prop\u00f3sito completamente general que puede utilizar en cualquier programa. Por ejemplo, puede utilizarla para ver registros de servidores, registros de depuraci\u00f3n y otras fuentes de datos similares. Eso es genial. Contenido | Anterior (6.1 Protocolo de iteraci\u00f3n) | Pr\u00f3ximo (6.3 Problemas y flujos de trabajo de productores y consumidores)","title":"Discusi\u00f3n"},{"location":"06_Generators/03_Producers_consumers/","text":"Contenido | Anterior (6.2 Personalizaci\u00f3n de la iteraci\u00f3n) | Pr\u00f3ximo (6.4 Expresiones generadoras) 6.3 Problemas y flujos de trabajo de productores y consumidores Los generadores son una herramienta \u00fatil para configurar varios tipos de problemas de productor/consumidor y las tuber\u00edas de flujo de datos. Esta secci\u00f3n trata sobre eso. Problemas de productor-consumidor Los generadores est\u00e1n estrechamente relacionados con varias formas de problemas de productor-consumidor . # Productor def follow(f): ... while True: ... yield line # Produce el valor en `line` a continuaci\u00f3n ... # Consumidor for line in follow(f): # Consume el valor de `yield` arriba ... yield produce valores que for consume. Tuberias de generadores Puede utilizar este aspecto de los generadores para configurar tuber\u00edas de procesamiento (como las tuber\u00edas de Unix). productor => procesamiento => procesamiento => consumidor Las tuber\u00edas de procesamiento tienen un productor de datos inicial, un conjunto de etapas de procesamiento intermedias y un consumidor final. productor => procesamiento => procesamiento => consumidor def productor(): ... yield item ... El productor es normalmente un generador. Aunque tambi\u00e9n podr\u00eda ser una lista de alguna otra secuencia. yield introduce datos en la tuber\u00eda. productor => procesamiento => procesamiento => consumidor def consumidor(s): for item in s: ... El consumidor es un bucle for . Obtiene elementos y hace algo con ellos. productor => procesamiento => procesamiento => consumidor def procesamiento(s): for item in s: ... yield newitem ... Las etapas de procesamiento intermedias consumen y producen elementos simult\u00e1neamente. Pueden modificar el flujo de datos. Tambi\u00e9n pueden filtrar (descartando elementos). productor => procesamiento => procesamiento => consumer def productor(): ... yield item # produce el elemento que recibe de `procesamiento` ... def procesamiento(s): for item in s: # Proviene del `productor` ... yield newitem # produce un nuevo elemento ... def consumidor(s): for item in s: # Proviene del `procesamiento` ... C\u00f3digo para configurar la canalizaci\u00f3n a = productor() b = procesamiento(a) c = consumidor(b) Notar\u00e1s que los datos fluyen de manera incremental a trav\u00e9s de las diferentes funciones. Ejercicios Para este ejercicio, el programa stocksim.py debe seguir ejecut\u00e1ndose en segundo plano. Vas a utilizar la funci\u00f3n follow() que escribiste en el ejercicio anterior. Ejercicio 6.8: Configuraci\u00f3n de una tuber\u00eda simple Veamos la idea de la tuber\u00eda en acci\u00f3n. Escriba la siguiente funci\u00f3n: >>> def filematch(lines, substr): ... for line in lines: ... if substr in line: ... yield line ... >>> Esta funci\u00f3n es casi exactamente la misma que el primer ejemplo de generador del ejercicio anterior, excepto que ya no abre un archivo, sino que simplemente opera sobre una secuencia de l\u00edneas que se le proporciona como argumento. Ahora, pruebe esto: >>> from follow import follow >>> lines = follow('Data/stocklog.csv') >>> ibm = filematch(lines, 'IBM') >>> for line in ibm: print(line) ... espere la salida ... Puede que la salida tarde un poco en aparecer, pero con el tiempo deber\u00eda ver algunas l\u00edneas que contienen datos de IBM. Ejercicio 6.9: Configuraci\u00f3n de una secuencia de comandos m\u00e1s compleja Lleve la idea de la secuencia de comandos un poco m\u00e1s all\u00e1 realizando m\u00e1s acciones. >>> from follow import follow >>> import csv >>> lines = follow('Data/stocklog.csv') >>> rows = csv.reader(lines) >>> for row in rows: print(row) ['BA', '98.35', '6/11/2007', '09:41.07', '0.16', '98.25', '98.35', '98.31', '158148'] ['AA', '39.63', '6/11/2007', '09:41.07', '-0.03', '39.67', '39.63', '39.31', '270224'] ['XOM', '82.45', '6/11/2007', '09:41.07', '-0.23', '82.68', '82.64', '82.41', '748062'] ['PG', '62.95', '6/11/2007', '09:41.08', '-0.12', '62.80', '62.97', '62.61', '454327'] Bueno, eso es interesante. Lo que est\u00e1s viendo aqu\u00ed es que la salida de la funci\u00f3n follow() se ha canalizado a la funci\u00f3n csv.reader() y ahora estamos obteniendo una secuencia de filas divididas. Ejercicio 6.10: Creaci\u00f3n de m\u00e1s componentes de tuber\u00eda Extendamos toda la idea a una canalizaci\u00f3n m\u00e1s grande. En un archivo separado ticker.py , comience por crear una funci\u00f3n que lea un archivo CSV como lo hizo anteriormente: # ticker.py from follow import follow import csv def parse_stock_data(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = follow('Data/stocklog.csv') rows = parse_stock_data(lines) for row in rows: print(row) Escriba una nueva funci\u00f3n que seleccione columnas espec\u00edficas: # ticker.py ... def select_columns(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) return rows Ejecute su programa nuevamente. Deber\u00eda ver la salida acotada de esta manera: ['BA', '98.35', '0.16'] ['AA', '39.63', '-0.03'] ['XOM', '82.45', '-0.23'] ['PG', '62.95', '-0.12'] ... Escriba funciones generadoras que conviertan tipos de datos y creen diccionarios. Por ejemplo: # ticker.py ... def convert_types(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def make_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) rows = convert_types(rows, [str, float, float]) rows = make_dicts(rows, ['name', 'price', 'change']) return rows ... Ejecute su programa nuevamente. Ahora deber\u00eda aparecer un flujo de diccionarios como este: { 'name':'BA', 'price':98.35, 'change':0.16 } { 'name':'AA', 'price':39.63, 'change':-0.03 } { 'name':'XOM', 'price':82.45, 'change': -0.23 } { 'name':'PG', 'price':62.95, 'change':-0.12 } ... Ejercicio 6.11: Filtrado de datos Escribe una funci\u00f3n que filtre datos. Por ejemplo: # ticker.py ... def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Use esto para filtrar acciones y seleccionar solo las que est\u00e1n en su cartera: import report portfolio = report.read_portfolio('Data/portfolio.csv') rows = parse_stock_data(follow('Data/stocklog.csv')) rows = filter_symbols(rows, portfolio) for row in rows: print(row) Ejercicio 6.12: Poni\u00e9ndolo todo junto En el programa ticker.py , escriba una funci\u00f3n ticker(portfile, logfile, fmt) que cree un ticker de acciones en tiempo real a partir de una cartera, un archivo de registro y un formato de tabla determinados. Por ejemplo:: >>> from ticker import ticker >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'txt') Name Price Change ---------- ---------- ---------- GE 37.14 -0.18 MSFT 29.96 -0.09 CAT 78.03 -0.49 AA 39.34 -0.32 ... >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'csv') Name,Price,Change IBM,102.79,-0.28 CAT,78.04,-0.48 AA,39.35,-0.31 CAT,78.05,-0.47 ... Discusi\u00f3n Algunas lecciones aprendidas: Puede crear varias funciones generadoras y encadenarlas para realizar un procesamiento que involucre flujos de datos. Adem\u00e1s, puede crear funciones que empaqueten una serie de etapas de flujos de datos en una \u00fanica llamada a la funci\u00f3n (por ejemplo, la funci\u00f3n parse_stock_data() ). Contenido | Anterior (6.2 Personalizaci\u00f3n de la iteraci\u00f3n) | Pr\u00f3ximo (6.4 Expresiones generadoras)","title":"03_Producers_consumers"},{"location":"06_Generators/03_Producers_consumers/#63-problemas-y-flujos-de-trabajo-de-productores-y-consumidores","text":"Los generadores son una herramienta \u00fatil para configurar varios tipos de problemas de productor/consumidor y las tuber\u00edas de flujo de datos. Esta secci\u00f3n trata sobre eso.","title":"6.3 Problemas y flujos de trabajo de productores y consumidores"},{"location":"06_Generators/03_Producers_consumers/#problemas-de-productor-consumidor","text":"Los generadores est\u00e1n estrechamente relacionados con varias formas de problemas de productor-consumidor . # Productor def follow(f): ... while True: ... yield line # Produce el valor en `line` a continuaci\u00f3n ... # Consumidor for line in follow(f): # Consume el valor de `yield` arriba ... yield produce valores que for consume.","title":"Problemas de productor-consumidor"},{"location":"06_Generators/03_Producers_consumers/#tuberias-de-generadores","text":"Puede utilizar este aspecto de los generadores para configurar tuber\u00edas de procesamiento (como las tuber\u00edas de Unix). productor => procesamiento => procesamiento => consumidor Las tuber\u00edas de procesamiento tienen un productor de datos inicial, un conjunto de etapas de procesamiento intermedias y un consumidor final. productor => procesamiento => procesamiento => consumidor def productor(): ... yield item ... El productor es normalmente un generador. Aunque tambi\u00e9n podr\u00eda ser una lista de alguna otra secuencia. yield introduce datos en la tuber\u00eda. productor => procesamiento => procesamiento => consumidor def consumidor(s): for item in s: ... El consumidor es un bucle for . Obtiene elementos y hace algo con ellos. productor => procesamiento => procesamiento => consumidor def procesamiento(s): for item in s: ... yield newitem ... Las etapas de procesamiento intermedias consumen y producen elementos simult\u00e1neamente. Pueden modificar el flujo de datos. Tambi\u00e9n pueden filtrar (descartando elementos). productor => procesamiento => procesamiento => consumer def productor(): ... yield item # produce el elemento que recibe de `procesamiento` ... def procesamiento(s): for item in s: # Proviene del `productor` ... yield newitem # produce un nuevo elemento ... def consumidor(s): for item in s: # Proviene del `procesamiento` ... C\u00f3digo para configurar la canalizaci\u00f3n a = productor() b = procesamiento(a) c = consumidor(b) Notar\u00e1s que los datos fluyen de manera incremental a trav\u00e9s de las diferentes funciones.","title":"Tuberias de generadores"},{"location":"06_Generators/03_Producers_consumers/#ejercicios","text":"Para este ejercicio, el programa stocksim.py debe seguir ejecut\u00e1ndose en segundo plano. Vas a utilizar la funci\u00f3n follow() que escribiste en el ejercicio anterior.","title":"Ejercicios"},{"location":"06_Generators/03_Producers_consumers/#ejercicio-68-configuracion-de-una-tuberia-simple","text":"Veamos la idea de la tuber\u00eda en acci\u00f3n. Escriba la siguiente funci\u00f3n: >>> def filematch(lines, substr): ... for line in lines: ... if substr in line: ... yield line ... >>> Esta funci\u00f3n es casi exactamente la misma que el primer ejemplo de generador del ejercicio anterior, excepto que ya no abre un archivo, sino que simplemente opera sobre una secuencia de l\u00edneas que se le proporciona como argumento. Ahora, pruebe esto: >>> from follow import follow >>> lines = follow('Data/stocklog.csv') >>> ibm = filematch(lines, 'IBM') >>> for line in ibm: print(line) ... espere la salida ... Puede que la salida tarde un poco en aparecer, pero con el tiempo deber\u00eda ver algunas l\u00edneas que contienen datos de IBM.","title":"Ejercicio 6.8: Configuraci\u00f3n de una tuber\u00eda simple"},{"location":"06_Generators/03_Producers_consumers/#ejercicio-69-configuracion-de-una-secuencia-de-comandos-mas-compleja","text":"Lleve la idea de la secuencia de comandos un poco m\u00e1s all\u00e1 realizando m\u00e1s acciones. >>> from follow import follow >>> import csv >>> lines = follow('Data/stocklog.csv') >>> rows = csv.reader(lines) >>> for row in rows: print(row) ['BA', '98.35', '6/11/2007', '09:41.07', '0.16', '98.25', '98.35', '98.31', '158148'] ['AA', '39.63', '6/11/2007', '09:41.07', '-0.03', '39.67', '39.63', '39.31', '270224'] ['XOM', '82.45', '6/11/2007', '09:41.07', '-0.23', '82.68', '82.64', '82.41', '748062'] ['PG', '62.95', '6/11/2007', '09:41.08', '-0.12', '62.80', '62.97', '62.61', '454327'] Bueno, eso es interesante. Lo que est\u00e1s viendo aqu\u00ed es que la salida de la funci\u00f3n follow() se ha canalizado a la funci\u00f3n csv.reader() y ahora estamos obteniendo una secuencia de filas divididas.","title":"Ejercicio 6.9: Configuraci\u00f3n de una secuencia de comandos m\u00e1s compleja"},{"location":"06_Generators/03_Producers_consumers/#ejercicio-610-creacion-de-mas-componentes-de-tuberia","text":"Extendamos toda la idea a una canalizaci\u00f3n m\u00e1s grande. En un archivo separado ticker.py , comience por crear una funci\u00f3n que lea un archivo CSV como lo hizo anteriormente: # ticker.py from follow import follow import csv def parse_stock_data(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = follow('Data/stocklog.csv') rows = parse_stock_data(lines) for row in rows: print(row) Escriba una nueva funci\u00f3n que seleccione columnas espec\u00edficas: # ticker.py ... def select_columns(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) return rows Ejecute su programa nuevamente. Deber\u00eda ver la salida acotada de esta manera: ['BA', '98.35', '0.16'] ['AA', '39.63', '-0.03'] ['XOM', '82.45', '-0.23'] ['PG', '62.95', '-0.12'] ... Escriba funciones generadoras que conviertan tipos de datos y creen diccionarios. Por ejemplo: # ticker.py ... def convert_types(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def make_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) rows = convert_types(rows, [str, float, float]) rows = make_dicts(rows, ['name', 'price', 'change']) return rows ... Ejecute su programa nuevamente. Ahora deber\u00eda aparecer un flujo de diccionarios como este: { 'name':'BA', 'price':98.35, 'change':0.16 } { 'name':'AA', 'price':39.63, 'change':-0.03 } { 'name':'XOM', 'price':82.45, 'change': -0.23 } { 'name':'PG', 'price':62.95, 'change':-0.12 } ...","title":"Ejercicio 6.10: Creaci\u00f3n de m\u00e1s componentes de tuber\u00eda"},{"location":"06_Generators/03_Producers_consumers/#ejercicio-611-filtrado-de-datos","text":"Escribe una funci\u00f3n que filtre datos. Por ejemplo: # ticker.py ... def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Use esto para filtrar acciones y seleccionar solo las que est\u00e1n en su cartera: import report portfolio = report.read_portfolio('Data/portfolio.csv') rows = parse_stock_data(follow('Data/stocklog.csv')) rows = filter_symbols(rows, portfolio) for row in rows: print(row)","title":"Ejercicio 6.11: Filtrado de datos"},{"location":"06_Generators/03_Producers_consumers/#ejercicio-612-poniendolo-todo-junto","text":"En el programa ticker.py , escriba una funci\u00f3n ticker(portfile, logfile, fmt) que cree un ticker de acciones en tiempo real a partir de una cartera, un archivo de registro y un formato de tabla determinados. Por ejemplo:: >>> from ticker import ticker >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'txt') Name Price Change ---------- ---------- ---------- GE 37.14 -0.18 MSFT 29.96 -0.09 CAT 78.03 -0.49 AA 39.34 -0.32 ... >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'csv') Name,Price,Change IBM,102.79,-0.28 CAT,78.04,-0.48 AA,39.35,-0.31 CAT,78.05,-0.47 ...","title":"Ejercicio 6.12: Poni\u00e9ndolo todo junto"},{"location":"06_Generators/03_Producers_consumers/#discusion","text":"Algunas lecciones aprendidas: Puede crear varias funciones generadoras y encadenarlas para realizar un procesamiento que involucre flujos de datos. Adem\u00e1s, puede crear funciones que empaqueten una serie de etapas de flujos de datos en una \u00fanica llamada a la funci\u00f3n (por ejemplo, la funci\u00f3n parse_stock_data() ). Contenido | Anterior (6.2 Personalizaci\u00f3n de la iteraci\u00f3n) | Pr\u00f3ximo (6.4 Expresiones generadoras)","title":"Discusi\u00f3n"},{"location":"06_Generators/04_More_generators/","text":"Contenido | Anterior (6.3 Problemas y flujos de trabajo de productores y consumidores) | Pr\u00f3ximo (7. Algunos temas avanzados) 6.4 M\u00e1s generadores Esta secci\u00f3n presenta algunos temas adicionales relacionados con los generadores, incluidas las expresiones de generador y el m\u00f3dulo itertools . Expresiones generadoras Una versi\u00f3n de generador de una lista por comprensi\u00f3n. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> Diferencias con las listas por comprensi\u00f3n. No construye una lista. El \u00fanico prop\u00f3sito \u00fatil es la iteraci\u00f3n. Una vez consumido, no se puede reutilizar. Sintaxis general. (<expresi\u00f3n> for i in s if <condicional>) Tambi\u00e9n puede servir como argumento de funci\u00f3n. sum(x*x for x in a) Se puede aplicar a cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones de generador es en c\u00f3digo que realiza alg\u00fan c\u00e1lculo en una secuencia, pero solo usa el resultado una vez. Por ejemplo, eliminar todos los comentarios de un archivo. f = open('somefile.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Con los generadores, el c\u00f3digo se ejecuta m\u00e1s r\u00e1pido y usa menos memoria. Es como un filtro aplicado a una secuencia. Por qu\u00e9 generadores Muchos problemas se expresan mucho m\u00e1s claramente en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de elementos y realizar alg\u00fan tipo de operaci\u00f3n (buscar, reemplazar, modificar, etc.). Las tuberias de procesamiento se pueden aplicar a una amplia gama de problemas de procesamiento de datos. Mejor eficiencia de la memoria. Solo se producen valores cuando es necesario. Contrasta con la construcci\u00f3n de listas gigantes. Puede operar en datos en tiempo real. Los generadores fomentan la reutilizaci\u00f3n de c\u00f3digo. Separa la iteraci\u00f3n del c\u00f3digo que utiliza la iteraci\u00f3n. Puede crear una caja de herramientas de funciones de iteraci\u00f3n interesantes y mezclar y combinar . M\u00f3dulo itertools itertools es un m\u00f3dulo de biblioteca con varias funciones dise\u00f1adas para ayudar con los iteradores/generadores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas las funciones procesan datos de forma iterativa. Implementan varios tipos de patrones de interaci\u00f3n. M\u00e1s informaci\u00f3n en el tutorial Generator Tricks for Systems Programmers de PyCon '08. Ejercicios En los ejercicios anteriores, escribi\u00f3 un c\u00f3digo que segu\u00eda las l\u00edneas que se escrib\u00edan en un archivo de registro y las analiz\u00f3 en una secuencia de filas. Este ejercicio contin\u00faa bas\u00e1ndose en eso. Aseg\u00farese de que Data/stocksim.py todav\u00eda se est\u00e9 ejecutando. Ejercicio 6.13: Expresiones generadoras Las expresiones generadoras son una versi\u00f3n generadora de una comprensi\u00f3n de lista. Por ejemplo: >>> nums = [1, 2, 3, 4, 5] >>> squares = (x*x for x in nums) >>> squares <generator object <genexpr> at 0x109207e60> >>> for n in squares: ... print(n) ... 1 4 9 16 25 A diferencia de una lista por comprensi\u00f3n, una expresi\u00f3n generadora solo se puede usar una vez. Por lo tanto, si intentas otro bucle for, no obtienes nada: >>> for n in squares: ... print(n) ... >>> Ejercicio 6.14: Expresiones generadoras en argumentos de funci\u00f3n A veces, las expresiones generadoras se colocan en los argumentos de funci\u00f3n. Parece un poco extra\u00f1o al principio, pero prueba este experimento: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # Una comprensi\u00f3n de lista 55 >>> sum(x*x for x in nums) # Una expresi\u00f3n generadora 55 >>> En el ejemplo anterior, la segunda versi\u00f3n que usa generadores utilizar\u00eda significativamente menos memoria si se manipulara una lista grande. En tu archivo portfolio.py , realizaste algunos c\u00e1lculos que involucraban comprensiones de lista. Intente reemplazarlas con expresiones generadoras. Ejercicio 6.15: Simplificaci\u00f3n de c\u00f3digo Las expresiones generadoras suelen ser un reemplazo \u00fatil para funciones generadoras peque\u00f1as. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Podr\u00eda escribir algo como esto: rows = (row for row in rows if row['name'] in names) Modifique el programa ticker.py para usar expresiones generadoras seg\u00fan corresponda. Contenido | Anterior (6.3 Problemas y flujos de trabajo de productores y consumidores) | Pr\u00f3ximo (7. Algunos temas avanzados)","title":"04_More_generators"},{"location":"06_Generators/04_More_generators/#64-mas-generadores","text":"Esta secci\u00f3n presenta algunos temas adicionales relacionados con los generadores, incluidas las expresiones de generador y el m\u00f3dulo itertools .","title":"6.4 M\u00e1s generadores"},{"location":"06_Generators/04_More_generators/#expresiones-generadoras","text":"Una versi\u00f3n de generador de una lista por comprensi\u00f3n. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> Diferencias con las listas por comprensi\u00f3n. No construye una lista. El \u00fanico prop\u00f3sito \u00fatil es la iteraci\u00f3n. Una vez consumido, no se puede reutilizar. Sintaxis general. (<expresi\u00f3n> for i in s if <condicional>) Tambi\u00e9n puede servir como argumento de funci\u00f3n. sum(x*x for x in a) Se puede aplicar a cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones de generador es en c\u00f3digo que realiza alg\u00fan c\u00e1lculo en una secuencia, pero solo usa el resultado una vez. Por ejemplo, eliminar todos los comentarios de un archivo. f = open('somefile.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Con los generadores, el c\u00f3digo se ejecuta m\u00e1s r\u00e1pido y usa menos memoria. Es como un filtro aplicado a una secuencia.","title":"Expresiones generadoras"},{"location":"06_Generators/04_More_generators/#por-que-generadores","text":"Muchos problemas se expresan mucho m\u00e1s claramente en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de elementos y realizar alg\u00fan tipo de operaci\u00f3n (buscar, reemplazar, modificar, etc.). Las tuberias de procesamiento se pueden aplicar a una amplia gama de problemas de procesamiento de datos. Mejor eficiencia de la memoria. Solo se producen valores cuando es necesario. Contrasta con la construcci\u00f3n de listas gigantes. Puede operar en datos en tiempo real. Los generadores fomentan la reutilizaci\u00f3n de c\u00f3digo. Separa la iteraci\u00f3n del c\u00f3digo que utiliza la iteraci\u00f3n. Puede crear una caja de herramientas de funciones de iteraci\u00f3n interesantes y mezclar y combinar .","title":"Por qu\u00e9 generadores"},{"location":"06_Generators/04_More_generators/#modulo-itertools","text":"itertools es un m\u00f3dulo de biblioteca con varias funciones dise\u00f1adas para ayudar con los iteradores/generadores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas las funciones procesan datos de forma iterativa. Implementan varios tipos de patrones de interaci\u00f3n. M\u00e1s informaci\u00f3n en el tutorial Generator Tricks for Systems Programmers de PyCon '08.","title":"M\u00f3dulo itertools"},{"location":"06_Generators/04_More_generators/#ejercicios","text":"En los ejercicios anteriores, escribi\u00f3 un c\u00f3digo que segu\u00eda las l\u00edneas que se escrib\u00edan en un archivo de registro y las analiz\u00f3 en una secuencia de filas. Este ejercicio contin\u00faa bas\u00e1ndose en eso. Aseg\u00farese de que Data/stocksim.py todav\u00eda se est\u00e9 ejecutando.","title":"Ejercicios"},{"location":"06_Generators/04_More_generators/#ejercicio-613-expresiones-generadoras","text":"Las expresiones generadoras son una versi\u00f3n generadora de una comprensi\u00f3n de lista. Por ejemplo: >>> nums = [1, 2, 3, 4, 5] >>> squares = (x*x for x in nums) >>> squares <generator object <genexpr> at 0x109207e60> >>> for n in squares: ... print(n) ... 1 4 9 16 25 A diferencia de una lista por comprensi\u00f3n, una expresi\u00f3n generadora solo se puede usar una vez. Por lo tanto, si intentas otro bucle for, no obtienes nada: >>> for n in squares: ... print(n) ... >>>","title":"Ejercicio 6.13: Expresiones generadoras"},{"location":"06_Generators/04_More_generators/#ejercicio-614-expresiones-generadoras-en-argumentos-de-funcion","text":"A veces, las expresiones generadoras se colocan en los argumentos de funci\u00f3n. Parece un poco extra\u00f1o al principio, pero prueba este experimento: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # Una comprensi\u00f3n de lista 55 >>> sum(x*x for x in nums) # Una expresi\u00f3n generadora 55 >>> En el ejemplo anterior, la segunda versi\u00f3n que usa generadores utilizar\u00eda significativamente menos memoria si se manipulara una lista grande. En tu archivo portfolio.py , realizaste algunos c\u00e1lculos que involucraban comprensiones de lista. Intente reemplazarlas con expresiones generadoras.","title":"Ejercicio 6.14: Expresiones generadoras en argumentos de funci\u00f3n"},{"location":"06_Generators/04_More_generators/#ejercicio-615-simplificacion-de-codigo","text":"Las expresiones generadoras suelen ser un reemplazo \u00fatil para funciones generadoras peque\u00f1as. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Podr\u00eda escribir algo como esto: rows = (row for row in rows if row['name'] in names) Modifique el programa ticker.py para usar expresiones generadoras seg\u00fan corresponda. Contenido | Anterior (6.3 Problemas y flujos de trabajo de productores y consumidores) | Pr\u00f3ximo (7. Algunos temas avanzados)","title":"Ejercicio 6.15: Simplificaci\u00f3n de c\u00f3digo"},{"location":"07_Advanced_Topics/00_Overview/","text":"Contenido | Anterior (6 Generadores) | Pr\u00f3ximo (8. Pruebas, registro y depuraci\u00f3n) 7. Algunos temas avanzados En esta secci\u00f3n, analizamos un peque\u00f1o conjunto de caracter\u00edsticas de Python un poco m\u00e1s avanzadas que puede encontrar en su codificaci\u00f3n diaria. Muchos de estos temas podr\u00edan haberse tratado en secciones anteriores del curso, pero no lo hicimos para ahorrarle m\u00e1s dolores de cabeza en ese momento. Se debe enfatizar que los temas de esta secci\u00f3n solo est\u00e1n destinados a servir como una introducci\u00f3n muy b\u00e1sica a estas ideas. Deber\u00e1 buscar material m\u00e1s avanzado para completar los detalles. 7.1 Funciones con argumentos variables 7.2 Funciones an\u00f3nimas y lambda 7.3 Retornando Funciones y clousures 7.4 Decoradores de funciones 7.5 M\u00e9todos est\u00e1ticos y de clase Contenido | Anterior (6 Generadores) | Pr\u00f3ximo (8. Pruebas, registro y depuraci\u00f3n)","title":"00_Overview"},{"location":"07_Advanced_Topics/00_Overview/#7-algunos-temas-avanzados","text":"En esta secci\u00f3n, analizamos un peque\u00f1o conjunto de caracter\u00edsticas de Python un poco m\u00e1s avanzadas que puede encontrar en su codificaci\u00f3n diaria. Muchos de estos temas podr\u00edan haberse tratado en secciones anteriores del curso, pero no lo hicimos para ahorrarle m\u00e1s dolores de cabeza en ese momento. Se debe enfatizar que los temas de esta secci\u00f3n solo est\u00e1n destinados a servir como una introducci\u00f3n muy b\u00e1sica a estas ideas. Deber\u00e1 buscar material m\u00e1s avanzado para completar los detalles. 7.1 Funciones con argumentos variables 7.2 Funciones an\u00f3nimas y lambda 7.3 Retornando Funciones y clousures 7.4 Decoradores de funciones 7.5 M\u00e9todos est\u00e1ticos y de clase Contenido | Anterior (6 Generadores) | Pr\u00f3ximo (8. Pruebas, registro y depuraci\u00f3n)","title":"7. Algunos temas avanzados"},{"location":"07_Advanced_Topics/01_Variable_arguments/","text":"Contenido | Anterior (6.4 Expresiones generadoras) | Pr\u00f3ximo (7.2 Funciones an\u00f3nimas y lambda) 7.1 Argumentos variables Esta secci\u00f3n cubre argumentos de funciones variables, a veces descritos como \"*args\" y \"**kwargs\". Argumentos de variables posicionales ( *args ) Se dice que una funci\u00f3n que acepta cualquier n\u00famero de argumentos usa argumentos variables. Por ejemplo: def f(x, *args): ... Llamada de funci\u00f3n. f(1,2,3,4,5) Los argumentos adicionales se pasan como una tupla. def f(x, *args): # x -> 1 # args -> (2,3,4,5) Argumentos variables de palabra clave ( *kwargs ) Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos de palabra clave. Por ejemplo: def f(x, y, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Las palabras clave adicionales se pasan en un diccionario. def f(x, y, **kwargs): # x -> 2 # y -> 3 # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } Combinaci\u00f3n de ambos Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos variables, tanto de palabras clave como de palabras no clave. def f(*args, **kwargs): ... Llamada a la funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Los argumentos se separan en componentes posicionales y de palabras clave def f(*args, **kwargs): # args = (2, 3) # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } ... Esta funci\u00f3n acepta cualquier combinaci\u00f3n de argumentos posicionales o de palabras clave. A veces se utiliza al escribir contenedores o cuando se quieren pasar argumentos a otra funci\u00f3n. Pasar tuplas y diccionarios Las tuplas se pueden expandir en argumentos variables. numbers = (2,3,4) f(1, *numbers) # Igual que f(1,2,3,4) Los diccionarios tambi\u00e9n se pueden expandir a argumentos de palabras clave. options = { 'color' : 'red', 'delimiter' : ',', 'width' : 400 } f(data, **options) # Igual que f(data, color='red', delimiter=',', width=400) Ejercicios Ejercicio 7.1: Un ejemplo simple de argumentos variables Intenta definir la siguiente funci\u00f3n: >>> def avg(x,*more): return float(x+sum(more))/(1+len(more)) >>> avg(10,11) 10.5 >>> avg(3,4,5) 4.0 >>> avg(1,2,3,4,5,6) 3.5 >>> Observa c\u00f3mo el par\u00e1metro *more recopila todos los argumentos adicionales. Ejercicio 7.2: Pasar tuplas y diccionarios como argumentos Supongamos que lees algunos datos de un archivo y obtienes una tupla como esta: >>> data = ('GOOG', 100, 490.1) >>> Ahora, supongamos que quieres crear un objeto Stock a partir de estos datos. Si intentas pasar data directamente, no funciona: >>> from stock import Stock >>> s = Stock(data) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> Esto se soluciona f\u00e1cilmente utilizando *data en su lugar. Pruebe esto: >>> s = Stock(*data) >>> s Stock('GOOG', 100, 490.1) >>> Si tiene un diccionario, puede usar ** en su lugar. Por ejemplo: >>> data = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s = Stock(**data) Stock('GOOG', 100, 490.1) >>> Ejercicio 7.3: Creaci\u00f3n de una lista de instancias En su programa report.py , cre\u00f3 una lista de instancias utilizando un c\u00f3digo como este: def read_portfolio(filename): ''' Lea un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) Puede simplificar ese c\u00f3digo usando Stock(**d) en su lugar. Realice ese cambio. Ejercicio 7.4: Paso de argumentos La funci\u00f3n fileparse.parse_csv() tiene algunas opciones para cambiar el delimitador de archivo y para informar errores. Tal vez le gustar\u00eda exponer esas opciones a la funci\u00f3n read_portfolio() anterior. Realice este cambio: def read_portfolio(filename, **opts): ''' Lea un archivo de cartera de acciones en una lista de diccionarios con las claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) Una vez que haya realizado el cambio, intente leer un archivo con algunos errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv') Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> Ahora, intenta silenciar los errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv', silence_errors=True) >>> Contenido | Anterior (6.4 Expresiones generadoras) | Pr\u00f3ximo (7.2 Funciones an\u00f3nimas y lambda)","title":"01_Variable_arguments"},{"location":"07_Advanced_Topics/01_Variable_arguments/#71-argumentos-variables","text":"Esta secci\u00f3n cubre argumentos de funciones variables, a veces descritos como \"*args\" y \"**kwargs\".","title":"7.1 Argumentos variables"},{"location":"07_Advanced_Topics/01_Variable_arguments/#argumentos-de-variables-posicionales-args","text":"Se dice que una funci\u00f3n que acepta cualquier n\u00famero de argumentos usa argumentos variables. Por ejemplo: def f(x, *args): ... Llamada de funci\u00f3n. f(1,2,3,4,5) Los argumentos adicionales se pasan como una tupla. def f(x, *args): # x -> 1 # args -> (2,3,4,5)","title":"Argumentos de variables posicionales (*args)"},{"location":"07_Advanced_Topics/01_Variable_arguments/#argumentos-variables-de-palabra-clave-kwargs","text":"Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos de palabra clave. Por ejemplo: def f(x, y, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Las palabras clave adicionales se pasan en un diccionario. def f(x, y, **kwargs): # x -> 2 # y -> 3 # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' }","title":"Argumentos variables de palabra clave (*kwargs)"},{"location":"07_Advanced_Topics/01_Variable_arguments/#combinacion-de-ambos","text":"Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos variables, tanto de palabras clave como de palabras no clave. def f(*args, **kwargs): ... Llamada a la funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Los argumentos se separan en componentes posicionales y de palabras clave def f(*args, **kwargs): # args = (2, 3) # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } ... Esta funci\u00f3n acepta cualquier combinaci\u00f3n de argumentos posicionales o de palabras clave. A veces se utiliza al escribir contenedores o cuando se quieren pasar argumentos a otra funci\u00f3n.","title":"Combinaci\u00f3n de ambos"},{"location":"07_Advanced_Topics/01_Variable_arguments/#pasar-tuplas-y-diccionarios","text":"Las tuplas se pueden expandir en argumentos variables. numbers = (2,3,4) f(1, *numbers) # Igual que f(1,2,3,4) Los diccionarios tambi\u00e9n se pueden expandir a argumentos de palabras clave. options = { 'color' : 'red', 'delimiter' : ',', 'width' : 400 } f(data, **options) # Igual que f(data, color='red', delimiter=',', width=400)","title":"Pasar tuplas y diccionarios"},{"location":"07_Advanced_Topics/01_Variable_arguments/#ejercicios","text":"","title":"Ejercicios"},{"location":"07_Advanced_Topics/01_Variable_arguments/#ejercicio-71-un-ejemplo-simple-de-argumentos-variables","text":"Intenta definir la siguiente funci\u00f3n: >>> def avg(x,*more): return float(x+sum(more))/(1+len(more)) >>> avg(10,11) 10.5 >>> avg(3,4,5) 4.0 >>> avg(1,2,3,4,5,6) 3.5 >>> Observa c\u00f3mo el par\u00e1metro *more recopila todos los argumentos adicionales.","title":"Ejercicio 7.1: Un ejemplo simple de argumentos variables"},{"location":"07_Advanced_Topics/01_Variable_arguments/#ejercicio-72-pasar-tuplas-y-diccionarios-como-argumentos","text":"Supongamos que lees algunos datos de un archivo y obtienes una tupla como esta: >>> data = ('GOOG', 100, 490.1) >>> Ahora, supongamos que quieres crear un objeto Stock a partir de estos datos. Si intentas pasar data directamente, no funciona: >>> from stock import Stock >>> s = Stock(data) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> Esto se soluciona f\u00e1cilmente utilizando *data en su lugar. Pruebe esto: >>> s = Stock(*data) >>> s Stock('GOOG', 100, 490.1) >>> Si tiene un diccionario, puede usar ** en su lugar. Por ejemplo: >>> data = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s = Stock(**data) Stock('GOOG', 100, 490.1) >>>","title":"Ejercicio 7.2: Pasar tuplas y diccionarios como argumentos"},{"location":"07_Advanced_Topics/01_Variable_arguments/#ejercicio-73-creacion-de-una-lista-de-instancias","text":"En su programa report.py , cre\u00f3 una lista de instancias utilizando un c\u00f3digo como este: def read_portfolio(filename): ''' Lea un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) Puede simplificar ese c\u00f3digo usando Stock(**d) en su lugar. Realice ese cambio.","title":"Ejercicio 7.3: Creaci\u00f3n de una lista de instancias"},{"location":"07_Advanced_Topics/01_Variable_arguments/#ejercicio-74-paso-de-argumentos","text":"La funci\u00f3n fileparse.parse_csv() tiene algunas opciones para cambiar el delimitador de archivo y para informar errores. Tal vez le gustar\u00eda exponer esas opciones a la funci\u00f3n read_portfolio() anterior. Realice este cambio: def read_portfolio(filename, **opts): ''' Lea un archivo de cartera de acciones en una lista de diccionarios con las claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) Una vez que haya realizado el cambio, intente leer un archivo con algunos errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv') Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> Ahora, intenta silenciar los errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv', silence_errors=True) >>> Contenido | Anterior (6.4 Expresiones generadoras) | Pr\u00f3ximo (7.2 Funciones an\u00f3nimas y lambda)","title":"Ejercicio 7.4: Paso de argumentos"},{"location":"07_Advanced_Topics/02_Anonymous_function/","text":"Contenido | Anterior (7.1 Funciones con argumentos variables) | Pr\u00f3ximo (7.3 Retornando Funciones y clousures) 7.2 Funciones an\u00f3nimas y Lambda Revisi\u00f3n del ordenamiento de listas Las listas se pueden ordenar in situ . Utilizando el m\u00e9todo sort . s = [10,1,7,3] s.sort() # s = [1,3,7,10] Puede ordenar en orden inverso. s = [10,1,7,3] s.sort(reverse=True) # s = [10,7,3,1] Parece bastante simple. Sin embargo, \u00bfc\u00f3mo ordenamos una lista de diccionarios? [{'name': 'AA', 'price': 32,2, 'shares': 100}, {'name': 'IBM', 'price': 91,1, 'shares': 50}, {'name': 'CAT', 'price': 83,44, 'shares': 150}, {'name': 'MSFT', 'price': 51,23, 'shares': 200}, {'name': 'GE', 'price': 40,37, 'shares': 95}, {'name': 'MSFT', 'price': 65,1, 'shares': 50}, {'name': 'IBM', 'price': 70,44, 'shares': 100}] \u00bfCon qu\u00e9 criterios? Puede guiar la clasificaci\u00f3n mediante una funci\u00f3n clave . La funci\u00f3n clave es una funci\u00f3n que recibe el diccionario y devuelve el valor de inter\u00e9s para la clasificaci\u00f3n. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) A continuaci\u00f3n se muestra el resultado. # Verifica c\u00f3mo se ordenan los diccionarios por la clave `name` [ {'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'MSFT', 'price': 65.1, 'shares': 50} ] Funciones de devoluci\u00f3n de llamada En el ejemplo anterior, la funci\u00f3n clave es un ejemplo de una funci\u00f3n de devoluci\u00f3n de llamada. El m\u00e9todo sort() \"devuelve la llamada\" a una funci\u00f3n que usted proporciona. Las funciones de devoluci\u00f3n de llamada suelen ser funciones cortas de una sola l\u00ednea que solo se utilizan para esa operaci\u00f3n. Los programadores suelen pedir un atajo para especificar este procesamiento adicional. Lambda: Funciones an\u00f3nimas Utilice una lambda en lugar de crear la funci\u00f3n. En nuestro ejemplo de ordenaci\u00f3n anterior. portfolio.sort(key=lambda s: s['name']) Esto crea una funci\u00f3n sin nombre que eval\u00faa una \u00fanica expresi\u00f3n. El c\u00f3digo anterior es mucho m\u00e1s corto que el c\u00f3digo inicial. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) # vs lambda portfolio.sort(key=lambda s: s['name']) Uso de lambda Lambda est\u00e1 muy restringida. Solo se permite una \u00fanica expresi\u00f3n. No se permiten declaraciones como if , while , etc. El uso m\u00e1s com\u00fan es con funciones como sort() . Ejercicios Lea algunos datos de una cartera de acciones y convi\u00e9rtalos en una lista: >>> import report >>> portfolio = list(report.read_portfolio('Data/portfolio.csv')) >>> for s in portfolio: print(s) Stock('AA', 100, 32.2) Stock('IBM', 50, 91.1) Stock('CAT', 150, 83.44) Stock('MSFT', 200, 51.23) Stock('GE', 95, 40.37) Stock('MSFT', 50, 65.1) Stock('IBM', 100, 70.44) >>> Ejercicio 7.5: Ordenar por un campo Pruebe las siguientes instrucciones que ordenan la cartera datos ordenados alfab\u00e9ticamente por nombre de la acci\u00f3n. >>> def stock_name(s): return s.name >>> portfolio.sort(key=stock_name) >>> for s in portfolio: print(s) ... inspeccionar el resultado... >>> En esta parte, la funci\u00f3n stock_name() extrae el nombre de una acci\u00f3n de una sola entrada en la lista portfolio . sort() utiliza el resultado de esta funci\u00f3n para hacer la comparaci\u00f3n. Ejercicio 7.6: Ordenar por un campo con lambda Intenta ordenar la cartera seg\u00fan la cantidad de acciones usando una expresi\u00f3n lambda : >>> portfolio.sort(key=lambda s: s.shares) >>> for s in portfolio: print(s) ... inspeccionar el resultado ... >>> Intenta ordenar la cartera seg\u00fan el precio de cada acci\u00f3n >>> portfolio.sort(key=lambda s: s.price) >>> for s in portfolio: print(s) ... inspeccionar el resultado ... >>> Nota: lambda es un atajo \u00fatil porque te permite definir una funci\u00f3n de procesamiento especial directamente en la llamada a sort() en lugar de tener que definir una funci\u00f3n separada primero. Contenido | Anterior (7.1 Funciones con argumentos variables) | Pr\u00f3ximo (7.3 Retornando Funciones y clousures)","title":"02_Anonymous_function"},{"location":"07_Advanced_Topics/02_Anonymous_function/#72-funciones-anonimas-y-lambda","text":"","title":"7.2 Funciones an\u00f3nimas y Lambda"},{"location":"07_Advanced_Topics/02_Anonymous_function/#revision-del-ordenamiento-de-listas","text":"Las listas se pueden ordenar in situ . Utilizando el m\u00e9todo sort . s = [10,1,7,3] s.sort() # s = [1,3,7,10] Puede ordenar en orden inverso. s = [10,1,7,3] s.sort(reverse=True) # s = [10,7,3,1] Parece bastante simple. Sin embargo, \u00bfc\u00f3mo ordenamos una lista de diccionarios? [{'name': 'AA', 'price': 32,2, 'shares': 100}, {'name': 'IBM', 'price': 91,1, 'shares': 50}, {'name': 'CAT', 'price': 83,44, 'shares': 150}, {'name': 'MSFT', 'price': 51,23, 'shares': 200}, {'name': 'GE', 'price': 40,37, 'shares': 95}, {'name': 'MSFT', 'price': 65,1, 'shares': 50}, {'name': 'IBM', 'price': 70,44, 'shares': 100}] \u00bfCon qu\u00e9 criterios? Puede guiar la clasificaci\u00f3n mediante una funci\u00f3n clave . La funci\u00f3n clave es una funci\u00f3n que recibe el diccionario y devuelve el valor de inter\u00e9s para la clasificaci\u00f3n. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) A continuaci\u00f3n se muestra el resultado. # Verifica c\u00f3mo se ordenan los diccionarios por la clave `name` [ {'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'MSFT', 'price': 65.1, 'shares': 50} ]","title":"Revisi\u00f3n del ordenamiento de listas"},{"location":"07_Advanced_Topics/02_Anonymous_function/#funciones-de-devolucion-de-llamada","text":"En el ejemplo anterior, la funci\u00f3n clave es un ejemplo de una funci\u00f3n de devoluci\u00f3n de llamada. El m\u00e9todo sort() \"devuelve la llamada\" a una funci\u00f3n que usted proporciona. Las funciones de devoluci\u00f3n de llamada suelen ser funciones cortas de una sola l\u00ednea que solo se utilizan para esa operaci\u00f3n. Los programadores suelen pedir un atajo para especificar este procesamiento adicional.","title":"Funciones de devoluci\u00f3n de llamada"},{"location":"07_Advanced_Topics/02_Anonymous_function/#lambda-funciones-anonimas","text":"Utilice una lambda en lugar de crear la funci\u00f3n. En nuestro ejemplo de ordenaci\u00f3n anterior. portfolio.sort(key=lambda s: s['name']) Esto crea una funci\u00f3n sin nombre que eval\u00faa una \u00fanica expresi\u00f3n. El c\u00f3digo anterior es mucho m\u00e1s corto que el c\u00f3digo inicial. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) # vs lambda portfolio.sort(key=lambda s: s['name'])","title":"Lambda: Funciones an\u00f3nimas"},{"location":"07_Advanced_Topics/02_Anonymous_function/#uso-de-lambda","text":"Lambda est\u00e1 muy restringida. Solo se permite una \u00fanica expresi\u00f3n. No se permiten declaraciones como if , while , etc. El uso m\u00e1s com\u00fan es con funciones como sort() .","title":"Uso de lambda"},{"location":"07_Advanced_Topics/02_Anonymous_function/#ejercicios","text":"Lea algunos datos de una cartera de acciones y convi\u00e9rtalos en una lista: >>> import report >>> portfolio = list(report.read_portfolio('Data/portfolio.csv')) >>> for s in portfolio: print(s) Stock('AA', 100, 32.2) Stock('IBM', 50, 91.1) Stock('CAT', 150, 83.44) Stock('MSFT', 200, 51.23) Stock('GE', 95, 40.37) Stock('MSFT', 50, 65.1) Stock('IBM', 100, 70.44) >>>","title":"Ejercicios"},{"location":"07_Advanced_Topics/02_Anonymous_function/#ejercicio-75-ordenar-por-un-campo","text":"Pruebe las siguientes instrucciones que ordenan la cartera datos ordenados alfab\u00e9ticamente por nombre de la acci\u00f3n. >>> def stock_name(s): return s.name >>> portfolio.sort(key=stock_name) >>> for s in portfolio: print(s) ... inspeccionar el resultado... >>> En esta parte, la funci\u00f3n stock_name() extrae el nombre de una acci\u00f3n de una sola entrada en la lista portfolio . sort() utiliza el resultado de esta funci\u00f3n para hacer la comparaci\u00f3n.","title":"Ejercicio 7.5: Ordenar por un campo"},{"location":"07_Advanced_Topics/02_Anonymous_function/#ejercicio-76-ordenar-por-un-campo-con-lambda","text":"Intenta ordenar la cartera seg\u00fan la cantidad de acciones usando una expresi\u00f3n lambda : >>> portfolio.sort(key=lambda s: s.shares) >>> for s in portfolio: print(s) ... inspeccionar el resultado ... >>> Intenta ordenar la cartera seg\u00fan el precio de cada acci\u00f3n >>> portfolio.sort(key=lambda s: s.price) >>> for s in portfolio: print(s) ... inspeccionar el resultado ... >>> Nota: lambda es un atajo \u00fatil porque te permite definir una funci\u00f3n de procesamiento especial directamente en la llamada a sort() en lugar de tener que definir una funci\u00f3n separada primero. Contenido | Anterior (7.1 Funciones con argumentos variables) | Pr\u00f3ximo (7.3 Retornando Funciones y clousures)","title":"Ejercicio 7.6: Ordenar por un campo con lambda"},{"location":"07_Advanced_Topics/03_Returning_functions/","text":"Contenido | Anterior (7.2 Funciones an\u00f3nimas y lambda) | Pr\u00f3ximo (7.4 Decoradores de funciones) 7.3 Retornando Funciones y clousures Esta secci\u00f3n presenta la idea de usar funciones para crear otras funciones. Introducci\u00f3n Considere la siguiente funci\u00f3n. def add(x, y): def do_add(): print('Sumando', x, y) return x + y return do_add Esta es una funci\u00f3n que devuelve otra funci\u00f3n. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Sumando 3 4 7 Variables locales Observe c\u00f3mo la funci\u00f3n interna hace referencia a las variables definidas por la funci\u00f3n externa. def add(x, y): def do_add(): # `x` e `y` se definen arriba, en `add(x, y)` print('Sumando ', x, y) return x + y return do_add Observe adem\u00e1s que esas variables se mantienen vivas de alguna manera despu\u00e9s de que add() haya terminado. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Sumando 3 4 # \u00bfDe d\u00f3nde provienen estos valores? 7 Clousures Cuando se devuelve una funci\u00f3n interna como resultado, esa funci\u00f3n interna se conoce como clousure . def add(x, y): # `do_add` es un clousure def do_add(): print('Sumando', x, y) return x + y return do_add Caracter\u00edstica esencial: clousures conserva los valores de todas las variables necesarias para que la funci\u00f3n se ejecute correctamente m\u00e1s adelante. Piense en Clousures como una funci\u00f3n m\u00e1s un entorno adicional que contiene los valores de las variables de las que depende. Uso de Clousures Clousures son una caracter\u00edstica esencial de Python. Sin embargo, su uso suele ser sutil. Aplicaciones comunes: Uso en funciones de devoluci\u00f3n de llamada. Evaluaci\u00f3n retrasada. Funciones de decorador (m\u00e1s adelante). Evaluaci\u00f3n retrasada Considere una funci\u00f3n como esta: def after(seconds, func): import time time.sleep(seconds) func() Ejemplo de uso: def greeting(): print('Hola Guido') after(30, greeting) after ejecuta la funci\u00f3n suministrada... m\u00e1s tarde. Clousures llevan informaci\u00f3n adicional. def add(x, y): def do_add(): print(f'Sumando {x} + {y} -> {x+y}') return do_add def after(seconds, func): import time time.sleep(seconds) func() after(30, add(2, 3)) # `do_add` tiene las referencias x -> 2 e y -> 3 Repetici\u00f3n de c\u00f3digo Clousures tambi\u00e9n se pueden utilizar como t\u00e9cnica para evitar la repetici\u00f3n excesiva de c\u00f3digo. Puede escribir funciones que generen c\u00f3digo. Ejercicios Ejercicio 7.7: Uso de clousures para evitar la repetici\u00f3n Una de las caracter\u00edsticas m\u00e1s poderosas de los clousures es su uso para generar c\u00f3digo repetitivo. Si vuelve a consultar Ejercicio 5.7 , recuerde el c\u00f3digo para definir una propiedad con verificaci\u00f3n de tipos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price ... @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value ... En lugar de escribir ese c\u00f3digo una y otra vez, puede crearlo autom\u00e1ticamente utilizando un clousure . Crea un archivo typedproperty.py y pon el siguiente c\u00f3digo en \u00e9l: # typedproperty.py def typedproperty(name, expected_type): private_name = '_' + name @property def prop(self): return getattr(self, private_name) @prop.setter def prop(self, value): if not isinstance(value, expected_type): raise TypeError(f'Esperado un {expected_type}') setattr(self, private_name, value) return prop Ahora, pru\u00e9balo definiendo una clase como esta: from typedproperty import typedproperty class Stock: name = typedproperty('name', str) shares = typedproperty('shares', int) price = typedproperty('price', float) def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Intenta crear una instancia y verificar que la comprobaci\u00f3n de tipos funciona. >>> s = Stock('IBM', 50, 91.1) >>> s.name 'IBM' >>> s.shares = '100' ... deber\u00eda obtener un TypeError ... >>> Ejercicio 7.8: Simplificaci\u00f3n de llamadas a funciones En el ejemplo anterior, los usuarios pueden encontrar llamadas como typedproperty('shares', int) un poco verbosas para escribir, especialmente si se repiten mucho. Agregue las siguientes definiciones al archivo typedproperty.py : String = lambda name: typedproperty(name, str) Integer = lambda name: typedproperty(name, int) Float = lambda name: typedproperty(name, float) Ahora, reescriba la clase Stock para usar estas funciones en su lugar: class Stock: name = String('name') shares = Integer('shares') price = Float('price') def __init__(self, name, shares, price): self.name = name self.shares = shares self.price= price Ah, eso est\u00e1 un poco mejor. La principal conclusi\u00f3n aqu\u00ed es que clousures y lambda a menudo se pueden usar para simplificar el c\u00f3digo y eliminar repeticiones molestas. Esto suele ser bueno. Ejercicio 7.9: Poni\u00e9ndolo en pr\u00e1ctica Reescribe la clase Stock en el archivo stock.py para que use propiedades tipificadas como se muestra. Contenido | Anterior (7.2 Funciones an\u00f3nimas y lambda) | Pr\u00f3ximo (7.4 Decoradores de funciones)","title":"03_Returning_functions"},{"location":"07_Advanced_Topics/03_Returning_functions/#73-retornando-funciones-y-clousures","text":"Esta secci\u00f3n presenta la idea de usar funciones para crear otras funciones.","title":"7.3 Retornando Funciones y clousures"},{"location":"07_Advanced_Topics/03_Returning_functions/#introduccion","text":"Considere la siguiente funci\u00f3n. def add(x, y): def do_add(): print('Sumando', x, y) return x + y return do_add Esta es una funci\u00f3n que devuelve otra funci\u00f3n. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Sumando 3 4 7","title":"Introducci\u00f3n"},{"location":"07_Advanced_Topics/03_Returning_functions/#variables-locales","text":"Observe c\u00f3mo la funci\u00f3n interna hace referencia a las variables definidas por la funci\u00f3n externa. def add(x, y): def do_add(): # `x` e `y` se definen arriba, en `add(x, y)` print('Sumando ', x, y) return x + y return do_add Observe adem\u00e1s que esas variables se mantienen vivas de alguna manera despu\u00e9s de que add() haya terminado. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Sumando 3 4 # \u00bfDe d\u00f3nde provienen estos valores? 7","title":"Variables locales"},{"location":"07_Advanced_Topics/03_Returning_functions/#clousures","text":"Cuando se devuelve una funci\u00f3n interna como resultado, esa funci\u00f3n interna se conoce como clousure . def add(x, y): # `do_add` es un clousure def do_add(): print('Sumando', x, y) return x + y return do_add Caracter\u00edstica esencial: clousures conserva los valores de todas las variables necesarias para que la funci\u00f3n se ejecute correctamente m\u00e1s adelante. Piense en Clousures como una funci\u00f3n m\u00e1s un entorno adicional que contiene los valores de las variables de las que depende.","title":"Clousures"},{"location":"07_Advanced_Topics/03_Returning_functions/#uso-de-clousures","text":"Clousures son una caracter\u00edstica esencial de Python. Sin embargo, su uso suele ser sutil. Aplicaciones comunes: Uso en funciones de devoluci\u00f3n de llamada. Evaluaci\u00f3n retrasada. Funciones de decorador (m\u00e1s adelante).","title":"Uso de Clousures"},{"location":"07_Advanced_Topics/03_Returning_functions/#evaluacion-retrasada","text":"Considere una funci\u00f3n como esta: def after(seconds, func): import time time.sleep(seconds) func() Ejemplo de uso: def greeting(): print('Hola Guido') after(30, greeting) after ejecuta la funci\u00f3n suministrada... m\u00e1s tarde. Clousures llevan informaci\u00f3n adicional. def add(x, y): def do_add(): print(f'Sumando {x} + {y} -> {x+y}') return do_add def after(seconds, func): import time time.sleep(seconds) func() after(30, add(2, 3)) # `do_add` tiene las referencias x -> 2 e y -> 3","title":"Evaluaci\u00f3n retrasada"},{"location":"07_Advanced_Topics/03_Returning_functions/#repeticion-de-codigo","text":"Clousures tambi\u00e9n se pueden utilizar como t\u00e9cnica para evitar la repetici\u00f3n excesiva de c\u00f3digo. Puede escribir funciones que generen c\u00f3digo.","title":"Repetici\u00f3n de c\u00f3digo"},{"location":"07_Advanced_Topics/03_Returning_functions/#ejercicios","text":"","title":"Ejercicios"},{"location":"07_Advanced_Topics/03_Returning_functions/#ejercicio-77-uso-de-clousures-para-evitar-la-repeticion","text":"Una de las caracter\u00edsticas m\u00e1s poderosas de los clousures es su uso para generar c\u00f3digo repetitivo. Si vuelve a consultar Ejercicio 5.7 , recuerde el c\u00f3digo para definir una propiedad con verificaci\u00f3n de tipos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price ... @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value ... En lugar de escribir ese c\u00f3digo una y otra vez, puede crearlo autom\u00e1ticamente utilizando un clousure . Crea un archivo typedproperty.py y pon el siguiente c\u00f3digo en \u00e9l: # typedproperty.py def typedproperty(name, expected_type): private_name = '_' + name @property def prop(self): return getattr(self, private_name) @prop.setter def prop(self, value): if not isinstance(value, expected_type): raise TypeError(f'Esperado un {expected_type}') setattr(self, private_name, value) return prop Ahora, pru\u00e9balo definiendo una clase como esta: from typedproperty import typedproperty class Stock: name = typedproperty('name', str) shares = typedproperty('shares', int) price = typedproperty('price', float) def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Intenta crear una instancia y verificar que la comprobaci\u00f3n de tipos funciona. >>> s = Stock('IBM', 50, 91.1) >>> s.name 'IBM' >>> s.shares = '100' ... deber\u00eda obtener un TypeError ... >>>","title":"Ejercicio 7.7: Uso de clousures para evitar la repetici\u00f3n"},{"location":"07_Advanced_Topics/03_Returning_functions/#ejercicio-78-simplificacion-de-llamadas-a-funciones","text":"En el ejemplo anterior, los usuarios pueden encontrar llamadas como typedproperty('shares', int) un poco verbosas para escribir, especialmente si se repiten mucho. Agregue las siguientes definiciones al archivo typedproperty.py : String = lambda name: typedproperty(name, str) Integer = lambda name: typedproperty(name, int) Float = lambda name: typedproperty(name, float) Ahora, reescriba la clase Stock para usar estas funciones en su lugar: class Stock: name = String('name') shares = Integer('shares') price = Float('price') def __init__(self, name, shares, price): self.name = name self.shares = shares self.price= price Ah, eso est\u00e1 un poco mejor. La principal conclusi\u00f3n aqu\u00ed es que clousures y lambda a menudo se pueden usar para simplificar el c\u00f3digo y eliminar repeticiones molestas. Esto suele ser bueno.","title":"Ejercicio 7.8: Simplificaci\u00f3n de llamadas a funciones"},{"location":"07_Advanced_Topics/03_Returning_functions/#ejercicio-79-poniendolo-en-practica","text":"Reescribe la clase Stock en el archivo stock.py para que use propiedades tipificadas como se muestra. Contenido | Anterior (7.2 Funciones an\u00f3nimas y lambda) | Pr\u00f3ximo (7.4 Decoradores de funciones)","title":"Ejercicio 7.9: Poni\u00e9ndolo en pr\u00e1ctica"},{"location":"07_Advanced_Topics/04_Function_decorators/","text":"Contenido | Anterior (7.3 Retornando Funciones y clousures) | Pr\u00f3ximo (7.5 M\u00e9todos est\u00e1ticos y de clase) 7.4 Decoradores de funciones Esta secci\u00f3n presenta el concepto de decorador. Este es un tema avanzado del que apenas hemos tocado la superficie. Ejemplo de registro Considere una funci\u00f3n. def add(x, y): return x + y Ahora, considere la funci\u00f3n con alg\u00fan registro agregado. def add(x, y): print('Llamando a add') return x + y Ahora una segunda funci\u00f3n tambi\u00e9n con alg\u00fan registro. def sub(x, y): print('Llamando a sub') return x - y Observaci\u00f3n Observaci\u00f3n: Es algo repetitivo. Escribir programas en los que hay mucha replicaci\u00f3n de c\u00f3digo suele ser muy molesto. Son tediosos de escribir y dif\u00edciles de mantener. Especialmente si decides que quieres cambiar su funcionamiento (es decir, un tipo diferente de registro, tal vez). C\u00f3digo que crea el registro Quiz\u00e1s puedas crear una funci\u00f3n que cree funciones con el registro agregado a ellas. Un contenedor. def logged(func): def wrapper(*args, **kwargs): print('Llamando a', func.__name__) return func(*args, **kwargs) return wrapper Ahora \u00fasalo. def add(x, y): return x + y logged_add = logged(add) \u00bfQu\u00e9 sucede cuando llamas a la funci\u00f3n devuelta por logged ? logged_add(3, 4) # Ves que aparece el mensaje de registro Este ejemplo ilustra el proceso de creaci\u00f3n de una llamada funci\u00f3n contenedora . Una funci\u00f3n contenedora es una funci\u00f3n que envuelve otra funci\u00f3n con algunos bits adicionales de procesamiento, pero que por lo dem\u00e1s funciona exactamente de la misma manera que la funci\u00f3n original. >>> logged_add(3, 4) Llamando a add # Salida adicional. A\u00f1adida por la funci\u00f3n contenedora 7 >>> Nota: La funci\u00f3n logged() crea la funci\u00f3n contenedora y la devuelve como resultado. Decoradores Poner envoltorios a las funciones es extremadamente com\u00fan en Python. Es tan com\u00fan que existe una sintaxis especial para ello. def add(x, y): return x + y add = logged(add) # Sintaxis especial @logged def add(x, y): return x + y La sintaxis especial realiza exactamente los mismos pasos que se muestran arriba. Un decorador es simplemente una sintaxis nueva. Se dice que decora la funci\u00f3n. Comentario Hay muchos m\u00e1s detalles sutiles sobre los decoradores que los que se han presentado aqu\u00ed. Por ejemplo, su uso en clases o el uso de m\u00faltiples decoradores con una funci\u00f3n. Sin embargo, el ejemplo anterior es una buena ilustraci\u00f3n de c\u00f3mo tiende a surgir su uso. Por lo general, es en respuesta a un c\u00f3digo repetitivo que aparece en una amplia gama de definiciones de funciones. Un decorador puede mover ese c\u00f3digo a una definici\u00f3n central. Ejercicios Ejercicio 7.10: Un decorador para cronometrar Si define una funci\u00f3n, su nombre y m\u00f3dulo se almacenan en los atributos __name__ y __module__ . Por ejemplo: >>> def add(x,y): return x+y >>> add.__name__ 'add' >>> add.__module__ '__main__' >>> En un archivo timethis.py , escriba una funci\u00f3n decoradora timethis(func) que envuelva una funci\u00f3n con una capa adicional de l\u00f3gica que muestre cu\u00e1nto tiempo tarda una funci\u00f3n en ejecutarse. Para ello, rodear\u00e1s la funci\u00f3n con llamadas de temporizaci\u00f3n como esta: start = time.time() r = func(*args,**kwargs) end = time.time() print('%s.%s: %f' % (func.__module__, func.__name__, end-start)) A continuaci\u00f3n, se incluye un ejemplo de c\u00f3mo deber\u00eda funcionar tu decorador: >>> from timethis import timethis >>> @timethis def countdown(n): while n > 0: n -= 1 >>> countdown(10000000) __main__.countdown : 0.076562 >>> Discusi\u00f3n: Este decorador @timethis se puede colocar delante de cualquier definici\u00f3n de funci\u00f3n. Por lo tanto, puedes usarlo como una herramienta de diagn\u00f3stico para ajustar el rendimiento. Contenido | Anterior (7.3 Retornando Funciones y clousures) | Pr\u00f3ximo (7.5 M\u00e9todos est\u00e1ticos y de clase)","title":"04_Function_decorators"},{"location":"07_Advanced_Topics/04_Function_decorators/#74-decoradores-de-funciones","text":"Esta secci\u00f3n presenta el concepto de decorador. Este es un tema avanzado del que apenas hemos tocado la superficie.","title":"7.4 Decoradores de funciones"},{"location":"07_Advanced_Topics/04_Function_decorators/#ejemplo-de-registro","text":"Considere una funci\u00f3n. def add(x, y): return x + y Ahora, considere la funci\u00f3n con alg\u00fan registro agregado. def add(x, y): print('Llamando a add') return x + y Ahora una segunda funci\u00f3n tambi\u00e9n con alg\u00fan registro. def sub(x, y): print('Llamando a sub') return x - y","title":"Ejemplo de registro"},{"location":"07_Advanced_Topics/04_Function_decorators/#observacion","text":"Observaci\u00f3n: Es algo repetitivo. Escribir programas en los que hay mucha replicaci\u00f3n de c\u00f3digo suele ser muy molesto. Son tediosos de escribir y dif\u00edciles de mantener. Especialmente si decides que quieres cambiar su funcionamiento (es decir, un tipo diferente de registro, tal vez).","title":"Observaci\u00f3n"},{"location":"07_Advanced_Topics/04_Function_decorators/#codigo-que-crea-el-registro","text":"Quiz\u00e1s puedas crear una funci\u00f3n que cree funciones con el registro agregado a ellas. Un contenedor. def logged(func): def wrapper(*args, **kwargs): print('Llamando a', func.__name__) return func(*args, **kwargs) return wrapper Ahora \u00fasalo. def add(x, y): return x + y logged_add = logged(add) \u00bfQu\u00e9 sucede cuando llamas a la funci\u00f3n devuelta por logged ? logged_add(3, 4) # Ves que aparece el mensaje de registro Este ejemplo ilustra el proceso de creaci\u00f3n de una llamada funci\u00f3n contenedora . Una funci\u00f3n contenedora es una funci\u00f3n que envuelve otra funci\u00f3n con algunos bits adicionales de procesamiento, pero que por lo dem\u00e1s funciona exactamente de la misma manera que la funci\u00f3n original. >>> logged_add(3, 4) Llamando a add # Salida adicional. A\u00f1adida por la funci\u00f3n contenedora 7 >>> Nota: La funci\u00f3n logged() crea la funci\u00f3n contenedora y la devuelve como resultado.","title":"C\u00f3digo que crea el registro"},{"location":"07_Advanced_Topics/04_Function_decorators/#decoradores","text":"Poner envoltorios a las funciones es extremadamente com\u00fan en Python. Es tan com\u00fan que existe una sintaxis especial para ello. def add(x, y): return x + y add = logged(add) # Sintaxis especial @logged def add(x, y): return x + y La sintaxis especial realiza exactamente los mismos pasos que se muestran arriba. Un decorador es simplemente una sintaxis nueva. Se dice que decora la funci\u00f3n.","title":"Decoradores"},{"location":"07_Advanced_Topics/04_Function_decorators/#comentario","text":"Hay muchos m\u00e1s detalles sutiles sobre los decoradores que los que se han presentado aqu\u00ed. Por ejemplo, su uso en clases o el uso de m\u00faltiples decoradores con una funci\u00f3n. Sin embargo, el ejemplo anterior es una buena ilustraci\u00f3n de c\u00f3mo tiende a surgir su uso. Por lo general, es en respuesta a un c\u00f3digo repetitivo que aparece en una amplia gama de definiciones de funciones. Un decorador puede mover ese c\u00f3digo a una definici\u00f3n central.","title":"Comentario"},{"location":"07_Advanced_Topics/04_Function_decorators/#ejercicios","text":"","title":"Ejercicios"},{"location":"07_Advanced_Topics/04_Function_decorators/#ejercicio-710-un-decorador-para-cronometrar","text":"Si define una funci\u00f3n, su nombre y m\u00f3dulo se almacenan en los atributos __name__ y __module__ . Por ejemplo: >>> def add(x,y): return x+y >>> add.__name__ 'add' >>> add.__module__ '__main__' >>> En un archivo timethis.py , escriba una funci\u00f3n decoradora timethis(func) que envuelva una funci\u00f3n con una capa adicional de l\u00f3gica que muestre cu\u00e1nto tiempo tarda una funci\u00f3n en ejecutarse. Para ello, rodear\u00e1s la funci\u00f3n con llamadas de temporizaci\u00f3n como esta: start = time.time() r = func(*args,**kwargs) end = time.time() print('%s.%s: %f' % (func.__module__, func.__name__, end-start)) A continuaci\u00f3n, se incluye un ejemplo de c\u00f3mo deber\u00eda funcionar tu decorador: >>> from timethis import timethis >>> @timethis def countdown(n): while n > 0: n -= 1 >>> countdown(10000000) __main__.countdown : 0.076562 >>> Discusi\u00f3n: Este decorador @timethis se puede colocar delante de cualquier definici\u00f3n de funci\u00f3n. Por lo tanto, puedes usarlo como una herramienta de diagn\u00f3stico para ajustar el rendimiento. Contenido | Anterior (7.3 Retornando Funciones y clousures) | Pr\u00f3ximo (7.5 M\u00e9todos est\u00e1ticos y de clase)","title":"Ejercicio 7.10: Un decorador para cronometrar"},{"location":"07_Advanced_Topics/05_Decorated_methods/","text":"Contenido | Anterior (7.4 Decoradores de funciones) | Pr\u00f3ximo (8 Pruebas y depuraci\u00f3n) 7.5 M\u00e9todos est\u00e1ticos y de clase Esta secci\u00f3n analiza algunos decoradores integrados que se utilizan en combinaci\u00f3n con definiciones de m\u00e9todos. Decoradores predefinidos Existen decoradores predefinidos que se utilizan para especificar tipos especiales de m\u00e9todos en las definiciones de clase. class Foo: def bar(self,a): ... @staticmethod def spam(a): ... @classmethod def grok(cls,a): ... @property def name(self): ... Veamos uno por uno. M\u00e9todos est\u00e1ticos @staticmethod se utiliza para definir los llamados m\u00e9todos de clase est\u00e1ticos (de C++/Java). Un m\u00e9todo est\u00e1tico es una funci\u00f3n que forma parte de la clase, pero que no opera en instancias. class Foo(object): @staticmethod def bar(x): print('x =', x) >>> Foo.bar(2) x=2 >>> Los m\u00e9todos est\u00e1ticos se utilizan a veces para implementar c\u00f3digo de soporte interno para una clase. Por ejemplo, c\u00f3digo para ayudar a administrar instancias creadas (administraci\u00f3n de memoria, recursos del sistema, persistencia, bloqueo, etc.). Tambi\u00e9n se utilizan en ciertos patrones de dise\u00f1o (no se analizan aqu\u00ed). M\u00e9todos de clase @classmethod se utiliza para definir m\u00e9todos de clase. Un m\u00e9todo de clase es un m\u00e9todo que recibe el objeto de clase como primer par\u00e1metro en lugar de la instancia. class Foo: def bar(self): print(self) @classmethod def spam(cls): print(cls) >>> f = Foo() >>> f.bar() <__main__.Foo object at 0x971690> # La instancia `f` >>> Foo.spam() <class '__main__.Foo'> # La clase `Foo` >>> Los m\u00e9todos de clase se utilizan con mayor frecuencia como una herramienta para definir constructores alternativos. import time class Date: def __init__(self,year,month,day): self.year = year self.month = month self.day = day @classmethod def today(cls): # Observa c\u00f3mo se pasa la clase como argumento tm = time.localtime() # Y se usa para crear una nueva instancia return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) d = Date.today() print(d.__dict__) Los m\u00e9todos de clase resuelven algunos problemas complicados con caracter\u00edsticas como la herencia. class Date: ... @classmethod def today(cls): # Obtiene la clase correcta (p. ej., `NewDate`) tm = time.localtime() return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) class NewDate(Date): ... d = NewDate.today() Ejercicios Ejercicio 7.11: M\u00e9todos de clase en la pr\u00e1ctica En los archivos report.py y portfolio.py , la creaci\u00f3n de un objeto Portfolio es un poco confusa. Por ejemplo, el programa report.py tiene un c\u00f3digo como este: def read_portfolio(filename, **opts): ''' Lee un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) y el archivo portfolio.py define Portfolio() con un inicializador extra\u00f1o como este: class Portfolio: def __init__(self, holdings): self.holdings = holdings ... Francamente, la cadena de responsabilidad es un poco confusa porque el c\u00f3digo est\u00e1 disperso. Si se supone que una clase Portfolio contiene una lista de instancias de Stock , tal vez deber\u00eda cambiar la clase para que sea un poco m\u00e1s clara. As\u00ed: # portfolio.py import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Se esperaba una instancia de Stock') self.holdings.append(holding) ... Si quieres leer un portfolio desde un archivo CSV, tal vez deber\u00edas crear un m\u00e9todo de clase para ello: # portfolio.py import fileparse import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Se esperaba una instancia de Stock') self.holdings.append(holding) @classmethod def from_csv(cls, lines, **opts): self = cls() portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) for d in portdicts: self.append(stock.Stock(**d)) return self Para usar esta nueva clase Portfolio, ahora puede escribir c\u00f3digo como este: >>> from portfolio import Portfolio >>> with open('Data/portfolio.csv') as lines: ... port = Portfolio.from_csv(lines) ... >>> Realice estos cambios en la clase Portfolio y modifique el c\u00f3digo report.py para utilizar el m\u00e9todo de clase. Contenido | Anterior (7.4 Decoradores de funciones) | Pr\u00f3ximo (8 Pruebas y depuraci\u00f3n)","title":"05_Decorated_methods"},{"location":"07_Advanced_Topics/05_Decorated_methods/#75-metodos-estaticos-y-de-clase","text":"Esta secci\u00f3n analiza algunos decoradores integrados que se utilizan en combinaci\u00f3n con definiciones de m\u00e9todos.","title":"7.5 M\u00e9todos est\u00e1ticos y de clase"},{"location":"07_Advanced_Topics/05_Decorated_methods/#decoradores-predefinidos","text":"Existen decoradores predefinidos que se utilizan para especificar tipos especiales de m\u00e9todos en las definiciones de clase. class Foo: def bar(self,a): ... @staticmethod def spam(a): ... @classmethod def grok(cls,a): ... @property def name(self): ... Veamos uno por uno.","title":"Decoradores predefinidos"},{"location":"07_Advanced_Topics/05_Decorated_methods/#metodos-estaticos","text":"@staticmethod se utiliza para definir los llamados m\u00e9todos de clase est\u00e1ticos (de C++/Java). Un m\u00e9todo est\u00e1tico es una funci\u00f3n que forma parte de la clase, pero que no opera en instancias. class Foo(object): @staticmethod def bar(x): print('x =', x) >>> Foo.bar(2) x=2 >>> Los m\u00e9todos est\u00e1ticos se utilizan a veces para implementar c\u00f3digo de soporte interno para una clase. Por ejemplo, c\u00f3digo para ayudar a administrar instancias creadas (administraci\u00f3n de memoria, recursos del sistema, persistencia, bloqueo, etc.). Tambi\u00e9n se utilizan en ciertos patrones de dise\u00f1o (no se analizan aqu\u00ed).","title":"M\u00e9todos est\u00e1ticos"},{"location":"07_Advanced_Topics/05_Decorated_methods/#metodos-de-clase","text":"@classmethod se utiliza para definir m\u00e9todos de clase. Un m\u00e9todo de clase es un m\u00e9todo que recibe el objeto de clase como primer par\u00e1metro en lugar de la instancia. class Foo: def bar(self): print(self) @classmethod def spam(cls): print(cls) >>> f = Foo() >>> f.bar() <__main__.Foo object at 0x971690> # La instancia `f` >>> Foo.spam() <class '__main__.Foo'> # La clase `Foo` >>> Los m\u00e9todos de clase se utilizan con mayor frecuencia como una herramienta para definir constructores alternativos. import time class Date: def __init__(self,year,month,day): self.year = year self.month = month self.day = day @classmethod def today(cls): # Observa c\u00f3mo se pasa la clase como argumento tm = time.localtime() # Y se usa para crear una nueva instancia return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) d = Date.today() print(d.__dict__) Los m\u00e9todos de clase resuelven algunos problemas complicados con caracter\u00edsticas como la herencia. class Date: ... @classmethod def today(cls): # Obtiene la clase correcta (p. ej., `NewDate`) tm = time.localtime() return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) class NewDate(Date): ... d = NewDate.today()","title":"M\u00e9todos de clase"},{"location":"07_Advanced_Topics/05_Decorated_methods/#ejercicios","text":"","title":"Ejercicios"},{"location":"07_Advanced_Topics/05_Decorated_methods/#ejercicio-711-metodos-de-clase-en-la-practica","text":"En los archivos report.py y portfolio.py , la creaci\u00f3n de un objeto Portfolio es un poco confusa. Por ejemplo, el programa report.py tiene un c\u00f3digo como este: def read_portfolio(filename, **opts): ''' Lee un archivo de cartera de acciones en una lista de diccionarios con claves name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) y el archivo portfolio.py define Portfolio() con un inicializador extra\u00f1o como este: class Portfolio: def __init__(self, holdings): self.holdings = holdings ... Francamente, la cadena de responsabilidad es un poco confusa porque el c\u00f3digo est\u00e1 disperso. Si se supone que una clase Portfolio contiene una lista de instancias de Stock , tal vez deber\u00eda cambiar la clase para que sea un poco m\u00e1s clara. As\u00ed: # portfolio.py import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Se esperaba una instancia de Stock') self.holdings.append(holding) ... Si quieres leer un portfolio desde un archivo CSV, tal vez deber\u00edas crear un m\u00e9todo de clase para ello: # portfolio.py import fileparse import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Se esperaba una instancia de Stock') self.holdings.append(holding) @classmethod def from_csv(cls, lines, **opts): self = cls() portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) for d in portdicts: self.append(stock.Stock(**d)) return self Para usar esta nueva clase Portfolio, ahora puede escribir c\u00f3digo como este: >>> from portfolio import Portfolio >>> with open('Data/portfolio.csv') as lines: ... port = Portfolio.from_csv(lines) ... >>> Realice estos cambios en la clase Portfolio y modifique el c\u00f3digo report.py para utilizar el m\u00e9todo de clase. Contenido | Anterior (7.4 Decoradores de funciones) | Pr\u00f3ximo (8 Pruebas y depuraci\u00f3n)","title":"Ejercicio 7.11: M\u00e9todos de clase en la pr\u00e1ctica"},{"location":"08_Testing_debugging/00_Overview/","text":"Contenido | Anterior (7. Algunos temas avanzados) | Pr\u00f3ximo (9. Paquetes) 8. Pruebas y depuraci\u00f3n Esta secci\u00f3n presenta algunos temas b\u00e1sicos relacionados con las pruebas, el registro y la depuraci\u00f3n. 8.1 Pruebas 8.2 Registro, manejo de errores y diagn\u00f3sticos 8.3 Depuraci\u00f3n Contenido | Anterior (7. Algunos temas avanzados) | Pr\u00f3ximo (9. Paquetes)","title":"00_Overview"},{"location":"08_Testing_debugging/00_Overview/#8-pruebas-y-depuracion","text":"Esta secci\u00f3n presenta algunos temas b\u00e1sicos relacionados con las pruebas, el registro y la depuraci\u00f3n. 8.1 Pruebas 8.2 Registro, manejo de errores y diagn\u00f3sticos 8.3 Depuraci\u00f3n Contenido | Anterior (7. Algunos temas avanzados) | Pr\u00f3ximo (9. Paquetes)","title":"8. Pruebas y depuraci\u00f3n"},{"location":"08_Testing_debugging/01_Testing/","text":"Contenido | Anterior (7.5 M\u00e9todos est\u00e1ticos y de clase) | Pr\u00f3ximo (8.2 Logging) 8.1 Pruebas Las pruebas son geniales, la depuraci\u00f3n es un asco La naturaleza din\u00e1mica de Python hace que las pruebas sean de vital importancia para la mayor\u00eda de las aplicaciones. No hay ning\u00fan compilador que encuentre errores. La \u00fanica forma de encontrarlos es ejecutar el c\u00f3digo y asegurarse de probar todas sus funciones. Afirmaciones La declaraci\u00f3n assert es una verificaci\u00f3n interna del programa. Si una expresi\u00f3n no es verdadera, genera una excepci\u00f3n AssertionError . Sintaxis de la declaraci\u00f3n assert . assert <expresi\u00f3nn> [, 'Mensaje de diagn\u00f3stico'] Por ejemplo. assert isinstance(10, int), 'Int esperado' No deber\u00eda usarse para verificar la entrada del usuario (es decir, los datos ingresados en un formulario web o algo as\u00ed). Su prop\u00f3sito es m\u00e1s para verificaciones internas e invariantes (condiciones que siempre deben ser verdaderas). Programaci\u00f3n por contrato Tambi\u00e9n conocida como Dise\u00f1o por contrato, el uso liberal de aserciones es un enfoque para dise\u00f1ar software. Prescribe que los dise\u00f1adores de software deben definir especificaciones de interfaces precisas para los componentes del software. Por ejemplo, puede colocar aserciones en todas las entradas de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Espera un int' assert isinstance(y, int), 'Espera un int' return x + y Al verificar las entradas, se detectar\u00e1n inmediatamente los invocadores que no est\u00e9n usando los argumentos adecuados. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Esperado un int >>> Pruebas en l\u00ednea Las afirmaciones tambi\u00e9n se pueden usar para pruebas simples. def add(x, y): return x + y assert add(2,2) == 4 De esta manera, est\u00e1 incluyendo la prueba en el mismo m\u00f3dulo que su c\u00f3digo. Beneficio: si el c\u00f3digo est\u00e1 claramente da\u00f1ado, los intentos de importar el m\u00f3dulo fallar\u00e1n. Esto no se recomienda para pruebas exhaustivas. Es m\u00e1s bien una \"prueba de humo\" b\u00e1sica. \u00bfFunciona la funci\u00f3n en alg\u00fan ejemplo? Si no, entonces algo est\u00e1 definitivamente da\u00f1ado. M\u00f3dulo unittest Supongamos que tiene un c\u00f3digo. # simple.py def add(x, y): return x + y Ahora, supongamos que desea probarlo. Cree un archivo de prueba independiente como este. # test_simple.py import simple import unittest Luego defina una clase de prueba. # test_simple.py import simple import unittest # Observe que hereda de unittest.TestCase class TestAdd(unittest.TestCase): ... La clase de prueba debe heredar de unittest.TestCase . En la clase de prueba, se definen los m\u00e9todos de prueba. # test_simple.py import simple import unittest # Observe que hereda de unittest.TestCase class TestAdd(unittest.TestCase): def test_simple(self): # Prueba con argumentos enteros simples r = simple.add(2, 2) self.assertEqual(r, 5) def test_str(self): # Prueba con cadenas r = simple.add('hello', 'world') self.assertEqual(r, 'helloworld') *Importante: Cada m\u00e9todo debe comenzar con test . Uso de unittest Hay varias afirmaciones integradas que vienen con unittest . Cada una de ellas afirma algo diferente. # Afirmar que expr es True self.assertTrue(expr) # Afirmar que x == y self.assertEqual(x,y) # Afirmar que x != y self.assertNotEqual(x,y) # Afirmar que x est\u00e1 cerca de y self.assertAlmostEqual(x,y,places) # Afirmar que callable(arg1,arg2,...) genera excepci\u00f3n self.assertRaises(exc, callable, arg1, arg2, ...) Esta no es una lista exhaustiva. Hay otras afirmaciones en el m\u00f3dulo. Ejecutar unittest Para ejecutar las pruebas, convierta el c\u00f3digo en un script. # test_simple.py ... if __name__ == '__main__': unittest.main() Luego, ejecute Python en el archivo de prueba. bash % python3 test_simple.py F. ========================================================= FAIL: test_simple (__main__.TestAdd) -------------------------------------------------------- Traceback (most recent call last): File \"testsimple.py\", line 8, in test_simple self.assertEqual(r, 5) AssertionError: 4 != 5 -------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=1) Comentario La realizaci\u00f3n de pruebas unitarias efectivas es un arte y puede volverse bastante complicada para aplicaciones grandes. El m\u00f3dulo unittest tiene una gran cantidad de opciones relacionadas con los ejecutores de pruebas, la recopilaci\u00f3n de resultados y otros aspectos de las pruebas. Consulta la documentaci\u00f3n para obtener m\u00e1s detalles. Herramientas de prueba de terceros El m\u00f3dulo unittest integrado tiene la ventaja de estar disponible en todas partes: es parte de Python. Sin embargo, muchos programadores tambi\u00e9n lo consideran bastante detallado. Una alternativa popular es pytest . Con pytest, tu archivo de prueba se simplifica a algo como lo siguiente: # test_simple.py import simple def test_simple(): assert simple.add(2,2) == 4 def test_str(): assert simple.add('hello','world') == 'helloworld' Para ejecutar las pruebas, simplemente escriba un comando como python -m pytest . Descubrir\u00e1 todas las pruebas y las ejecutar\u00e1. pytest es mucho m\u00e1s que este ejemplo, pero suele ser bastante f\u00e1cil comenzar si decide probarlo. Ejercicios En este ejercicio, explorar\u00e1 la mec\u00e1nica b\u00e1sica del uso del m\u00f3dulo unittest de Python. En ejercicios anteriores, escribi\u00f3 un archivo stock.py que conten\u00eda una clase Stock . Para este ejercicio, se asumi\u00f3 que est\u00e1 usando el c\u00f3digo escrito para Ejercicio 7.9 que involucra propiedades tipificadas. Si, por alguna raz\u00f3n, eso no funciona, es posible que desee copiar la soluci\u00f3n de Soluciones/7_9 a su directorio de trabajo. Ejercicio 8.1: Escritura de pruebas unitarias En un archivo separado test_stock.py , escribe un conjunto de pruebas unitarias para la clase Stock . Para comenzar, aqu\u00ed tienes un peque\u00f1o fragmento de c\u00f3digo que prueba la creaci\u00f3n de instancias: # test_stock.py import unittest import stock class TestStock(unittest.TestCase): def test_create(self): s = stock.Stock('GOOG', 100, 490.1) self.assertEqual(s.name, 'GOOG') self.assertEqual(s.shares, 100) self.assertEqual(s.price, 490.1) if __name__ == '__main__': unittest.main() Ejecuta tus pruebas unitarias. Deber\u00edas obtener un resultado similar a este: . ---------------------------------------------------------------------- Ran 1 tests in 0.000s OK Una vez que est\u00e9 satisfecho con el funcionamiento, escriba pruebas unitarias adicionales que verifiquen lo siguiente: Aseg\u00farese de que la propiedad s.cost devuelva el valor correcto (49010.0) Aseg\u00farese de que el m\u00e9todo s.sell() funcione correctamente. Deber\u00eda disminuir el valor de s.shares en consecuencia. Aseg\u00farese de que el atributo s.shares no se pueda configurar en un valor que no sea entero. Para la \u00faltima parte, deber\u00e1 verificar que se genere una excepci\u00f3n. Una forma sencilla de hacerlo es con un c\u00f3digo como este: class TestStock(unittest.TestCase): ... def test_bad_shares(self): s = stock.Stock('GOOG', 100, 490.1) with self.assertRaises(TypeError): s.shares = '100' Contenido | Anterior (7.5 M\u00e9todos est\u00e1ticos y de clase) | Pr\u00f3ximo (8.2 Logging)","title":"01_Testing"},{"location":"08_Testing_debugging/01_Testing/#81-pruebas","text":"","title":"8.1 Pruebas"},{"location":"08_Testing_debugging/01_Testing/#las-pruebas-son-geniales-la-depuracion-es-un-asco","text":"La naturaleza din\u00e1mica de Python hace que las pruebas sean de vital importancia para la mayor\u00eda de las aplicaciones. No hay ning\u00fan compilador que encuentre errores. La \u00fanica forma de encontrarlos es ejecutar el c\u00f3digo y asegurarse de probar todas sus funciones.","title":"Las pruebas son geniales, la depuraci\u00f3n es un asco"},{"location":"08_Testing_debugging/01_Testing/#afirmaciones","text":"La declaraci\u00f3n assert es una verificaci\u00f3n interna del programa. Si una expresi\u00f3n no es verdadera, genera una excepci\u00f3n AssertionError . Sintaxis de la declaraci\u00f3n assert . assert <expresi\u00f3nn> [, 'Mensaje de diagn\u00f3stico'] Por ejemplo. assert isinstance(10, int), 'Int esperado' No deber\u00eda usarse para verificar la entrada del usuario (es decir, los datos ingresados en un formulario web o algo as\u00ed). Su prop\u00f3sito es m\u00e1s para verificaciones internas e invariantes (condiciones que siempre deben ser verdaderas).","title":"Afirmaciones"},{"location":"08_Testing_debugging/01_Testing/#programacion-por-contrato","text":"Tambi\u00e9n conocida como Dise\u00f1o por contrato, el uso liberal de aserciones es un enfoque para dise\u00f1ar software. Prescribe que los dise\u00f1adores de software deben definir especificaciones de interfaces precisas para los componentes del software. Por ejemplo, puede colocar aserciones en todas las entradas de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Espera un int' assert isinstance(y, int), 'Espera un int' return x + y Al verificar las entradas, se detectar\u00e1n inmediatamente los invocadores que no est\u00e9n usando los argumentos adecuados. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Esperado un int >>>","title":"Programaci\u00f3n por contrato"},{"location":"08_Testing_debugging/01_Testing/#pruebas-en-linea","text":"Las afirmaciones tambi\u00e9n se pueden usar para pruebas simples. def add(x, y): return x + y assert add(2,2) == 4 De esta manera, est\u00e1 incluyendo la prueba en el mismo m\u00f3dulo que su c\u00f3digo. Beneficio: si el c\u00f3digo est\u00e1 claramente da\u00f1ado, los intentos de importar el m\u00f3dulo fallar\u00e1n. Esto no se recomienda para pruebas exhaustivas. Es m\u00e1s bien una \"prueba de humo\" b\u00e1sica. \u00bfFunciona la funci\u00f3n en alg\u00fan ejemplo? Si no, entonces algo est\u00e1 definitivamente da\u00f1ado.","title":"Pruebas en l\u00ednea"},{"location":"08_Testing_debugging/01_Testing/#modulo-unittest","text":"Supongamos que tiene un c\u00f3digo. # simple.py def add(x, y): return x + y Ahora, supongamos que desea probarlo. Cree un archivo de prueba independiente como este. # test_simple.py import simple import unittest Luego defina una clase de prueba. # test_simple.py import simple import unittest # Observe que hereda de unittest.TestCase class TestAdd(unittest.TestCase): ... La clase de prueba debe heredar de unittest.TestCase . En la clase de prueba, se definen los m\u00e9todos de prueba. # test_simple.py import simple import unittest # Observe que hereda de unittest.TestCase class TestAdd(unittest.TestCase): def test_simple(self): # Prueba con argumentos enteros simples r = simple.add(2, 2) self.assertEqual(r, 5) def test_str(self): # Prueba con cadenas r = simple.add('hello', 'world') self.assertEqual(r, 'helloworld') *Importante: Cada m\u00e9todo debe comenzar con test .","title":"M\u00f3dulo unittest"},{"location":"08_Testing_debugging/01_Testing/#uso-de-unittest","text":"Hay varias afirmaciones integradas que vienen con unittest . Cada una de ellas afirma algo diferente. # Afirmar que expr es True self.assertTrue(expr) # Afirmar que x == y self.assertEqual(x,y) # Afirmar que x != y self.assertNotEqual(x,y) # Afirmar que x est\u00e1 cerca de y self.assertAlmostEqual(x,y,places) # Afirmar que callable(arg1,arg2,...) genera excepci\u00f3n self.assertRaises(exc, callable, arg1, arg2, ...) Esta no es una lista exhaustiva. Hay otras afirmaciones en el m\u00f3dulo.","title":"Uso de unittest"},{"location":"08_Testing_debugging/01_Testing/#ejecutar-unittest","text":"Para ejecutar las pruebas, convierta el c\u00f3digo en un script. # test_simple.py ... if __name__ == '__main__': unittest.main() Luego, ejecute Python en el archivo de prueba. bash % python3 test_simple.py F. ========================================================= FAIL: test_simple (__main__.TestAdd) -------------------------------------------------------- Traceback (most recent call last): File \"testsimple.py\", line 8, in test_simple self.assertEqual(r, 5) AssertionError: 4 != 5 -------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=1)","title":"Ejecutar unittest"},{"location":"08_Testing_debugging/01_Testing/#comentario","text":"La realizaci\u00f3n de pruebas unitarias efectivas es un arte y puede volverse bastante complicada para aplicaciones grandes. El m\u00f3dulo unittest tiene una gran cantidad de opciones relacionadas con los ejecutores de pruebas, la recopilaci\u00f3n de resultados y otros aspectos de las pruebas. Consulta la documentaci\u00f3n para obtener m\u00e1s detalles.","title":"Comentario"},{"location":"08_Testing_debugging/01_Testing/#herramientas-de-prueba-de-terceros","text":"El m\u00f3dulo unittest integrado tiene la ventaja de estar disponible en todas partes: es parte de Python. Sin embargo, muchos programadores tambi\u00e9n lo consideran bastante detallado. Una alternativa popular es pytest . Con pytest, tu archivo de prueba se simplifica a algo como lo siguiente: # test_simple.py import simple def test_simple(): assert simple.add(2,2) == 4 def test_str(): assert simple.add('hello','world') == 'helloworld' Para ejecutar las pruebas, simplemente escriba un comando como python -m pytest . Descubrir\u00e1 todas las pruebas y las ejecutar\u00e1. pytest es mucho m\u00e1s que este ejemplo, pero suele ser bastante f\u00e1cil comenzar si decide probarlo.","title":"Herramientas de prueba de terceros"},{"location":"08_Testing_debugging/01_Testing/#ejercicios","text":"En este ejercicio, explorar\u00e1 la mec\u00e1nica b\u00e1sica del uso del m\u00f3dulo unittest de Python. En ejercicios anteriores, escribi\u00f3 un archivo stock.py que conten\u00eda una clase Stock . Para este ejercicio, se asumi\u00f3 que est\u00e1 usando el c\u00f3digo escrito para Ejercicio 7.9 que involucra propiedades tipificadas. Si, por alguna raz\u00f3n, eso no funciona, es posible que desee copiar la soluci\u00f3n de Soluciones/7_9 a su directorio de trabajo.","title":"Ejercicios"},{"location":"08_Testing_debugging/01_Testing/#ejercicio-81-escritura-de-pruebas-unitarias","text":"En un archivo separado test_stock.py , escribe un conjunto de pruebas unitarias para la clase Stock . Para comenzar, aqu\u00ed tienes un peque\u00f1o fragmento de c\u00f3digo que prueba la creaci\u00f3n de instancias: # test_stock.py import unittest import stock class TestStock(unittest.TestCase): def test_create(self): s = stock.Stock('GOOG', 100, 490.1) self.assertEqual(s.name, 'GOOG') self.assertEqual(s.shares, 100) self.assertEqual(s.price, 490.1) if __name__ == '__main__': unittest.main() Ejecuta tus pruebas unitarias. Deber\u00edas obtener un resultado similar a este: . ---------------------------------------------------------------------- Ran 1 tests in 0.000s OK Una vez que est\u00e9 satisfecho con el funcionamiento, escriba pruebas unitarias adicionales que verifiquen lo siguiente: Aseg\u00farese de que la propiedad s.cost devuelva el valor correcto (49010.0) Aseg\u00farese de que el m\u00e9todo s.sell() funcione correctamente. Deber\u00eda disminuir el valor de s.shares en consecuencia. Aseg\u00farese de que el atributo s.shares no se pueda configurar en un valor que no sea entero. Para la \u00faltima parte, deber\u00e1 verificar que se genere una excepci\u00f3n. Una forma sencilla de hacerlo es con un c\u00f3digo como este: class TestStock(unittest.TestCase): ... def test_bad_shares(self): s = stock.Stock('GOOG', 100, 490.1) with self.assertRaises(TypeError): s.shares = '100' Contenido | Anterior (7.5 M\u00e9todos est\u00e1ticos y de clase) | Pr\u00f3ximo (8.2 Logging)","title":"Ejercicio 8.1: Escritura de pruebas unitarias"},{"location":"08_Testing_debugging/02_Logging/","text":"Contenido | Anterior (8.1 Pruebas) | Pr\u00f3ximo (8.3 Depuraci\u00f3n) 8.2 Registro, manejo de errores y diagn\u00f3sticos Esta secci\u00f3n presenta brevemente el m\u00f3dulo de registro. M\u00f3dulo de registro El m\u00f3dulo logging es un m\u00f3dulo de la biblioteca est\u00e1ndar para registrar informaci\u00f3n de diagn\u00f3stico. Tambi\u00e9n es un m\u00f3dulo muy grande con muchas funciones sofisticadas. Mostraremos un ejemplo simple para ilustrar su utilidad. Excepciones revisitadas En los ejercicios, escribimos una funci\u00f3n parse() que se parec\u00eda a esto: # fileparse.py def parse(f, types=None, names=None, delimiter=None): records = [] for line in f: line = line.strip() if not line: continue try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"No se pudo analizar :\", line) print(\"Raz\u00f3n :\", e) return records Conc\u00e9ntrese en la declaraci\u00f3n try-except . \u00bfQu\u00e9 deber\u00eda hacer en el bloque except ? \u00bfDeber\u00eda imprimir un mensaje de advertencia? try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"No se pudo analizar :\", line) print(\"Raz\u00f3n :\", e) \u00bfO lo ignoras en silencio? try: records.append(split(line,types,names,delimiter)) except ValueError as e: pass Ninguna soluci\u00f3n es satisfactoria porque a menudo se desean ambos comportamientos (seleccionables por el usuario). Uso del registro El m\u00f3dulo logging puede solucionar este problema. # fileparse.py import logging log = logging.getLogger(__name__) def parse(f,types=None,names=None,delimiter=None): ... try: records.append(split(line,types,names,delimiter)) except ValueError as e: log.warning(\"No se pudo analizar: %s\", line) log.debug(\"Raz\u00f3n: %s\", e) Se modifica el c\u00f3digo para emitir mensajes de advertencia o un objeto Logger especial. El creado con logging.getLogger(__name__) . Conceptos b\u00e1sicos de registro Crear un objeto de registro. log = logging.getLogger(name) # name es una cadena Emisi\u00f3n de mensajes de registro. log.critical(message [, args]) log.error(message [, args]) log.warning(message [, args]) log.info(message [, args]) log.debug(message [, args]) Cada m\u00e9todo representa un nivel de gravedad diferente. Todos ellos crean un mensaje de registro formateado. args se utiliza con el operador % para crear el mensaje. logmsg = message % args # Escrito en el registro Configuraci\u00f3n del registro El comportamiento del registro se configura por separado. # main.py ... if __name__ == '__main__': import logging logging.basicConfig( filename = 'app.log', # Archivo de salida del registro level = logging.INFO, # Nivel de salida ) Normalmente, esta es una configuraci\u00f3n \u00fanica al iniciar el programa. La configuraci\u00f3n es independiente del c\u00f3digo que realiza las llamadas de registro. Comentarios El registro es altamente configurable. Puede ajustar cada aspecto del mismo: archivos de salida, niveles, formatos de mensajes, etc. Sin embargo, el c\u00f3digo que usa el registro no tiene que preocuparse por eso. Ejercicios Ejercicio 8.2: Agregar registro a un m\u00f3dulo En fileparse.py , hay un manejo de errores relacionado con excepciones causadas por una entrada incorrecta. Se parece a esto: # fileparse.py import csv import logging log = logging.getLogger(__name__) def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Analiza un archivo CSV en una lista de registros con conversi\u00f3n de tipo. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # Leer los encabezados de archivo (si los hay) headers = next(rows) if has_headers else [] # Si se han seleccionado columnas espec\u00edficas, crear \u00edndices para filtrar y establecer columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # Omitir filas sin datos continue # Si se seleccionan \u00edndices de columnas espec\u00edficos, seleccionarlos if select: row = [ row[index] for index in indices] # Aplicar conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: log.warning(\"Row %d: No se puede analizar %s\", rowno, row) log.debug(\"Row %d: Rez\u00f3n %s\", rowno, e) continue # Crea un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Ahora que has realizado estos cambios, prueba a usar Parte de tu c\u00f3digo contiene datos err\u00f3neos. >>> import report >>> a = report.read_portfolio('Data/missing.csv') Row 4: Bad row: ['MSFT', '', '51.23'] Row 7: Bad row: ['IBM', '', '70.44'] >>> Si no hace nada, solo obtendr\u00e1 mensajes de registro para el nivel WARNING y superiores. La salida se ver\u00e1 como simples declaraciones de impresi\u00f3n. Sin embargo, Si configura el m\u00f3dulo de registro, obtendr\u00e1 informaci\u00f3n adicional sobre los niveles de registro, el m\u00f3dulo y m\u00e1s. Escriba estos pasos para comprobarlo: >>> import logging >>> logging.basicConfig() >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] >>> Notar\u00e1s que no ves el resultado de la operaci\u00f3n log.debug() . Escriba esto para cambiar el nivel. >>> logging.getLogger('fileparse').setLevel(logging.DEBUG) >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] DEBUG:fileparse:Row 4: Reason: invalid literal for int() with base 10: '' WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] DEBUG:fileparse:Row 7: Reason: invalid literal for int() with base 10: '' >>> Desactive todos los mensajes de registro, excepto los m\u00e1s cr\u00edticos: >>> logging.getLogger ('fileparse').setLevel(logging.CRITICAL) >>> a = report.read_portfolio('Datos/missing.csv') >>> Ejercicio 8.3: Agregar registros a un programa Para agregar registro a una aplicaci\u00f3n, necesita tener alg\u00fan mecanismo para inicializar el m\u00f3dulo de registro en el m\u00f3dulo principal. Una forma de hacerlo es incluir un c\u00f3digo de configuraci\u00f3n similar a este: # Este archivo establece la configuraci\u00f3n b\u00e1sica del m\u00f3dulo de registro. # Cambie la configuraci\u00f3n aqu\u00ed para ajustar la salida del registro seg\u00fan sea necesario. import logging logging.basicConfig( filename = 'app.log', # Nombre del archivo de registro (omitir para usar stderr) filemode = 'w', # Modo de archivo (use 'a' para agregar) level = logging.WARNING, # Nivel de registro DEBUG, INFO, WARNING, ERROR, or CRITICAL ) Nuevamente, deber\u00e1 colocar esto en alg\u00fan lugar de los pasos de inicio de su programa. Por ejemplo, \u00bfd\u00f3nde colocar\u00eda esto en su programa report.py ? Contenido | Anterior (8.1 Pruebas) | Pr\u00f3ximo (8.3 Depuraci\u00f3n)","title":"02_Logging"},{"location":"08_Testing_debugging/02_Logging/#82-registro-manejo-de-errores-y-diagnosticos","text":"Esta secci\u00f3n presenta brevemente el m\u00f3dulo de registro.","title":"8.2 Registro, manejo de errores y diagn\u00f3sticos"},{"location":"08_Testing_debugging/02_Logging/#modulo-de-registro","text":"El m\u00f3dulo logging es un m\u00f3dulo de la biblioteca est\u00e1ndar para registrar informaci\u00f3n de diagn\u00f3stico. Tambi\u00e9n es un m\u00f3dulo muy grande con muchas funciones sofisticadas. Mostraremos un ejemplo simple para ilustrar su utilidad.","title":"M\u00f3dulo de registro"},{"location":"08_Testing_debugging/02_Logging/#excepciones-revisitadas","text":"En los ejercicios, escribimos una funci\u00f3n parse() que se parec\u00eda a esto: # fileparse.py def parse(f, types=None, names=None, delimiter=None): records = [] for line in f: line = line.strip() if not line: continue try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"No se pudo analizar :\", line) print(\"Raz\u00f3n :\", e) return records Conc\u00e9ntrese en la declaraci\u00f3n try-except . \u00bfQu\u00e9 deber\u00eda hacer en el bloque except ? \u00bfDeber\u00eda imprimir un mensaje de advertencia? try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"No se pudo analizar :\", line) print(\"Raz\u00f3n :\", e) \u00bfO lo ignoras en silencio? try: records.append(split(line,types,names,delimiter)) except ValueError as e: pass Ninguna soluci\u00f3n es satisfactoria porque a menudo se desean ambos comportamientos (seleccionables por el usuario).","title":"Excepciones revisitadas"},{"location":"08_Testing_debugging/02_Logging/#uso-del-registro","text":"El m\u00f3dulo logging puede solucionar este problema. # fileparse.py import logging log = logging.getLogger(__name__) def parse(f,types=None,names=None,delimiter=None): ... try: records.append(split(line,types,names,delimiter)) except ValueError as e: log.warning(\"No se pudo analizar: %s\", line) log.debug(\"Raz\u00f3n: %s\", e) Se modifica el c\u00f3digo para emitir mensajes de advertencia o un objeto Logger especial. El creado con logging.getLogger(__name__) .","title":"Uso del registro"},{"location":"08_Testing_debugging/02_Logging/#conceptos-basicos-de-registro","text":"Crear un objeto de registro. log = logging.getLogger(name) # name es una cadena Emisi\u00f3n de mensajes de registro. log.critical(message [, args]) log.error(message [, args]) log.warning(message [, args]) log.info(message [, args]) log.debug(message [, args]) Cada m\u00e9todo representa un nivel de gravedad diferente. Todos ellos crean un mensaje de registro formateado. args se utiliza con el operador % para crear el mensaje. logmsg = message % args # Escrito en el registro","title":"Conceptos b\u00e1sicos de registro"},{"location":"08_Testing_debugging/02_Logging/#configuracion-del-registro","text":"El comportamiento del registro se configura por separado. # main.py ... if __name__ == '__main__': import logging logging.basicConfig( filename = 'app.log', # Archivo de salida del registro level = logging.INFO, # Nivel de salida ) Normalmente, esta es una configuraci\u00f3n \u00fanica al iniciar el programa. La configuraci\u00f3n es independiente del c\u00f3digo que realiza las llamadas de registro.","title":"Configuraci\u00f3n del registro"},{"location":"08_Testing_debugging/02_Logging/#comentarios","text":"El registro es altamente configurable. Puede ajustar cada aspecto del mismo: archivos de salida, niveles, formatos de mensajes, etc. Sin embargo, el c\u00f3digo que usa el registro no tiene que preocuparse por eso.","title":"Comentarios"},{"location":"08_Testing_debugging/02_Logging/#ejercicios","text":"","title":"Ejercicios"},{"location":"08_Testing_debugging/02_Logging/#ejercicio-82-agregar-registro-a-un-modulo","text":"En fileparse.py , hay un manejo de errores relacionado con excepciones causadas por una entrada incorrecta. Se parece a esto: # fileparse.py import csv import logging log = logging.getLogger(__name__) def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Analiza un archivo CSV en una lista de registros con conversi\u00f3n de tipo. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # Leer los encabezados de archivo (si los hay) headers = next(rows) if has_headers else [] # Si se han seleccionado columnas espec\u00edficas, crear \u00edndices para filtrar y establecer columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # Omitir filas sin datos continue # Si se seleccionan \u00edndices de columnas espec\u00edficos, seleccionarlos if select: row = [ row[index] for index in indices] # Aplicar conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: log.warning(\"Row %d: No se puede analizar %s\", rowno, row) log.debug(\"Row %d: Rez\u00f3n %s\", rowno, e) continue # Crea un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Ahora que has realizado estos cambios, prueba a usar Parte de tu c\u00f3digo contiene datos err\u00f3neos. >>> import report >>> a = report.read_portfolio('Data/missing.csv') Row 4: Bad row: ['MSFT', '', '51.23'] Row 7: Bad row: ['IBM', '', '70.44'] >>> Si no hace nada, solo obtendr\u00e1 mensajes de registro para el nivel WARNING y superiores. La salida se ver\u00e1 como simples declaraciones de impresi\u00f3n. Sin embargo, Si configura el m\u00f3dulo de registro, obtendr\u00e1 informaci\u00f3n adicional sobre los niveles de registro, el m\u00f3dulo y m\u00e1s. Escriba estos pasos para comprobarlo: >>> import logging >>> logging.basicConfig() >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] >>> Notar\u00e1s que no ves el resultado de la operaci\u00f3n log.debug() . Escriba esto para cambiar el nivel. >>> logging.getLogger('fileparse').setLevel(logging.DEBUG) >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] DEBUG:fileparse:Row 4: Reason: invalid literal for int() with base 10: '' WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] DEBUG:fileparse:Row 7: Reason: invalid literal for int() with base 10: '' >>> Desactive todos los mensajes de registro, excepto los m\u00e1s cr\u00edticos: >>> logging.getLogger ('fileparse').setLevel(logging.CRITICAL) >>> a = report.read_portfolio('Datos/missing.csv') >>>","title":"Ejercicio 8.2: Agregar registro a un m\u00f3dulo"},{"location":"08_Testing_debugging/02_Logging/#ejercicio-83-agregar-registros-a-un-programa","text":"Para agregar registro a una aplicaci\u00f3n, necesita tener alg\u00fan mecanismo para inicializar el m\u00f3dulo de registro en el m\u00f3dulo principal. Una forma de hacerlo es incluir un c\u00f3digo de configuraci\u00f3n similar a este: # Este archivo establece la configuraci\u00f3n b\u00e1sica del m\u00f3dulo de registro. # Cambie la configuraci\u00f3n aqu\u00ed para ajustar la salida del registro seg\u00fan sea necesario. import logging logging.basicConfig( filename = 'app.log', # Nombre del archivo de registro (omitir para usar stderr) filemode = 'w', # Modo de archivo (use 'a' para agregar) level = logging.WARNING, # Nivel de registro DEBUG, INFO, WARNING, ERROR, or CRITICAL ) Nuevamente, deber\u00e1 colocar esto en alg\u00fan lugar de los pasos de inicio de su programa. Por ejemplo, \u00bfd\u00f3nde colocar\u00eda esto en su programa report.py ? Contenido | Anterior (8.1 Pruebas) | Pr\u00f3ximo (8.3 Depuraci\u00f3n)","title":"Ejercicio 8.3: Agregar registros a un programa"},{"location":"08_Testing_debugging/03_Debugging/","text":"Contenido | Anterior (8.2 Registro, manejo de errores y diagn\u00f3sticos) | Pr\u00f3ximo (9 Paquetes) 8.3 Depuraci\u00f3n Consejos de depuraci\u00f3n Entonces, su programa se ha bloqueado... bash % python3 blah.py Traceback (\u00faltima llamada m\u00e1s reciente): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) AttributeError: el objeto 'int' no tiene el atributo 'append' \u00bfY ahora qu\u00e9?! Lectura de los tracebacks La \u00faltima l\u00ednea es la causa espec\u00edfica del fallo. bash % python3 blah.py Traceback (most recent call last): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) # Causa del fallo AttributeError: el objeto 'int' no tiene el atributo 'append' Sin embargo, no siempre es f\u00e1cil de leer o comprender. CONSEJO PROFESIONAL: Pegue el traceback completo en Google. Uso del REPL Use la opci\u00f3n -i para mantener Python activo al ejecutar un script. bash % python3 -i blah.py Traceback (most recent call last): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) AttributeError: el objeto 'int' no tiene el atributo 'append' >>> Conserva el estado del int\u00e9rprete. Eso significa que puede seguir investigando despu\u00e9s de la falla. Verificando los valores de las variables y otros estados. Depuraci\u00f3n con Print La depuraci\u00f3n con print() es bastante com\u00fan. Consejo: aseg\u00farate de usar repr() def spam(x): print('DEBUG:', repr(x)) ... repr() te muestra una representaci\u00f3n precisa de un valor. No la buena salida impresa. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>> El depurador de Python Puedes iniciar manualmente el depurador dentro de un programa. def some_function(): ... breakpoint() # Ingresa al depurador (Python 3.7+) ... Esto inicia el depurador en la llamada breakpoint() . En versiones anteriores de Python, esto se hac\u00eda. A veces ver\u00e1s que se menciona esto en otras gu\u00edas de depuraci\u00f3n. import pdb ... pdb.set_trace() # En lugar de `breakpoint()` ... Ejecutar bajo el depurador Tambi\u00e9n puedes ejecutar un programa completo bajo el depurador. bash % python3 -m pdb someprogram.py Ingresar\u00e1 autom\u00e1ticamente al depurador antes de la primera declaraci\u00f3n, lo que te permitir\u00e1 establecer puntos de interrupci\u00f3n y cambiar la configuraci\u00f3n. Comandos comunes del depurador: (Pdb) help # Obtener ayuda (Pdb) w(here) # Imprimir seguimiento de la pila (Pdb) d(own) # Bajar un nivel de pila (Pdb) u(p) # Subir un nivel de pila (Pdb) b(reak) loc # Establecer un punto de interrupci\u00f3n (Pdb) s(tep) # Ejecutar una instrucci\u00f3n (Pdb) c(ontinue) # Continuar la ejecuci\u00f3n (Pdb) l(ist) # Listar el c\u00f3digo fuente (Pdb) a(rgs) # Imprimir los argumentos de la funci\u00f3n actual (Pdb) !statement # Ejecutar la instrucci\u00f3n Para los puntos de interrupci\u00f3n, la ubicaci\u00f3n es una de las siguientes: (Pdb) b 45 # L\u00ednea 45 en el archivo actual (Pdb) b file.py:45 # L\u00ednea 45 en file.py (Pdb) b foo # Funci\u00f3n foo() en el archivo actual (Pdb) b module.foo # Funci\u00f3n foo() en un m\u00f3dulo Ejercicios Ejercicio 8.4: \u00bfErrores? \u00bfQu\u00e9 errores? Funciona. \u00a1Env\u00edalo! Contenido | Anterior (8.2 Registro, manejo de errores y diagn\u00f3sticos) | Pr\u00f3ximo (9 Paquetes)","title":"03_Debugging"},{"location":"08_Testing_debugging/03_Debugging/#83-depuracion","text":"","title":"8.3 Depuraci\u00f3n"},{"location":"08_Testing_debugging/03_Debugging/#consejos-de-depuracion","text":"Entonces, su programa se ha bloqueado... bash % python3 blah.py Traceback (\u00faltima llamada m\u00e1s reciente): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) AttributeError: el objeto 'int' no tiene el atributo 'append' \u00bfY ahora qu\u00e9?!","title":"Consejos de depuraci\u00f3n"},{"location":"08_Testing_debugging/03_Debugging/#lectura-de-los-tracebacks","text":"La \u00faltima l\u00ednea es la causa espec\u00edfica del fallo. bash % python3 blah.py Traceback (most recent call last): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) # Causa del fallo AttributeError: el objeto 'int' no tiene el atributo 'append' Sin embargo, no siempre es f\u00e1cil de leer o comprender. CONSEJO PROFESIONAL: Pegue el traceback completo en Google.","title":"Lectura de los tracebacks"},{"location":"08_Testing_debugging/03_Debugging/#uso-del-repl","text":"Use la opci\u00f3n -i para mantener Python activo al ejecutar un script. bash % python3 -i blah.py Traceback (most recent call last): Archivo \"blah.py\", l\u00ednea 13, en ? foo() Archivo \"blah.py\", l\u00ednea 10, en foo bar() Archivo \"blah.py\", l\u00ednea 7, en bar spam() Archivo \"blah.py\", 4, en spam l\u00ednea x.append(3) AttributeError: el objeto 'int' no tiene el atributo 'append' >>> Conserva el estado del int\u00e9rprete. Eso significa que puede seguir investigando despu\u00e9s de la falla. Verificando los valores de las variables y otros estados.","title":"Uso del REPL"},{"location":"08_Testing_debugging/03_Debugging/#depuracion-con-print","text":"La depuraci\u00f3n con print() es bastante com\u00fan. Consejo: aseg\u00farate de usar repr() def spam(x): print('DEBUG:', repr(x)) ... repr() te muestra una representaci\u00f3n precisa de un valor. No la buena salida impresa. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>>","title":"Depuraci\u00f3n con Print"},{"location":"08_Testing_debugging/03_Debugging/#el-depurador-de-python","text":"Puedes iniciar manualmente el depurador dentro de un programa. def some_function(): ... breakpoint() # Ingresa al depurador (Python 3.7+) ... Esto inicia el depurador en la llamada breakpoint() . En versiones anteriores de Python, esto se hac\u00eda. A veces ver\u00e1s que se menciona esto en otras gu\u00edas de depuraci\u00f3n. import pdb ... pdb.set_trace() # En lugar de `breakpoint()` ...","title":"El depurador de Python"},{"location":"08_Testing_debugging/03_Debugging/#ejecutar-bajo-el-depurador","text":"Tambi\u00e9n puedes ejecutar un programa completo bajo el depurador. bash % python3 -m pdb someprogram.py Ingresar\u00e1 autom\u00e1ticamente al depurador antes de la primera declaraci\u00f3n, lo que te permitir\u00e1 establecer puntos de interrupci\u00f3n y cambiar la configuraci\u00f3n. Comandos comunes del depurador: (Pdb) help # Obtener ayuda (Pdb) w(here) # Imprimir seguimiento de la pila (Pdb) d(own) # Bajar un nivel de pila (Pdb) u(p) # Subir un nivel de pila (Pdb) b(reak) loc # Establecer un punto de interrupci\u00f3n (Pdb) s(tep) # Ejecutar una instrucci\u00f3n (Pdb) c(ontinue) # Continuar la ejecuci\u00f3n (Pdb) l(ist) # Listar el c\u00f3digo fuente (Pdb) a(rgs) # Imprimir los argumentos de la funci\u00f3n actual (Pdb) !statement # Ejecutar la instrucci\u00f3n Para los puntos de interrupci\u00f3n, la ubicaci\u00f3n es una de las siguientes: (Pdb) b 45 # L\u00ednea 45 en el archivo actual (Pdb) b file.py:45 # L\u00ednea 45 en file.py (Pdb) b foo # Funci\u00f3n foo() en el archivo actual (Pdb) b module.foo # Funci\u00f3n foo() en un m\u00f3dulo","title":"Ejecutar bajo el depurador"},{"location":"08_Testing_debugging/03_Debugging/#ejercicios","text":"","title":"Ejercicios"},{"location":"08_Testing_debugging/03_Debugging/#ejercicio-84-errores-que-errores","text":"Funciona. \u00a1Env\u00edalo! Contenido | Anterior (8.2 Registro, manejo de errores y diagn\u00f3sticos) | Pr\u00f3ximo (9 Paquetes)","title":"Ejercicio 8.4: \u00bfErrores? \u00bfQu\u00e9 errores?"},{"location":"09_Packages/00_Overview/","text":"Contenido | Anterior (8. Pruebas, registro y depuraci\u00f3n) 9 Paquetes Concluimos el curso con algunos detalles sobre c\u00f3mo organizar su c\u00f3digo en una estructura de paquete. Tambi\u00e9n analizaremos la instalaci\u00f3n de paquetes de terceros y la preparaci\u00f3n para entregar su propio c\u00f3digo a otros. El tema del empaquetado es una parte en constante evoluci\u00f3n y excesivamente compleja del desarrollo de Python. En lugar de centrarse en herramientas espec\u00edficas, el enfoque principal de esta secci\u00f3n est\u00e1 en algunos principios generales de organizaci\u00f3n de c\u00f3digo que resultar\u00e1n \u00fatiles sin importar qu\u00e9 herramientas utilice m\u00e1s adelante para entregar c\u00f3digo o administrar dependencias. 9.1 Paquetes 9.2 M\u00f3dulos de terceros 9.3 Entrega tu c\u00f3digo a terceross Contenido | Anterior (8. Pruebas, registro y depuraci\u00f3n)","title":"00_Overview"},{"location":"09_Packages/00_Overview/#9-paquetes","text":"Concluimos el curso con algunos detalles sobre c\u00f3mo organizar su c\u00f3digo en una estructura de paquete. Tambi\u00e9n analizaremos la instalaci\u00f3n de paquetes de terceros y la preparaci\u00f3n para entregar su propio c\u00f3digo a otros. El tema del empaquetado es una parte en constante evoluci\u00f3n y excesivamente compleja del desarrollo de Python. En lugar de centrarse en herramientas espec\u00edficas, el enfoque principal de esta secci\u00f3n est\u00e1 en algunos principios generales de organizaci\u00f3n de c\u00f3digo que resultar\u00e1n \u00fatiles sin importar qu\u00e9 herramientas utilice m\u00e1s adelante para entregar c\u00f3digo o administrar dependencias. 9.1 Paquetes 9.2 M\u00f3dulos de terceros 9.3 Entrega tu c\u00f3digo a terceross Contenido | Anterior (8. Pruebas, registro y depuraci\u00f3n)","title":"9 Paquetes"},{"location":"09_Packages/01_Packages/","text":"Contenido | Anterior (8.3 Depuraci\u00f3n) | Pr\u00f3ximo (9.2 M\u00f3dulos de terceros) 9.1 Paquetes Si escribe un programa m\u00e1s grande, no querr\u00e1 organizarlo como una gran colecci\u00f3n de archivos independientes en el nivel superior. Esta secci\u00f3n presenta el concepto de paquete. M\u00f3dulos Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... Una declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hola') ... Paquetes vs. m\u00f3dulos Para colecciones de c\u00f3digo m\u00e1s grandes, es com\u00fan organizar los m\u00f3dulos en un paquete. # Desde esto pcost.py report.py fileparse.py # a esto porty/ __init__.py pcost.py report.py fileparse.py Eliges un nombre y creas un directorio de nivel superior. porty en el ejemplo anterior (claramente elegir este nombre es el primer paso m\u00e1s importante). Agrega un archivo __init__.py al directorio. Puede estar vac\u00edo. Coloca tus archivos fuente en el directorio. Uso de un paquete Un paquete sirve como un espacio de nombres para las importaciones. Esto significa que ahora hay importaciones de varios niveles. import porty.report port = porty.report.read_portfolio('Data/portfolio.csv') Existen otras variaciones de las declaraciones de importaci\u00f3n. from porty import report port = report.read_portfolio('Data/portfolio.csv') from porty.report import read_portfolio port = read_portfolio('Data/portfolio.csv') Dos problemas Hay dos problemas principales con este enfoque. Las importaciones entre archivos del mismo paquete se interrumpen. Los scripts principales ubicados dentro del paquete se interrumpen. B\u00e1sicamente, todo se interrumpe. Pero, aparte de eso, funciona. Problema: Importaciones Las importaciones entre archivos del mismo paquete ahora deben incluir el nombre del paquete en la importaci\u00f3n . Recuerde la estructura. porty/ __init__.py pcost.py report.py fileparse.py Ejemplo de importaci\u00f3n modificado. # report.py from porty import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Todas las importaciones son absolutas , no relativas. # report.py import fileparse # FALLA. fileparse not found ... Importaciones relativas En lugar de usar directamente el nombre del paquete, puede usar . para hacer referencia al paquete actual. # report.py from . import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Sintaxis: from . import modname Esto facilita cambiar el nombre del paquete. Problema: Scripts principales Ejecutar un subm\u00f3dulo de paquete como un script principal falla. bash % python3 porty/pcost.py # FALLA ... Raz\u00f3n: est\u00e1s ejecutando Python en un solo archivo y Python no ve el resto de la estructura del paquete correctamente ( sys.path es incorrecto). Todas las importaciones fallan. Para solucionar esto, debes ejecutar tu programa de una manera diferente, usando la opci\u00f3n -m . bash % python3 -m porty.pcost # FUNCIONA ... Archivos __init__.py El prop\u00f3sito principal de estos archivos es unir m\u00f3dulos. Ejemplo: consolidaci\u00f3n de funciones # porty/__init__.py from .pcost import portfolio_cost from .report import portfolio_report Esto hace que los nombres aparezcan en el nivel superior al importar. from porty import portfolio_cost portfolio_cost('portfolio.csv') En lugar de usar las importaciones multinivel. from porty import pcost pcost.portfolio_cost('portfolio.csv') Otra soluci\u00f3n para los scripts Como se indic\u00f3, ahora debe usar -m package.module para ejecutar scripts dentro de su paquete. bash % python3 -m porty.pcost portfolio.csv Existe otra alternativa: escriba un nuevo script de nivel superior. #!/usr/bin/env python # pcost.py import porty.pcost import sys porty.pcost.main(sys.argv) Este script se encuentra fuera del paquete. Por ejemplo, si observamos la estructura del directorio: pcost.py # script de nivel superior porty/ # directorio de paquetes __init__.py pcost.py ... Estructura de la aplicaci\u00f3n La organizaci\u00f3n del c\u00f3digo y la estructura de archivos son clave para la capacidad de mantenimiento de una aplicaci\u00f3n. No existe un enfoque \"universal\" para Python. Sin embargo, una estructura que funciona para muchos problemas es algo como esto. porty-app/ README.txt script.py # SCRIPT porty/ # C\u00d3DIGO DE LA BIBLIOTECA __init__.py pcost.py report.py fileparse.py El porty-app de nivel superior es un contenedor para todo lo dem\u00e1s: documentaci\u00f3n, scripts de nivel superior, ejemplos, etc. Nuevamente, los scripts de nivel superior (si los hay) deben existir fuera del paquete de c\u00f3digo. Un nivel por encima. #!/usr/bin/env python # porty-app/script.py import sys import porty porty.report.main(sys.argv) Ejercicios En este punto, tienes un directorio con varios programas: pcost.py # calcula el costo de la cartera report.py # crea un informe ticker.py # produce un ticker de acciones en tiempo real Hay una variedad de m\u00f3dulos de soporte con otras funciones: stock.py # Clase Stock portfolio.py # Clase Portfolio fileparse.py # An\u00e1lisis CSV tableformat.py # Tablas formateadas follow.py # Seguimiento de un archivo de registro typedproperty.py # Propiedades de clase tipificadas En este ejercicio, vamos a limpiar el c\u00f3digo y ponerlo en un paquete com\u00fan. Ejercicio 9.1: Crear un paquete simple Cree un directorio llamado porty/ y coloque todos los archivos de Python anteriores en \u00e9l. Adem\u00e1s, cree un archivo __init__.py vac\u00edo y col\u00f3quelo en el directorio. Deber\u00eda tener un directorio de archivos como este: porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Elimine el archivo __pycache__ que se encuentra en su directorio. Este contiene m\u00f3dulos de Python precompilados de antes. Queremos comenzar de nuevo. Intente importar algunos de los m\u00f3dulos del paquete: >>> import porty.report >>> import porty.pcost >>> import porty.ticker Si estas importaciones fallan, vaya al archivo apropiado y corrija las importaciones del m\u00f3dulo para incluir una importaci\u00f3n relativa al paquete. Por ejemplo, una declaraci\u00f3n como import fileparse podr\u00eda cambiar a lo siguiente: # report.py from . import fileparse ... Si tiene una declaraci\u00f3n como from fileparse import parse_csv , cambie el c\u00f3digo a lo siguiente: # report.py from .fileparse import parse_csv ... Ejercicio 9.2: Crear un directorio de aplicaci\u00f3n Poner todo el c\u00f3digo en un \"paquete\" no suele ser suficiente para una aplicaci\u00f3n. A veces hay archivos de soporte, documentaci\u00f3n, scripts y otras cosas. Estos archivos deben existir FUERA del directorio porty/ que cre\u00f3 anteriormente. Cree un nuevo directorio llamado porty-app . Mueva el directorio porty que cre\u00f3 en el Ejercicio 9.1 a ese directorio. Copie los archivos de prueba Data/portfolio.csv y Data/prices.csv en este directorio. Adem\u00e1s, cree un archivo README.txt con informaci\u00f3n sobre usted. Ahora, su c\u00f3digo deber\u00eda estar organizado de la siguiente manera: porty-app/ portfolio.csv prices.csv README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Para ejecutar su c\u00f3digo, debe asegurarse de estar trabajando en el directorio de nivel superior porty-app/ . Por ejemplo, desde la terminal: bash % cd porty-app bash % python3 >>> import porty.report >>> Intente ejecutar algunos de sus scripts anteriores como un programa principal: bash % cd porty-app bash % python3 -m porty.report portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash % Ejercicio 9.3: Scripts de nivel superior Usar el comando python -m suele ser un poco extra\u00f1o. Es posible que desee escribir un script de nivel superior que simplemente se ocupe de las rarezas de los paquetes. Cree un script print-report.py que produzca el informe anterior: #!/usr/bin/env python3 # print-report.py import sys from porty.report import main main(sys.argv) Coloque este script en el directorio de nivel superior porty-app/ . Aseg\u00farate de que puedes ejecutarlo en esa ubicaci\u00f3n: bash % cd porty-app bash % python3 print-report.py portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash % Tu c\u00f3digo final ahora deber\u00eda estar estructurado de manera similar a esto: porty-app/ portfolio.csv prices.csv print-report.py README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Contenido | Anterior (8.3 Depuraci\u00f3n) | Pr\u00f3ximo (9.2 M\u00f3dulos de terceros)","title":"01_Packages"},{"location":"09_Packages/01_Packages/#91-paquetes","text":"Si escribe un programa m\u00e1s grande, no querr\u00e1 organizarlo como una gran colecci\u00f3n de archivos independientes en el nivel superior. Esta secci\u00f3n presenta el concepto de paquete.","title":"9.1 Paquetes"},{"location":"09_Packages/01_Packages/#modulos","text":"Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... Una declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hola') ...","title":"M\u00f3dulos"},{"location":"09_Packages/01_Packages/#paquetes-vs-modulos","text":"Para colecciones de c\u00f3digo m\u00e1s grandes, es com\u00fan organizar los m\u00f3dulos en un paquete. # Desde esto pcost.py report.py fileparse.py # a esto porty/ __init__.py pcost.py report.py fileparse.py Eliges un nombre y creas un directorio de nivel superior. porty en el ejemplo anterior (claramente elegir este nombre es el primer paso m\u00e1s importante). Agrega un archivo __init__.py al directorio. Puede estar vac\u00edo. Coloca tus archivos fuente en el directorio.","title":"Paquetes vs. m\u00f3dulos"},{"location":"09_Packages/01_Packages/#uso-de-un-paquete","text":"Un paquete sirve como un espacio de nombres para las importaciones. Esto significa que ahora hay importaciones de varios niveles. import porty.report port = porty.report.read_portfolio('Data/portfolio.csv') Existen otras variaciones de las declaraciones de importaci\u00f3n. from porty import report port = report.read_portfolio('Data/portfolio.csv') from porty.report import read_portfolio port = read_portfolio('Data/portfolio.csv')","title":"Uso de un paquete"},{"location":"09_Packages/01_Packages/#dos-problemas","text":"Hay dos problemas principales con este enfoque. Las importaciones entre archivos del mismo paquete se interrumpen. Los scripts principales ubicados dentro del paquete se interrumpen. B\u00e1sicamente, todo se interrumpe. Pero, aparte de eso, funciona.","title":"Dos problemas"},{"location":"09_Packages/01_Packages/#problema-importaciones","text":"Las importaciones entre archivos del mismo paquete ahora deben incluir el nombre del paquete en la importaci\u00f3n . Recuerde la estructura. porty/ __init__.py pcost.py report.py fileparse.py Ejemplo de importaci\u00f3n modificado. # report.py from porty import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Todas las importaciones son absolutas , no relativas. # report.py import fileparse # FALLA. fileparse not found ...","title":"Problema: Importaciones"},{"location":"09_Packages/01_Packages/#importaciones-relativas","text":"En lugar de usar directamente el nombre del paquete, puede usar . para hacer referencia al paquete actual. # report.py from . import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Sintaxis: from . import modname Esto facilita cambiar el nombre del paquete.","title":"Importaciones relativas"},{"location":"09_Packages/01_Packages/#problema-scripts-principales","text":"Ejecutar un subm\u00f3dulo de paquete como un script principal falla. bash % python3 porty/pcost.py # FALLA ... Raz\u00f3n: est\u00e1s ejecutando Python en un solo archivo y Python no ve el resto de la estructura del paquete correctamente ( sys.path es incorrecto). Todas las importaciones fallan. Para solucionar esto, debes ejecutar tu programa de una manera diferente, usando la opci\u00f3n -m . bash % python3 -m porty.pcost # FUNCIONA ...","title":"Problema: Scripts principales"},{"location":"09_Packages/01_Packages/#archivos-__init__py","text":"El prop\u00f3sito principal de estos archivos es unir m\u00f3dulos. Ejemplo: consolidaci\u00f3n de funciones # porty/__init__.py from .pcost import portfolio_cost from .report import portfolio_report Esto hace que los nombres aparezcan en el nivel superior al importar. from porty import portfolio_cost portfolio_cost('portfolio.csv') En lugar de usar las importaciones multinivel. from porty import pcost pcost.portfolio_cost('portfolio.csv')","title":"Archivos __init__.py"},{"location":"09_Packages/01_Packages/#otra-solucion-para-los-scripts","text":"Como se indic\u00f3, ahora debe usar -m package.module para ejecutar scripts dentro de su paquete. bash % python3 -m porty.pcost portfolio.csv Existe otra alternativa: escriba un nuevo script de nivel superior. #!/usr/bin/env python # pcost.py import porty.pcost import sys porty.pcost.main(sys.argv) Este script se encuentra fuera del paquete. Por ejemplo, si observamos la estructura del directorio: pcost.py # script de nivel superior porty/ # directorio de paquetes __init__.py pcost.py ...","title":"Otra soluci\u00f3n para los scripts"},{"location":"09_Packages/01_Packages/#estructura-de-la-aplicacion","text":"La organizaci\u00f3n del c\u00f3digo y la estructura de archivos son clave para la capacidad de mantenimiento de una aplicaci\u00f3n. No existe un enfoque \"universal\" para Python. Sin embargo, una estructura que funciona para muchos problemas es algo como esto. porty-app/ README.txt script.py # SCRIPT porty/ # C\u00d3DIGO DE LA BIBLIOTECA __init__.py pcost.py report.py fileparse.py El porty-app de nivel superior es un contenedor para todo lo dem\u00e1s: documentaci\u00f3n, scripts de nivel superior, ejemplos, etc. Nuevamente, los scripts de nivel superior (si los hay) deben existir fuera del paquete de c\u00f3digo. Un nivel por encima. #!/usr/bin/env python # porty-app/script.py import sys import porty porty.report.main(sys.argv)","title":"Estructura de la aplicaci\u00f3n"},{"location":"09_Packages/01_Packages/#ejercicios","text":"En este punto, tienes un directorio con varios programas: pcost.py # calcula el costo de la cartera report.py # crea un informe ticker.py # produce un ticker de acciones en tiempo real Hay una variedad de m\u00f3dulos de soporte con otras funciones: stock.py # Clase Stock portfolio.py # Clase Portfolio fileparse.py # An\u00e1lisis CSV tableformat.py # Tablas formateadas follow.py # Seguimiento de un archivo de registro typedproperty.py # Propiedades de clase tipificadas En este ejercicio, vamos a limpiar el c\u00f3digo y ponerlo en un paquete com\u00fan.","title":"Ejercicios"},{"location":"09_Packages/01_Packages/#ejercicio-91-crear-un-paquete-simple","text":"Cree un directorio llamado porty/ y coloque todos los archivos de Python anteriores en \u00e9l. Adem\u00e1s, cree un archivo __init__.py vac\u00edo y col\u00f3quelo en el directorio. Deber\u00eda tener un directorio de archivos como este: porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Elimine el archivo __pycache__ que se encuentra en su directorio. Este contiene m\u00f3dulos de Python precompilados de antes. Queremos comenzar de nuevo. Intente importar algunos de los m\u00f3dulos del paquete: >>> import porty.report >>> import porty.pcost >>> import porty.ticker Si estas importaciones fallan, vaya al archivo apropiado y corrija las importaciones del m\u00f3dulo para incluir una importaci\u00f3n relativa al paquete. Por ejemplo, una declaraci\u00f3n como import fileparse podr\u00eda cambiar a lo siguiente: # report.py from . import fileparse ... Si tiene una declaraci\u00f3n como from fileparse import parse_csv , cambie el c\u00f3digo a lo siguiente: # report.py from .fileparse import parse_csv ...","title":"Ejercicio 9.1: Crear un paquete simple"},{"location":"09_Packages/01_Packages/#ejercicio-92-crear-un-directorio-de-aplicacion","text":"Poner todo el c\u00f3digo en un \"paquete\" no suele ser suficiente para una aplicaci\u00f3n. A veces hay archivos de soporte, documentaci\u00f3n, scripts y otras cosas. Estos archivos deben existir FUERA del directorio porty/ que cre\u00f3 anteriormente. Cree un nuevo directorio llamado porty-app . Mueva el directorio porty que cre\u00f3 en el Ejercicio 9.1 a ese directorio. Copie los archivos de prueba Data/portfolio.csv y Data/prices.csv en este directorio. Adem\u00e1s, cree un archivo README.txt con informaci\u00f3n sobre usted. Ahora, su c\u00f3digo deber\u00eda estar organizado de la siguiente manera: porty-app/ portfolio.csv prices.csv README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Para ejecutar su c\u00f3digo, debe asegurarse de estar trabajando en el directorio de nivel superior porty-app/ . Por ejemplo, desde la terminal: bash % cd porty-app bash % python3 >>> import porty.report >>> Intente ejecutar algunos de sus scripts anteriores como un programa principal: bash % cd porty-app bash % python3 -m porty.report portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash %","title":"Ejercicio 9.2: Crear un directorio de aplicaci\u00f3n"},{"location":"09_Packages/01_Packages/#ejercicio-93-scripts-de-nivel-superior","text":"Usar el comando python -m suele ser un poco extra\u00f1o. Es posible que desee escribir un script de nivel superior que simplemente se ocupe de las rarezas de los paquetes. Cree un script print-report.py que produzca el informe anterior: #!/usr/bin/env python3 # print-report.py import sys from porty.report import main main(sys.argv) Coloque este script en el directorio de nivel superior porty-app/ . Aseg\u00farate de que puedes ejecutarlo en esa ubicaci\u00f3n: bash % cd porty-app bash % python3 print-report.py portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 bash % Tu c\u00f3digo final ahora deber\u00eda estar estructurado de manera similar a esto: porty-app/ portfolio.csv prices.csv print-report.py README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Contenido | Anterior (8.3 Depuraci\u00f3n) | Pr\u00f3ximo (9.2 M\u00f3dulos de terceros)","title":"Ejercicio 9.3: Scripts de nivel superior"},{"location":"09_Packages/02_Third_party/","text":"Contenido | Anterior (9.1 Paquetes) | Pr\u00f3ximo (9.3 Entrega tu c\u00f3digo a terceros) 9.2 M\u00f3dulos de terceros Python tiene una gran biblioteca de m\u00f3dulos integrados ( bater\u00edas incluidas ). Hay incluso m\u00e1s m\u00f3dulos de terceros. Cons\u00faltelos en el \u00cdndice de paquetes de Python o PyPi. O simplemente haga una b\u00fasqueda en Google de un tema espec\u00edfico. C\u00f3mo manejar dependencias de terceros es un tema en constante evoluci\u00f3n con Python. Esta secci\u00f3n simplemente cubre los conceptos b\u00e1sicos para ayudarlo a comprender c\u00f3mo funciona. La ruta de b\u00fasqueda de m\u00f3dulos sys.path es un directorio que contiene la lista de todos los directorios revisados \u200b\u200bpor la declaraci\u00f3n import . M\u00edralo: >>> import sys >>> sys.path ... mira el resultado... >>> Si importas algo y no est\u00e1 ubicado en uno de esos directorios, obtendr\u00e1s una excepci\u00f3n ImportError . M\u00f3dulos de la biblioteca est\u00e1ndar Los m\u00f3dulos de la biblioteca est\u00e1ndar de Python generalmente provienen de una ubicaci\u00f3n como /usr/local/lib/python3.6 . Puedes averiguarlo con certeza haciendo una prueba corta: >>> import re >>> re <module 're' from '/usr/local/lib/python3.6/re.py'> >>> Simplemente mirar un m\u00f3dulo en el REPL es un buen consejo de depuraci\u00f3n que debes conocer. Te mostrar\u00e1 la ubicaci\u00f3n del archivo. M\u00f3dulos de terceros Los m\u00f3dulos de terceros suelen estar ubicados en un directorio site-packages dedicado. Lo ver\u00e1s si realizas los mismos pasos que los anteriores: >>> import numpy >>> numpy <module 'numpy' from '/usr/local/lib/python3.6/site-packages/numpy/__init__.py'> >>> Nuevamente, mirar un m\u00f3dulo es un buen consejo de depuraci\u00f3n si est\u00e1s tratando de averiguar por qu\u00e9 algo relacionado con import no est\u00e1 funcionando como se esperaba. Instalaci\u00f3n de m\u00f3dulos La t\u00e9cnica m\u00e1s com\u00fan para instalar un m\u00f3dulo de terceros es usar pip . Por ejemplo: bash % python3 -m pip install packagename Este comando descargar\u00e1 el paquete y lo instalar\u00e1 en el directorio site-packages . Problemas Es posible que est\u00e9s usando una instalaci\u00f3n de Python que no controlas directamente. Una instalaci\u00f3n aprobada por la empresa Est\u00e1s usando la versi\u00f3n de Python que viene con el sistema operativo. Es posible que no tengas permiso para instalar paquetes globales en la computadora. Es posible que existan otras dependencias. Entornos virtuales Una soluci\u00f3n com\u00fan para los problemas de instalaci\u00f3n de paquetes es crear un denominado \"entorno virtual\" para ti mismo. Naturalmente, no existe una \"\u00fanica forma\" de hacerlo; de hecho, existen varias herramientas y t\u00e9cnicas que compiten entre s\u00ed. Sin embargo, si est\u00e1s usando una instalaci\u00f3n est\u00e1ndar de Python, puedes intentar escribir lo siguiente: bash % python3 -m venv mypython bash % Despu\u00e9s de unos minutos de espera, tendr\u00e1s un nuevo directorio mypython que es tu propia peque\u00f1a instalaci\u00f3n de Python. Dentro de ese directorio encontrar\u00e1s un directorio bin/ (Unix) o un directorio Scripts/ (Windows). Si ejecuta el script activate que se encuentra all\u00ed, \"activar\u00e1\" esta versi\u00f3n de Python, convirti\u00e9ndolo en el comando python predeterminado para el shell. Por ejemplo: # UNIX bash % source mypython/bin/activate (mypython) bash % # UNIX # Windows C:\\Users\\tu_nombre\\practical-python\\Work>cd porty-app C:\\Users\\tu_nombre\\practical-python\\Work\\porty-app> mypython\\Scripts\\activate (mypython) C:\\Users\\tu_nombre\\practical-python\\Work\\porty-app> Desde aqu\u00ed, ahora puede comenzar a instalar paquetes de Python por su cuenta. Por ejemplo: (mypython) bash % python3 -m pip install pandas ... Para experimentar y probar diferentes paquetes, un entorno virtual generalmente funcionar\u00e1 bien. Si, por otro lado, est\u00e1 creando una aplicaci\u00f3n y tiene dependencias de paquetes espec\u00edficas, ese es un problema ligeramente diferente. Manejo de dependencias de terceros en su aplicaci\u00f3n Si ha escrito una aplicaci\u00f3n y tiene dependencias de terceros espec\u00edficas, un desaf\u00edo se relaciona con la creaci\u00f3n y preservaci\u00f3n del entorno que incluye su c\u00f3digo y las dependencias. Lamentablemente, esta ha sido un \u00e1rea de gran confusi\u00f3n y cambios frecuentes durante la existencia de Python. Sigue evolucionando incluso ahora. En lugar de proporcionar informaci\u00f3n que seguramente quedar\u00e1 desactualizada pronto, le recomiendo que consulte la Gu\u00eda del usuario de empaquetado de Python . Ejercicios Ejercicio 9.4: Creaci\u00f3n de un entorno virtual Vea si puede recrear los pasos para crear un entorno virtual e instalar pandas en \u00e9l como se muestra arriba. Contenido | Anterior (9.1 Paquetes) | Pr\u00f3ximo (9.3 Entrega tu c\u00f3digo a terceros)","title":"02_Third_party"},{"location":"09_Packages/02_Third_party/#92-modulos-de-terceros","text":"Python tiene una gran biblioteca de m\u00f3dulos integrados ( bater\u00edas incluidas ). Hay incluso m\u00e1s m\u00f3dulos de terceros. Cons\u00faltelos en el \u00cdndice de paquetes de Python o PyPi. O simplemente haga una b\u00fasqueda en Google de un tema espec\u00edfico. C\u00f3mo manejar dependencias de terceros es un tema en constante evoluci\u00f3n con Python. Esta secci\u00f3n simplemente cubre los conceptos b\u00e1sicos para ayudarlo a comprender c\u00f3mo funciona.","title":"9.2 M\u00f3dulos de terceros"},{"location":"09_Packages/02_Third_party/#la-ruta-de-busqueda-de-modulos","text":"sys.path es un directorio que contiene la lista de todos los directorios revisados \u200b\u200bpor la declaraci\u00f3n import . M\u00edralo: >>> import sys >>> sys.path ... mira el resultado... >>> Si importas algo y no est\u00e1 ubicado en uno de esos directorios, obtendr\u00e1s una excepci\u00f3n ImportError .","title":"La ruta de b\u00fasqueda de m\u00f3dulos"},{"location":"09_Packages/02_Third_party/#modulos-de-la-biblioteca-estandar","text":"Los m\u00f3dulos de la biblioteca est\u00e1ndar de Python generalmente provienen de una ubicaci\u00f3n como /usr/local/lib/python3.6 . Puedes averiguarlo con certeza haciendo una prueba corta: >>> import re >>> re <module 're' from '/usr/local/lib/python3.6/re.py'> >>> Simplemente mirar un m\u00f3dulo en el REPL es un buen consejo de depuraci\u00f3n que debes conocer. Te mostrar\u00e1 la ubicaci\u00f3n del archivo.","title":"M\u00f3dulos de la biblioteca est\u00e1ndar"},{"location":"09_Packages/02_Third_party/#modulos-de-terceros","text":"Los m\u00f3dulos de terceros suelen estar ubicados en un directorio site-packages dedicado. Lo ver\u00e1s si realizas los mismos pasos que los anteriores: >>> import numpy >>> numpy <module 'numpy' from '/usr/local/lib/python3.6/site-packages/numpy/__init__.py'> >>> Nuevamente, mirar un m\u00f3dulo es un buen consejo de depuraci\u00f3n si est\u00e1s tratando de averiguar por qu\u00e9 algo relacionado con import no est\u00e1 funcionando como se esperaba.","title":"M\u00f3dulos de terceros"},{"location":"09_Packages/02_Third_party/#instalacion-de-modulos","text":"La t\u00e9cnica m\u00e1s com\u00fan para instalar un m\u00f3dulo de terceros es usar pip . Por ejemplo: bash % python3 -m pip install packagename Este comando descargar\u00e1 el paquete y lo instalar\u00e1 en el directorio site-packages .","title":"Instalaci\u00f3n de m\u00f3dulos"},{"location":"09_Packages/02_Third_party/#problemas","text":"Es posible que est\u00e9s usando una instalaci\u00f3n de Python que no controlas directamente. Una instalaci\u00f3n aprobada por la empresa Est\u00e1s usando la versi\u00f3n de Python que viene con el sistema operativo. Es posible que no tengas permiso para instalar paquetes globales en la computadora. Es posible que existan otras dependencias.","title":"Problemas"},{"location":"09_Packages/02_Third_party/#entornos-virtuales","text":"Una soluci\u00f3n com\u00fan para los problemas de instalaci\u00f3n de paquetes es crear un denominado \"entorno virtual\" para ti mismo. Naturalmente, no existe una \"\u00fanica forma\" de hacerlo; de hecho, existen varias herramientas y t\u00e9cnicas que compiten entre s\u00ed. Sin embargo, si est\u00e1s usando una instalaci\u00f3n est\u00e1ndar de Python, puedes intentar escribir lo siguiente: bash % python3 -m venv mypython bash % Despu\u00e9s de unos minutos de espera, tendr\u00e1s un nuevo directorio mypython que es tu propia peque\u00f1a instalaci\u00f3n de Python. Dentro de ese directorio encontrar\u00e1s un directorio bin/ (Unix) o un directorio Scripts/ (Windows). Si ejecuta el script activate que se encuentra all\u00ed, \"activar\u00e1\" esta versi\u00f3n de Python, convirti\u00e9ndolo en el comando python predeterminado para el shell. Por ejemplo: # UNIX bash % source mypython/bin/activate (mypython) bash % # UNIX # Windows C:\\Users\\tu_nombre\\practical-python\\Work>cd porty-app C:\\Users\\tu_nombre\\practical-python\\Work\\porty-app> mypython\\Scripts\\activate (mypython) C:\\Users\\tu_nombre\\practical-python\\Work\\porty-app> Desde aqu\u00ed, ahora puede comenzar a instalar paquetes de Python por su cuenta. Por ejemplo: (mypython) bash % python3 -m pip install pandas ... Para experimentar y probar diferentes paquetes, un entorno virtual generalmente funcionar\u00e1 bien. Si, por otro lado, est\u00e1 creando una aplicaci\u00f3n y tiene dependencias de paquetes espec\u00edficas, ese es un problema ligeramente diferente.","title":"Entornos virtuales"},{"location":"09_Packages/02_Third_party/#manejo-de-dependencias-de-terceros-en-su-aplicacion","text":"Si ha escrito una aplicaci\u00f3n y tiene dependencias de terceros espec\u00edficas, un desaf\u00edo se relaciona con la creaci\u00f3n y preservaci\u00f3n del entorno que incluye su c\u00f3digo y las dependencias. Lamentablemente, esta ha sido un \u00e1rea de gran confusi\u00f3n y cambios frecuentes durante la existencia de Python. Sigue evolucionando incluso ahora. En lugar de proporcionar informaci\u00f3n que seguramente quedar\u00e1 desactualizada pronto, le recomiendo que consulte la Gu\u00eda del usuario de empaquetado de Python .","title":"Manejo de dependencias de terceros en su aplicaci\u00f3n"},{"location":"09_Packages/02_Third_party/#ejercicios","text":"","title":"Ejercicios"},{"location":"09_Packages/02_Third_party/#ejercicio-94-creacion-de-un-entorno-virtual","text":"Vea si puede recrear los pasos para crear un entorno virtual e instalar pandas en \u00e9l como se muestra arriba. Contenido | Anterior (9.1 Paquetes) | Pr\u00f3ximo (9.3 Entrega tu c\u00f3digo a terceros)","title":"Ejercicio 9.4: Creaci\u00f3n de un entorno virtual"},{"location":"09_Packages/03_Distribution/","text":"Contenido | Anterior (9.2 M\u00f3dulos de terceros) | Pr\u00f3ximo (Fin) 9.3 Entrega tu c\u00f3digo a terceros En alg\u00fan momento, es posible que desee entregar su c\u00f3digo a otra persona, posiblemente solo a un compa\u00f1ero de trabajo. Esta secci\u00f3n proporciona la t\u00e9cnica m\u00e1s b\u00e1sica para hacerlo. Para obtener informaci\u00f3n m\u00e1s detallada, deber\u00e1 consultar la Gu\u00eda del usuario de empaquetado de Python . Creaci\u00f3n de un archivo setup.py Agregue un archivo setup.py al nivel superior del directorio de su proyecto. # setup.py import setuptools setuptools.setup( name=\"porty\", version=\"0.0.1\", author=\"Your Name\", author_email=\"you@example.com\", description=\"Practical Python Code\", packages=setuptools.find_packages(), ) Creaci\u00f3n de MANIFEST.in Si hay archivos adicionales asociados con su proyecto, especif\u00edquelos con un archivo MANIFEST.in . Por ejemplo: # MANIFEST.in include *.csv Coloque el archivo MANIFEST.in en el mismo directorio que setup.py . Creaci\u00f3n de una distribuci\u00f3n de c\u00f3digo fuente Para crear una distribuci\u00f3n de su c\u00f3digo, utilice el archivo setup.py . Por ejemplo: bash % python3 setup.py sdist Esto crear\u00e1 un archivo .tar.gz o .zip en el directorio dist/ . Ese archivo es algo que ahora puedes regalar a otros. Instalaci\u00f3n de tu c\u00f3digo Otros pueden instalar tu c\u00f3digo Python usando pip de la misma manera que lo hacen con otros paquetes. Simplemente necesitan proporcionar el archivo creado en el paso anterior. Por ejemplo: bash % python3 -m pip install porty-0.0.1.tar.gz Comentario Los pasos anteriores describen los conceptos b\u00e1sicos m\u00e1s m\u00ednimos para crear un paquete de c\u00f3digo Python que puedes regalar a otra persona. En realidad, puede ser mucho m\u00e1s complicado dependiendo de las dependencias de terceros, si tu aplicaci\u00f3n incluye o no c\u00f3digo externo (es decir, C/C++), etc. Cubrir eso est\u00e1 fuera del alcance de este curso. Solo hemos dado un peque\u00f1o primer paso. Ejercicios Ejercicio 9.5: Crea un paquete Toma el c\u00f3digo porty-app/ que creaste para el Ejercicio 9.3 y ve si puedes recrear los pasos que se describen aqu\u00ed. Espec\u00edficamente, agrega un archivo setup.py y un archivo MANIFEST.in al directorio de nivel superior. Crea un archivo de distribuci\u00f3n de origen ejecutando python setup.py sdist . Como paso final, ve si puedes instalar tu paquete en un entorno virtual de Python. Contenido | Anterior (9.2 M\u00f3dulos de terceros) | Pr\u00f3ximo (Fin)","title":"03_Distribution"},{"location":"09_Packages/03_Distribution/#93-entrega-tu-codigo-a-terceros","text":"En alg\u00fan momento, es posible que desee entregar su c\u00f3digo a otra persona, posiblemente solo a un compa\u00f1ero de trabajo. Esta secci\u00f3n proporciona la t\u00e9cnica m\u00e1s b\u00e1sica para hacerlo. Para obtener informaci\u00f3n m\u00e1s detallada, deber\u00e1 consultar la Gu\u00eda del usuario de empaquetado de Python .","title":"9.3 Entrega tu c\u00f3digo a terceros"},{"location":"09_Packages/03_Distribution/#creacion-de-un-archivo-setuppy","text":"Agregue un archivo setup.py al nivel superior del directorio de su proyecto. # setup.py import setuptools setuptools.setup( name=\"porty\", version=\"0.0.1\", author=\"Your Name\", author_email=\"you@example.com\", description=\"Practical Python Code\", packages=setuptools.find_packages(), )","title":"Creaci\u00f3n de un archivo setup.py"},{"location":"09_Packages/03_Distribution/#creacion-de-manifestin","text":"Si hay archivos adicionales asociados con su proyecto, especif\u00edquelos con un archivo MANIFEST.in . Por ejemplo: # MANIFEST.in include *.csv Coloque el archivo MANIFEST.in en el mismo directorio que setup.py .","title":"Creaci\u00f3n de MANIFEST.in"},{"location":"09_Packages/03_Distribution/#creacion-de-una-distribucion-de-codigo-fuente","text":"Para crear una distribuci\u00f3n de su c\u00f3digo, utilice el archivo setup.py . Por ejemplo: bash % python3 setup.py sdist Esto crear\u00e1 un archivo .tar.gz o .zip en el directorio dist/ . Ese archivo es algo que ahora puedes regalar a otros.","title":"Creaci\u00f3n de una distribuci\u00f3n de c\u00f3digo fuente"},{"location":"09_Packages/03_Distribution/#instalacion-de-tu-codigo","text":"Otros pueden instalar tu c\u00f3digo Python usando pip de la misma manera que lo hacen con otros paquetes. Simplemente necesitan proporcionar el archivo creado en el paso anterior. Por ejemplo: bash % python3 -m pip install porty-0.0.1.tar.gz","title":"Instalaci\u00f3n de tu c\u00f3digo"},{"location":"09_Packages/03_Distribution/#comentario","text":"Los pasos anteriores describen los conceptos b\u00e1sicos m\u00e1s m\u00ednimos para crear un paquete de c\u00f3digo Python que puedes regalar a otra persona. En realidad, puede ser mucho m\u00e1s complicado dependiendo de las dependencias de terceros, si tu aplicaci\u00f3n incluye o no c\u00f3digo externo (es decir, C/C++), etc. Cubrir eso est\u00e1 fuera del alcance de este curso. Solo hemos dado un peque\u00f1o primer paso.","title":"Comentario"},{"location":"09_Packages/03_Distribution/#ejercicios","text":"","title":"Ejercicios"},{"location":"09_Packages/03_Distribution/#ejercicio-95-crea-un-paquete","text":"Toma el c\u00f3digo porty-app/ que creaste para el Ejercicio 9.3 y ve si puedes recrear los pasos que se describen aqu\u00ed. Espec\u00edficamente, agrega un archivo setup.py y un archivo MANIFEST.in al directorio de nivel superior. Crea un archivo de distribuci\u00f3n de origen ejecutando python setup.py sdist . Como paso final, ve si puedes instalar tu paquete en un entorno virtual de Python. Contenido | Anterior (9.2 M\u00f3dulos de terceros) | Pr\u00f3ximo (Fin)","title":"Ejercicio 9.5: Crea un paquete"},{"location":"09_Packages/TheEnd/","text":"\u00a1Fin! Has llegado al final del curso. Gracias por tu tiempo y tu atenci\u00f3n. \u00a1Que tu futuro hackeo de Python sea divertido y productivo! Siempre me alegra recibir comentarios. Puedes encontrarme en https://dabeaz.com o en Twitter en @dabeaz . - David Beazley. Por errores en la traducci\u00f3n Mario.Melchiori Contenido | Inicio","title":"TheEnd"},{"location":"09_Packages/TheEnd/#fin","text":"Has llegado al final del curso. Gracias por tu tiempo y tu atenci\u00f3n. \u00a1Que tu futuro hackeo de Python sea divertido y productivo! Siempre me alegra recibir comentarios. Puedes encontrarme en https://dabeaz.com o en Twitter en @dabeaz . - David Beazley. Por errores en la traducci\u00f3n Mario.Melchiori Contenido | Inicio","title":"\u00a1Fin!"}]}